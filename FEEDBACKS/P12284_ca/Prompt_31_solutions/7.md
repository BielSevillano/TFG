## Anàlisi del programa per trobar les paraules més freqüents

### Resum del problema i l'enfocament de la solució

El problema consisteix a llegir una seqüència de `n` paraules i escriure les `k` paraules més freqüents. En cas d'empat en la freqüència, s'han d'ordenar lexicogràficament (les paraules més petites primer).

L'enfocament de la solució presentada es basa en els següents passos:

1.  **Llegir les paraules:** Es llegeixen `n` paraules per a cada cas d'entrada.
2.  **Ordenar les paraules:** Les paraules es ordenen lexicogràficament. Això facilita la identificació de paraules consecutives idèntiques, que corresponen a la seva freqüència.
3.  **Trobar la paraula més freqüent (`mesfreq`):** Aquesta funció recorre la llista ordenada per trobar la paraula que apareix més vegades consecutivament. S'utilitza una lògica per comptar les aparicions consecutives i mantenir un registre de la paraula amb la freqüència màxima trobada fins al moment.
4.  **Eliminar la paraula més freqüent (`novallista`):** Un cop identificada la paraula més freqüent, aquesta funció la elimina de la llista original. Això és crucial per poder trobar la següent paraula més freqüent en la següent iteració.
5.  **Iterar per trobar les `k` paraules:** El programa repeteix els passos 3 i 4 `k` vegades, imprimint la paraula més freqüent trobada en cada iteració.
6.  **Imprimir separador:** Al final de cada cas, s'imprimeix una línia de 10 guions.

### Anàlisi del codi: Fortaleses i Debilitats

**Fortaleses:**

*   **Compreu el problema:** El codi intenta abordar el problema de manera directa, identificant la paraula més freqüent en cada iteració.
*   **Utilitza les funcions:** El codi està organitzat en funcions (`novallista`, `mesfreq`, `main`), la qual cosa millora la legibilitat i la modularitat.
*   **Ordenació inicial:** La ordenació inicial de la llista de paraules (`lst.sort()`) és un pas correcte per poder identificar freqüències de manera eficient.

**Debilitats i Errors:**

1.  **Error de funcionament a `mesfreq`:** La funció `mesfreq` té un error lògic significatiu en com calcula la paraula més freqüent i el seu índex.
    *   La lògica amb la variable `primer` és confusa i probablement incorrecta.
    *   Quan `act > max` es fa `max = i`. Això significa que `max` acaba emmagatzemant l'índex de la *última aparició* de la seqüència més freqüent, no necessàriament l'índex de la paraula en si que s'hauria de retornar.
    *   No gestiona correctament els empats en freqüència (les paraules més petites en ordre alfabètic). L'ordre alfabètic s'hauria de considerar *després* d'haver determinat la freqüència màxima.
    *   L'accés `lst[i + 1]` quan `i` podria ser l'últim índex de la llista (`n-1`) provoca un `IndexError`. Això ocorre quan `n > 1` i el bucle arriba al final.

2.  **Error de funcionament a `novallista`:** La funció `novallista` utilitza `lst.remove(a)` dins d'un bucle `while a in lst`. Aquesta operació és ineficient (es busca `a` repetidament) i pot ser lenta. A més, modificar una llista mentre s'itera sobre ella amb `while a in lst` pot portar a comportaments inesperats si hi ha múltiples instàncies de `a`. Una millor aproximació seria crear una nova llista sense les paraules desitjades.

3.  **Recursivitat implícita en la lògica de `main`:** Encara que no és una crida recursiva explícita, la lògica de `main` de trobar la paraula més freqüent, imprimir-la i després eliminar-la per repetir el procés per les següents `k` paraules és conceptualment similar a una recursió (o una iteració que simula la reducció del problema). Tot i que és una manera vàlida d'abordar el problema si la implementació de `mesfreq` fos correcta, aquest enfocament pot ser ineficient per a grans volums de dades i moltes iteracions de `k`. Les solucions de referència utilitzen diccionaris o estructures de dades similars per comptar freqüències de manera més directa.

4.  **Maneig d'inputs buits o casos extrems:** Encara que les especificacions del problema diuen que `k` està entre 1 i el nombre de paraules diferents, un codi robust hauria de considerar casos on la llista estigui buida o `k` sigui 0 (tot i que no és el cas aquí).

5.  **Index `i+1` a `mesfreq`:** L'accés `lst[i+1]` quan `i` és `n-1` causarà un `IndexError`. Això es pot produir si la paraula més freqüent és l'última de la llista ordenada.

### Suggeriments de millora

La millor manera de millorar aquest codi és adoptar un enfocament més eficient per comptar freqüències, similar al que s'observa en moltes de les solucions de referència:

1.  **Utilitzar un diccionari (o `collections.Counter`) per comptar freqüències:**
    *   Itereu per totes les paraules llegides.
    *   Utilitzeu un diccionari (`dict` en Python) on les claus siguin les paraules i els valors siguin les seves freqüències.
    *   Per a cada paraula llegida, si ja existeix al diccionari, incrementa el seu valor; si no, afegeix-la amb valor 1.

2.  **Ordenar les paraules basant-se en freqüència i ordre alfabètic:**
    *   Un cop tinguis el diccionari de freqüències, crea una llista de tuples `(paraula, freqüencia)`.
    *   Ordena aquesta llista. El criteri d'ordenació ha de ser:
        *   Primer, per freqüència en ordre descendent.
        *   En cas d'empat en freqüència, per la paraula en ordre alfabètic ascendent. Python permet fer això amb claus de comparació compostes.

3.  **Imprimir les `k` primeres paraules:** Després de l'ordenació, simplement imprimeix les primeres `k` paraules de la llista ordenada.

**Exemple d'implementació millorada (pseudocodi):**

```python
from yogi import tokens, read
from collections import Counter
from functools import cmp_to_key

def comparar(item1, item2):
    # item1 i item2 són tuples (paraula, freq)
    # Ordre: freq descendent, paraula ascendent
    if item1[1] != item2[1]:
        return item2[1] - item1[1] # Ordena per freqüència descendent
    else:
        if item1[0] < item2[0]:
            return -1 # Ordena per paraula ascendent
        elif item1[0] > item2[0]:
            return 1
        else:
            return 0

def main():
    for n in tokens(int):
        k = read(int)
        paraules_llegides = []
        for _ in range(n):
            paraules_llegides.append(read(str))

        # Comptar freqüències
        comptador = Counter(paraules_llegides)

        # Convertir a llista de tuples (paraula, freq)
        llista_freq = list(comptador.items())

        # Ordenar segons els criteris
        # Opció 1: Usant cmp_to_key (similar a les solucions de referència)
        llista_freq_ordenada = sorted(llista_freq, key=cmp_to_key(comparar))

        # Opció 2: Usant una lambda amb tuple (més "pythonic")
        # llista_freq_ordenada = sorted(llista_freq, key=lambda item: (-item[1], item[0]))

        # Imprimir les k paraules més freqüents
        for i in range(k):
            print(llista_freq_ordenada[i][0])
        print("-" * 10)

main()
```

En resum, el codi actual té un error greu en la seva lògica de cerca de la paraula més freqüent i una ineficiència en l'eliminació de paraules. La millor solució passa per un canvi d'estratègia cap a l'ús d'un diccionari per al recompte de freqüències i una ordenació eficient basada en els criteris especificats.