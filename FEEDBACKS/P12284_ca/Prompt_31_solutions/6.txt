This program aims to solve the "Most Frequent Words" problem by identifying and printing the `k` most frequent words from a given sequence, adhering to specific sorting rules: primarily by frequency (descending) and then by alphabetical order (ascending) for ties.

**Summary of the Problem and Solution Approach:**

The program implements a common strategy for this type of problem:
1.  **Read Input:** It reads `n` and `k`, then all `n` words for a given test case.
2.  **Initial Sort:** It first sorts the entire list of words alphabetically (`P.sort()`). This groups identical words together, making frequency counting efficient.
3.  **Count Frequencies:** It then iterates through the sorted list `P` to count the occurrences of each unique word. These unique words and their counts are stored in `Info` objects (`par` for the word, `num` for the count).
4.  **Final Sort:** It attempts to sort this list of `Info` objects (`V`) based on the problem's criteria:
    *   Higher frequency first (`a.num > b.num`).
    *   For ties in frequency, alphabetically smaller word first (`a.par < b.par`).
5.  **Output:** Finally, it prints the `par` attribute (the word) of the first `k` `Info` objects from the sorted list, followed by the "----------" separator. This process repeats for multiple test cases.

**Analysis of the Code's Strengths and Weaknesses:**

**Strengths:**

*   **Clear Data Structure:** The `Info` class (`par`, `num`) is well-defined and clearly represents the word-frequency pair.
*   **Efficient Frequency Counting:** Sorting the initial list of words (`P.sort()`) and then performing a single pass to count consecutive duplicates (`while j < n and P[j] == P[i]: j += 1`) is an efficient and standard way to determine word frequencies.
*   **Modularity:** Separating the comparison logic into a `comp` function makes the sorting criteria explicit.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly processes multiple input cases.

**Weaknesses (and the reason for "Wrong Answer"):**

*   **Incorrect Usage of `sort(key=...)` in Python 3:** The primary issue leading to "Wrong Answer" is how the `V.sort(key=comp, reverse=True)` line is used.
    *   In Python 3, the `key` argument to `list.sort()` (or `sorted()`) expects a function that takes *one argument* (an element from the list) and returns a *comparison key*. Python then uses its default comparison rules on these keys.
    *   The `comp` function, however, is a traditional *comparison function* (like C++'s `std::sort` predicate) that takes *two arguments* (`a` and `b`) and returns `True` if `a` should come before `b`.
    *   When `V.sort(key=comp, reverse=True)` is called, Python tries to pass a single `Info` object (e.g., `V[j]`) to `comp`, which expects two. This will either raise a `TypeError` at runtime if `yogi` allows it, or, in some environments (or with slightly different `comp` structure), it might simply return an unexpected boolean or object, leading to incorrect sorting without an obvious error message. The `reverse=True` further complicates the interpretation of `comp`'s return value.

**Suggestions for Improvement:**

1.  **Correct Sorting with a `key` Function (Recommended Pythonic Approach):**
    The most straightforward and Pythonic way to implement the custom sort order is to define a `key` function that returns a tuple. Python's default tuple comparison handles this naturally: it compares the first elements, if they are equal, it compares the second, and so on.
    To achieve descending frequency and then ascending alphabetical order:
    *   For frequency, return its negative value (`-x.num`). This makes higher frequencies compare as "smaller" when sorted, achieving a descending sort.
    *   For the word, return the word directly (`x.par`). This ensures ascending alphabetical sort for ties.

    Modify the sorting line from:
    ```python
    V.sort(key=comp, reverse=True)
    ```
    to:
    ```python
    # No need for the 'comp' function or 'reverse=True' with this approach
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    You can then remove the `comp` function definition entirely.

2.  **Using `functools.cmp_to_key` (Alternative for `cmp`-style functions):**
    If you specifically want to keep a `cmp`-style comparison function (like `comp` is structured), you can adapt it for `key` using `functools.cmp_to_key`. You would need to ensure `comp` returns -1, 0, or 1 to properly represent `<,=,>`:

    ```python
    import functools # Add this import at the top

    # Define comp to return -1, 0, or 1
    def comp(a, b):
      if a.num != b.num:
        return -1 if a.num > b.num else 1 # a.num > b.num means 'a' comes first (is "less" in comparison value)
      if a.par != b.par:
        return -1 if a.par < b.par else 1 # a.par < b.par means 'a' comes first
      return 0

    # Then use it like this (without reverse=True, as 'comp' already defines the full order)
    V.sort(key=functools.cmp_to_key(comp))
    ```
    However, the `lambda` tuple approach (Suggestion 1) is generally preferred in modern Python for its simplicity and efficiency.

By fixing the sorting mechanism, the program should produce the correct output according to the problem's requirements.