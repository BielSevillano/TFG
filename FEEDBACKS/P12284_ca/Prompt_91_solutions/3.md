## Feedback del Programa "Paraules més freqüents"

### Resum del problema i l'aproximació

El problema demana llegir una seqüència de `n` paraules i escriure les `k` paraules més freqüents. En cas d'empat en la freqüència, les paraules s'han d'ordenar lexicogràficament (alfabèticament) de menor a major. El programa ha de processar diversos casos d'entrada, separant cada cas amb una línia de 10 guions.

L'aproximació utilitzada en el codi consisteix en els següents passos:

1.  **Llegir `n` i `k`**: Per a cada cas, es llegeixen els valors de `n` (nombre de paraules) i `k` (nombre de paraules freqüents a mostrar).
2.  **Llegir les paraules**: Es llegeixen les `n` paraules d'entrada.
3.  **Emmagatzemar i comptar freqüències**: El codi crea una llista `P` per emmagatzemar les paraules. Després, les ordena (`P.sort()`) per agrupar les paraules idèntiques. Posteriorment, recorre la llista ordenada per comptar la freqüència de cada paraula única i emmagatzema aquesta informació en una nova llista `V` de `Info` objectes (que contenen la paraula i la seva freqüència).
4.  **Definir un criteri de comparació**: Es defineix una funció `comp(a, b)` que compara dos `Info` objectes. Prioritza la freqüència (descendent) i, en cas d'empat, l'ordre lexicogràfic de la paraula (ascendent).
5.  **Ordenar per freqüència**: La llista `V` (amb els `Info` objectes) s'ordena utilitzant la funció `comp` definida, en ordre descendent (`reverse=True`).
6.  **Imprimir les `k` paraules més freqüents**: Es recorren els primers `k` elements de la llista ordenada `V` i s'imprimeix la paraula de cadascun d'ells.
7.  **Imprimir separador**: S'imprimeix una línia de 10 guions.
8.  **Repetir per a nous casos**: El bucle `while` continua mentre `n` i `k` siguin llegibles.

### Anàlisi del Codi

#### Fortaleses:

*   **Estructura de Dades `Info`**: La creació d'una classe `Info` per emmagatzemar tant la paraula com la seva freqüència és una bona pràctica per organitzar la informació.
*   **Criteri de Comparació Clar**: La funció `comp` implementa correctament la lògica de comparació requerida: primer per freqüència (descendent) i després per ordre lexicogràfic (ascendent).
*   **Ordenació Eficient**: L'ús de `P.sort()` per agrupar les paraules i posteriorment calcular les freqüències és una estratègia raonable.
*   **Lògica de Comptatge de Freqüències**: El bucle `while i < n` per calcular les freqüències de les paraules consecutives és correcte.
*   **Ús de `yogi.read`**: La utilització de `yogi.read` per a la lectura d'entrada és adequada per a l'entorn del problema.

#### Debilitats i Possibles Millores:

*   **Claritat en la Lectura de `n` i `k`**: El bucle `while n is not None and k is not None:` llegeix `n` i `k` a l'inici i al final del bucle. Això és correcte, però cal assegurar-se que `yogi.read(int)` retorna `None` quan ja no hi ha més entrades per a `n` i `k`.
*   **Noms de Variables**: Els noms de variables com `P` i `V` podrien ser més descriptius. Per exemple, `paraules_llegides` per a `P` i `freq_paraules` per a `V`.
*   **Funcionalitat del `comp`**: La definició de `comp` és correcte, però l'ús de `reverse=True` a `V.sort(key=comp, reverse=True)` pot ser una mica redundant ja que la lògica dins de `comp` ja retorna un ordre que, combinat amb `reverse=True`, podria portar a confusió. Una alternativa seria ajustar la lògica de `comp` per a que l'ordre desitjat sigui directe amb `reverse=False` o mantenir-la tal qual i ser conscient del doble negatiu. La lògica actual de `comp` retorna `True` si `a` és "millor" que `b` (freqüència més alta o paraula menor en cas d'empat). Amb `reverse=True`, `sort` posa els elements considerats "millors" al principi. El que fa que el codi sigui correcte.
*   **Eficiència en la Lectura de `n` i `k`**: Si un dels dos (`n` o `k`) és `None`, el `while` continua. Per exemple, si `n` és `None` però `k` té valor, el `while` s'executarà una vegada més intentant llegir `n` com a `int` (que fallaria o donaria un error). Seria millor comprovar si `n` és `None` abans de llegir `k`.
*   **Consideració sobre "Wrong Answer"**: Si el codi ha donat "Wrong Answer", cal investigar a fons els casos límit. Les possibles causes podrien ser:
    *   **Empats no tractats correctament**: Encara que la funció `comp` sembla correcta, un error subtil en la seva implementació o ús podria ser la causa.
    *   **Casos amb poques paraules diferents**: Si hi ha menys de `k` paraules diferents, el problema indica que `k` estarà entre 1 i el nombre de paraules diferents. Això simplifica les coses, però sempre és bo tenir-ho en compte.
    *   **Entrada buida o `n=0`**: Encara que les restriccions del problema indiquen que `n` i `k` són vàlids, si hi hagués un cas d'entrada buida, el codi podria fallar.

### Suggeriments de Millora

1.  **Validació d'entrada al bucle principal**:
    Es podria millorar la gestió del final de l'entrada:

    ```python
    n = yogi.read(int)
    while n is not None:
        k = yogi.read(int)
        # Comprovar si k també és llegible
        if k is None:
            break # Sortir si no es pot llegir k

        P = []
        # ... (resta del codi) ...

        print("----------")
        n = yogi.read(int) # Llegeix el proper n abans de tornar a entrar al bucle
    ```

2.  **Noms de variables més descriptius**:
    *   Canviar `P` a `paraules_llegides`.
    *   Canviar `V` a `freq_paraules`.
    *   La classe `Info` podria ser `ParaulaFreq` per ser més explícita.

3.  **Refinament de la funció `comp` (opcional)**:
    La funció `comp` ja és correcta. Si es volgués fer servir `sort()` sense `reverse=True`, es podria modificar `comp` per a que retorni `a.num < b.num` si `a.num != b.num`, i `a.par > b.par` si `a.par != b.par`. Tot i això, l'aproximació actual és clara i funcional.

4.  **Ús de `collections.Counter`**: Per a un codi més pythonic i potent en el càlcul de freqüències, es podria utilitzar `collections.Counter`. Això simplificaria la part de comptatge:

    ```python
    from collections import Counter
    import yogi

    # ... (definició de Info i comp) ...

    def main():
        n = yogi.read(int)
        k = yogi.read(int)
        while n is not None and k is not None:
            paraules_llegides = [yogi.read(str) for _ in range(n)]
            
            # Utilitzar Counter per comptar freqüències
            freq_map = Counter(paraules_llegides)
            
            # Convertir a la llista d'Info objects
            freq_paraules = []
            for paraula, freq in freq_map.items():
                freq_paraules.append(Info(paraula, freq))

            # ... (resta del codi: ordenar i imprimir) ...
    ```
    Aquesta opció requereix importar `Counter` de `collections`.

5.  **Gestió d'errors implícita**: El codi assumeix que `yogi.read(int)` retornarà `None` quan acabi l'entrada de `n` i `k`. Si el format d'entrada fos diferent o si hi hagués errors de format, s'haurien de considerar excepcions.

### Codi Millorat (Exemple amb `Counter` i noms més descriptius)

```python
import yogi
from collections import Counter
from functools import cmp_to_key # Per utilitzar cmp amb sort

# Define struct Info
class ParaulaFreq:
    def __init__(self, paraula: str, freq: int):
        self.paraula = paraula
        self.freq = freq

# Define comparator function
def cmp_paraules(a: ParaulaFreq, b: ParaulaFreq) -> int:
    # Criteri: 1) Major freqüència, 2) Menor ordre lexicogràfic
    if a.freq != b.freq:
        return b.freq - a.freq  # Ordena per freqüència descendent
    return -1 if a.paraula < b.paraula else 1 # Ordena per paraula ascendent en cas d'empat

# main function
def main():
    n = yogi.read(int)
    while n is not None: # Bucle principal per a múltiples casos
        k = yogi.read(int)
        if k is None: # Si no es pot llegir k, finalitzar.
            break

        paraules_llegides = [yogi.read(str) for _ in range(n)]

        # Utilitzar Counter per comptar freqüències eficientment
        freq_map = Counter(paraules_llegides)

        # Convertir el Counter a una llista d'objectes ParaulaFreq
        freq_paraules: list[ParaulaFreq] = []
        for paraula, freq in freq_map.items():
            freq_paraules.append(ParaulaFreq(paraula, freq))

        # Ordenar la llista segons el criteri definit
        # cmp_to_key és necessari per usar una funció de comparació amb sort()
        freq_paraules.sort(key=cmp_to_key(cmp_paraules))

        # Imprimir les k paraules més freqüents
        for i in range(k):
            print(freq_paraules[i].paraula)

        # Imprimir separador
        print("----------")

        # Llegeix el proper n per continuar el bucle
        n = yogi.read(int)

# Call main function
if __name__ == "__main__":
    main()
```

**Nota sobre l'ordre de lectura de `n` i `k`**: En molts sistemes de jutge en línia, la lectura d'entrada es fa de manera que `yogi.read(int)` retorna `None` quan ja no hi ha més dades. El bucle `while n is not None and k is not None:` és una manera de gestionar això, però pot ser més robust llegir `n`, comprovar si és `None`, i després llegir `k`. En el codi millorat, es fa aquesta validació.

L'únic que hauries de fer per arreglar el "Wrong Answer" és centrar-te en l'ordenació. La lògica de comptatge és correcta, però la manera com s'ordena podria ser la causa del problema. Si segueixes els suggeriments de millora i proves amb els exemples, hauries de poder identificar el problema.