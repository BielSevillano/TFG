Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents

**1. Problem and Solution Approach Summary:**

The problem requires finding the `k` most frequent words from a sequence of `n` input words. In case of a tie in frequency, words should be sorted alphabetically. The program needs to handle multiple test cases and print a separator line after each case.

The chosen approach is robust and common for this type of problem:
1.  Read all `n` words into a list (`P`).
2.  Sort this list alphabetically (`P.sort()`). This groups identical words together.
3.  Iterate through the sorted list to count the frequency of each unique word. Store these unique words and their counts in a list of custom `Info` objects (`V`).
4.  Sort this list of `Info` objects based on the problem's criteria: descending frequency, then ascending alphabetical order for ties.
5.  Print the `par` (word) component of the first `k` sorted `Info` objects.

**2. Analysis of the Code's Strengths and Weaknesses:**

**Strengths:**

*   **Clear Data Structure:** The `Info` class (with `par` for word and `num` for count) is an excellent way to encapsulate the necessary data for each unique word.
*   **Correct Input Handling:** The `while n is not None and k is not None:` loop correctly handles multiple test cases as specified by `Jutge.org`.
*   **Efficient Frequency Counting:** Sorting the initial list of words (`P.sort()`) and then iterating through it once to count frequencies is an efficient and standard technique (O(N log N) for sort + O(N) for counting).
*   **Readability:** The code is well-structured and easy to follow, clearly delineating steps like input reading, frequency calculation, and output printing.

**Weaknesses:**

*   **Incorrect Comparator Usage for Sorting:** The core issue leading to "Wrong Answer" is likely in this line:
    ```python
    V.sort(key=comp, reverse=True)
    ```
    In Python 3, the `key` argument for `list.sort()` (or `sorted()`) expects a function that takes *one* argument (an element from the list) and returns a *comparison key*. It does not directly accept a two-argument comparison function like C++'s `std::sort` predicate.
    Your `comp` function:
    ```python
    def comp(a, b):
      if a.num != b.num:
        return a.num > b.num
      return a.par < b.par
    ```
    This function returns a boolean (`True` or `False`). When `key` receives a boolean, it attempts to sort the `Info` objects based on these boolean values, which does not achieve the desired complex sorting criteria. This will lead to an incorrect order.

**3. Suggestions for Improvement:**

The primary improvement needed is to correct the sorting of the `V` list. There are a few idiomatic Python ways to achieve this:

**Option 1: Using a `lambda` function for `key` (Most concise for simple multi-criteria sorts)**

You can define the `key` to return a tuple. Python sorts tuples lexicographically. To achieve descending frequency, we negate `a.num`. For ascending alphabetical, `a.par` is used directly.

```python
# ... (rest of your code remains the same)

# main function
def main():
  # ... (initial variable setup)

    # V is already created as a list of Info objects

    # Sort V using a lambda key for multi-criteria sorting
    # (-x.num for descending frequency, x.par for ascending alphabetical)
    V.sort(key=lambda x: (-x.num, x.par))

    # ... (rest of your code remains the same)
```
With this approach, you no longer need the separate `comp` function or `reverse=True`.

**Option 2: Implementing `__lt__` in the `Info` class (More object-oriented)**

You can make your `Info` class directly comparable by implementing the `__lt__` (less than) method. This allows `list.sort()` to work without a `key` or `reverse` argument (it will sort based on `__lt__` by default).

```python
# define struct Info
class Info:
  def __init__(self, par, num):
    self.par = par
    self.num = num

  # Define how Info objects are compared
  def __lt__(self, other):
    # Primary sort: higher frequency comes first (so current.num > other.num)
    # If self.num is greater, it should come *before* other, so return True
    if self.num != other.num:
      return self.num > other.num # True if self is "less" (i.e., higher priority)

    # Secondary sort: smaller word alphabetically comes first
    return self.par < other.par

# main function
def main():
  # ... (initial variable setup)

    # Sort V. The __lt__ method handles the custom comparison logic.
    V.sort() # No 'key' or 'reverse' needed here!

    # ... (rest of your code remains the same)
```
In this case, the `comp` function would become redundant and could be removed.

**Option 3: Using `functools.cmp_to_key` (if you prefer the `cmp`-style function)**

If you specifically want to keep your `comp(a, b)` function structure (returning `True`/`False` or -1/0/1), you can adapt it with `functools.cmp_to_key`.

First, modify `comp` to return -1, 0, or 1 as expected by `cmp_to_key`:
```python
import functools # Add this import at the top

# define comparator function
def comp_func(a, b): # Renamed to avoid conflict with 'key' if used
  if a.num > b.num:
    return -1 # a comes before b (higher frequency)
  if a.num < b.num:
    return 1  # b comes before a
  # Frequencies are equal, compare words alphabetically
  if a.par < b.par:
    return -1 # a comes before b (smaller word)
  if a.par > b.par:
    return 1  # b comes before a
  return 0    # words are equal (shouldn't happen with unique words in V)

# main function
def main():
  # ... (initial variable setup)

    # Sort V using cmp_to_key
    V.sort(key=functools.cmp_to_key(comp_func)) # No 'reverse' needed!

    # ... (rest of your code remains the same)
```

**Recommendation:**

For simplicity and common Python practice, **Option 1 (using `lambda` with a tuple key)** is often the preferred choice for this kind of multi-criteria sorting. If the comparison logic becomes very complex, implementing `__lt__` (Option 2) can lead to cleaner code within the class itself.

By implementing one of these fixes, your program should correctly sort the words according to frequency and alphabetical order, resolving the "Wrong Answer".

---