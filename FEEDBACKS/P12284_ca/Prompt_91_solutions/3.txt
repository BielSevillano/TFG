Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents

**1. Summary of the Problem and Solution Approach:**

The problem requires reading a sequence of `n` words and identifying the `k` most frequent ones. In the case of a tie in frequency, words should be ordered alphabetically (lexicographically ascending). The program should handle multiple test cases, printing a separator `----------` after each.

The provided Python solution adopts a common and generally efficient approach:
1.  **Read all words:** All `n` words are read into a list `P`.
2.  **Initial Sort:** `P` is sorted alphabetically. This step is crucial as it groups identical words together, making frequency counting much simpler.
3.  **Frequency Counting:** The program then iterates through the sorted list `P` to count the occurrences of each unique word. It stores these unique words along with their counts in a list `V` of `Info` objects (where `Info` is a custom class holding the word (`par`) and its count (`num`)).
4.  **Final Sort:** The list `V` (containing unique words and their frequencies) is sorted according to the problem's criteria: descending by frequency, and then ascending alphabetically for ties.
5.  **Output:** The first `k` words from the sorted `V` list are printed, followed by the specified separator.

**2. Analysis of the Code's Strengths and Weaknesses:**

**Strengths:**

*   **Clear Problem Understanding:** The overall logic correctly addresses the problem requirements, including counting frequencies and handling tie-breaking rules.
*   **Good Data Structure Usage:** The `Info` class is a suitable way to encapsulate a word and its frequency, making the code more readable and organized.
*   **Efficient Frequency Counting:** Sorting the initial list of words (`P.sort()`) and then iterating through it to count frequencies using a two-pointer approach (`while i < n` and `while j < n`) is an efficient and standard way to determine word frequencies.
*   **Modularity:** Defining a separate `Info` class and a `comp` function contributes to code organization.
*   **Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly handles multiple test cases as specified.

**Weaknesses:**

*   **Critical Error in Sorting Logic (Primary Cause for "Wrong Answer"):** The main issue lies in how the `comp` function is used with `list.sort()`. In Python 3, the `key` argument for `list.sort()` (or `sorted()`) expects a function that takes *one* element from the list and returns a value to be used for comparison. The `comp` function, however, is defined to take *two* arguments (`a` and `b`) and performs a comparison between them.
    *   Attempting to use `V.sort(key=comp, reverse=True)` will result in a `TypeError` because `comp` will be called with only one argument (an `Info` object) instead of two.
    *   If by some chance it didn't immediately `TypeError` in a specific environment, it would certainly not produce the correct sorting, leading to "Wrong Answer".
    *   Python's `key` function typically returns a tuple for multi-criteria sorting, where Python's default tuple comparison handles the priority and order of elements.

**3. Suggestions for Improvement:**

The primary suggestion is to fix the sorting logic to correctly implement the desired comparison.

1.  **Corrected Sorting using a Lambda Key (Most Pythonic):**
    The most idiomatic and correct way to achieve the desired sorting in Python 3 is to provide a `key` function that returns a tuple. Python's default tuple comparison sorts elements lexicographically. To achieve descending order for frequency and ascending for words, we can negate the frequency.

    *   **Remove the `comp` function definition entirely.**
    *   **Modify the sorting line:**
        ```python
        # Sort V: descending by frequency (-x.num) then ascending by word (x.par)
        V.sort(key=lambda x: (-x.num, x.par))
        ```
        *   `lambda x: (-x.num, x.par)`: This anonymous function takes an `Info` object `x` and returns a tuple `(-x.num, x.par)`.
        *   When `V.sort()` uses this key, it will first compare the negative frequencies. A larger positive frequency becomes a smaller negative number, ensuring descending order.
        *   If the negative frequencies are equal (meaning actual frequencies are equal), it then compares `x.par` (the word itself), sorting them alphabetically in ascending order, which matches the tie-breaking rule.
        *   The `reverse=True` is no longer needed with this tuple-based key, as the negation already handles the descending order for frequency.

2.  **Minor Optimization (for very large `n` and small `k`):**
    While the current approach of sorting `V` is generally acceptable, for extremely large `n` (total words) and very small `k` (number of words to print), it might be slightly more efficient to use a min-heap (priority queue) of size `k` to keep track of the `k` most frequent words. This avoids sorting the entire `V` list, which could contain many unique words. However, this is usually an advanced optimization and not strictly necessary for most competitive programming constraints. For this problem, the corrected `V.sort(key=...)` is likely efficient enough.

---