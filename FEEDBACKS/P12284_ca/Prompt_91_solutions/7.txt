The program aims to solve the "Paraules més freqüents" problem, which requires finding the `k` most frequent words from a given sequence of `n` words. In case of a tie in frequency, words should be ordered alphabetically.

**Summary of the solution approach:**
The program first reads all `n` words into a list `P`. It then sorts `P` alphabetically. After sorting, it iterates through `P` to count the frequency of each unique word. These unique words and their counts are stored in a list `V` of `Info` objects (where `Info` stores the word `par` and its count `num`). Finally, `V` is intended to be sorted based on frequency (descending) and then alphabetically (ascending) for ties, and the first `k` words are printed.

**Analysis of the code's strengths and weaknesses:**

**Strengths:**
*   **Clear Structure:** The code is well-structured with a dedicated `Info` class for word-frequency pairs and a `main` function encapsulating the logic.
*   **Efficient Frequency Counting:** The approach of sorting all input words first (`P.sort()`) and then iterating through the sorted list to count consecutive occurrences (`while j < n and P[j] == P[i]: j += 1`) is efficient and correct. This reduces the problem of counting frequencies for `n` words to a single pass after an initial `O(N log N)` sort.
*   **Correct Input/Output Handling:** The program correctly reads `n` and `k` for multiple test cases and prints the `----------` separator as required.

**Weaknesses:**
*   **Incorrect Comparator Usage for Python's `sort()`:** The primary reason for the "Wrong Answer" is the incorrect usage of the `comp` function with `V.sort(key=comp, reverse=True)`.
    *   In Python, the `key` argument for `list.sort()` (or `sorted()`) expects a function that takes **one argument** (an element from the list) and returns a value to be used for comparison.
    *   The `comp(a, b)` function provided is a **two-argument comparator** (like those used in C++'s `std::sort`), designed to return `True` if `a` should come before `b`.
    *   When `key=comp` is used, Python's `sort` attempts to call `comp(an_Info_object)` which fails because `comp` expects two arguments. Even if it were syntactically valid, its return value (`True` or `False`) would be used for sorting, which is not the intended behavior.

**Suggestions for improvement:**

1.  **Correct the Sorting Logic for `V`:**
    To achieve the desired sorting (descending frequency, then ascending alphabetical for ties), the `V.sort()` call needs a `key` function that returns a tuple where the first element handles descending frequency and the second handles ascending alphabetical order.

    Replace the `V.sort(key=comp, reverse=True)` line with:
    ```python
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    *   `lambda x: ...` creates an anonymous function that takes one `Info` object `x`.
    *   `x.num` (frequency) is negated (`-x.num`) to achieve **descending** order (higher frequency comes first).
    *   `x.par` (word) is used as is for **ascending** alphabetical order in case of a tie in frequency. Python's tuple comparison will handle this automatically: it compares elements from left to right.

2.  **Remove the Unused `comp` Function:** Since the `lambda` function directly provides the key for sorting, the custom `comp` function is no longer needed and can be removed, simplifying the code.

By implementing this change, the program will correctly sort the words according to the problem's specifications, resolving the "Wrong Answer".