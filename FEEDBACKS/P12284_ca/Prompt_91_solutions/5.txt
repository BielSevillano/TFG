Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**Summary of the Problem:**
The task is to read a sequence of `n` words and an integer `k`. The program must then identify and print the `k` most frequent words from the input. In case of a tie in frequency, words should be sorted and printed in ascending alphabetical order. This process needs to be repeated for multiple test cases, with a separator line (`----------`) after each case.

**Solution Approach in the Provided Code:**
The program implements the following steps:
1.  **Reads Input:** Reads `n`, `k`, and then `n` words for each test case.
2.  **Initial Sorting:** Stores all `n` words in a list `P` and sorts `P` alphabetically. This groups identical words together.
3.  **Frequency Counting:** Iterates through the sorted list `P` to count the occurrences of each unique word. It uses a custom `Info` class to store each unique word along with its frequency. These `Info` objects are collected in a list `V`.
4.  **Final Sorting:** Sorts the list `V` of `Info` objects. The intent is to sort primarily by frequency in descending order, and secondarily by word in ascending alphabetical order. A custom comparison function `comp` is defined for this purpose.
5.  **Output:** Prints the `par` (word) attribute of the first `k` elements from the sorted `V`, followed by the separator line.

**Analysis of the Code:**

**Strengths:**
*   **Clear Structure:** The code is well-structured, logically dividing the problem into distinct steps (input, initial sort, frequency count, final sort, output).
*   **Custom Data Structure:** The `Info` class (`par` for word, `num` for frequency) is an appropriate and clear way to manage word-frequency pairs.
*   **Efficient Frequency Counting:** By first sorting all input words (`P.sort()`), the program efficiently counts frequencies in a single pass through the sorted list. This approach is generally efficient (O(N log N) for the initial sort, then O(N) for counting).
*   **Multi-case Handling:** The `while n is not None and k is not None:` loop correctly handles multiple test cases as specified.

**Weaknesses and Reason for "Wrong Answer":**

The core issue likely lies in the application of the custom comparison function `comp` for sorting the `V` list:

1.  **Incorrect Use of `key` in `list.sort()`:** In standard Python, the `key` argument for `list.sort()` (or `sorted()`) expects a function that takes *one* argument (an element from the list) and returns a value to be used for comparison. Your `comp` function, however, is defined to take *two* arguments (`a` and `b`).
    *   If `yogi.sort` strictly follows standard Python `list.sort` behavior, this line `V.sort(key=comp, reverse=True)` should result in a `TypeError` (e.g., `comp() missing 1 required positional argument: 'b'`). Since the verdict is "Wrong Answer" and not "Runtime Error", it suggests that either the `yogi` environment has a non-standard `sort` implementation, or there's a subtle way this specific usage is interpreted without crashing.

2.  **Redundant/Conflicting `reverse=True` (if `comp` is interpreted as a comparison function):**
    *   Assuming `yogi.sort` might, non-standardly, accept `comp` as a pairwise comparison function (like C++ `std::sort` takes a custom comparator `bool comp(A a, A b)` that returns `true` if `a` should precede `b`):
        *   Your `comp` function correctly expresses the desired ordering: `a.num > b.num` means `a` comes before `b` if `a` has higher frequency; `a.par < b.par` means `a` comes before `b` if frequencies are tied and `a` is alphabetically smaller.
        *   This `comp` function *already* defines the "preferred" order for the final output (highest frequency, then smallest word). If `yogi.sort` uses this comparison directly, it would naturally sort `V` into the correct order.
        *   Adding `reverse=True` in this scenario would then *invert* this desired order, leading to a "Wrong Answer" because the words would be sorted by lowest frequency (or highest word alphabetically in case of ties) first.

**Suggestions for Improvement:**

1.  **Correct Pythonic Sorting:** The most idiomatic and correct way to achieve the desired sorting in Python is to provide a `key` function that returns a tuple. This allows for multi-level sorting criteria. For descending frequency (highest first) and then ascending word (alphabetically smallest first):

    ```python
    # Define comparator as a key function returning a tuple
    # No need for the separate 'comp' function with two arguments
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    Here, `-x.num` ensures that higher frequencies (which become smaller negative numbers) are sorted first in an ascending sort, and `x.par` then correctly sorts alphabetically for ties. The `reverse=True` argument is no longer needed with this `key`.

2.  **Remove or Correct `comp`:** If the `comp` function is kept, it should ideally be converted to a key function (as in the lambda above) or used with `functools.cmp_to_key` if a Python 2-style comparison function is strictly required (though this is less Pythonic in modern code). Given the current definition, it's best to replace its usage.

By implementing the corrected sorting key, the program should produce the desired output.

---