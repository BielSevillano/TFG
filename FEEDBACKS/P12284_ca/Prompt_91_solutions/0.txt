Here's feedback for the provided Python program:

## Feedback: Paraules més freqüents

### 1. Problem Summary and Solution Approach

The program aims to identify and print the `k` most frequent words from a given sequence of `n` words. The sorting criteria are: first, by frequency in descending order, and second, in case of a tie in frequency, by alphabetical order (lexicographically smallest first) in ascending order. Each test case's output should be separated by a line of ten dashes.

The chosen solution approach involves:
1.  Reading all `n` words into a list (`P`).
2.  Sorting this list alphabetically (`P.sort()`) to group identical words together.
3.  Iterating through the sorted list to count the occurrences of each unique word, storing each unique word and its frequency in a custom `Info` object, and collecting these objects in a new list (`V`).
4.  Sorting the list of `Info` objects (`V`) based on the problem's criteria (frequency descending, then word ascending).
5.  Printing the `par` (word) attribute of the first `k` `Info` objects from the sorted list.
6.  Handling multiple test cases and printing the separator.

### 2. Analysis of Code's Strengths and Weaknesses

**Strengths:**

*   **Clear Data Structure:** The `Info` class neatly encapsulates the word (`par`) and its frequency (`num`), which is good practice for organizing related data.
*   **Efficient Frequency Counting:** The strategy of first sorting all words (`P.sort()`) and then iterating to count consecutive duplicates (`while j < n and P[j] == P[i]:`) is an efficient way to determine unique word frequencies, especially for large inputs.
*   **Modularity:** The custom `comp` function clearly attempts to define the sorting logic, separating it from the main flow.
*   **Input/Output Handling:** The program correctly reads `n` and `k`, processes multiple test cases, and prints the required "----------" separator.

**Weaknesses:**

*   **Incorrect Comparator Usage (Primary Issue):** The main reason for the "Wrong Answer" lies in how the `V.sort(key=comp, reverse=True)` line is used.
    *   In Python 3, the `list.sort()` method's `key` argument expects a callable that takes *one* argument (an element from the list) and returns a *single value* to be used for comparison. The `comp` function, as written, takes *two* arguments (`a`, `b`) and returns a boolean (`True` or `False`).
    *   When `key=comp` is used, the `sort` function attempts to use `comp(item)` for each `item` in `V`, which is not what `comp` is designed for. Even if it were to somehow pass two arguments, sorting by boolean values (`True` or `False`) and then attempting to reverse it is not the correct way to implement the specified comparison logic.
    *   The `reverse=True` argument further complicates the intended logic if `comp` were a traditional comparison function (which Python 3's `sort` generally discourages in favor of `key` or `functools.cmp_to_key`).

### 3. Suggestions for Improvement

The primary improvement needed is to correct the sorting logic for the `V` list.

1.  **Correct the Sorting of `V`:**
    *   The most Pythonic and correct way to achieve the desired sorting criteria (descending frequency, then ascending alphabetical order) is to use a `lambda` function with the `key` argument that returns a *tuple*. Python's sorting mechanism compares tuples element by element.
    *   Modify the line:
        ```python
        # Original:
        # V.sort(key=comp, reverse=True)

        # Corrected:
        V.sort(key=lambda x: (-x.num, x.par))
        ```
    *   **Explanation:**
        *   `lambda x: ...` creates an anonymous function that takes one `Info` object `x` (representing `a` or `b` in your `comp` function).
        *   `(-x.num, x.par)` creates a tuple for each `Info` object.
        *   By putting `-x.num`, the frequencies will be effectively sorted in descending order (e.g., -5, -4, -3 will sort as -5, -4, -3, which corresponds to 5, 4, 3 in descending order).
        *   `x.par` then serves as the secondary sorting key. Since strings are compared alphabetically by default, this correctly handles the ascending lexicographical order tie-breaking rule.

2.  **Remove Unused Code:**
    *   Once the `lambda` function is used for sorting `V`, the `comp` function is no longer needed and can be removed for cleaner code.

3.  **Consider `collections.Counter` for Conciseness (Minor/Advanced):**
    *   While your manual counting loop is correct and efficient, Python's `collections.Counter` can often simplify frequency counting.
    *   You could replace the `P.sort()` and the subsequent `while i < n:` loop with:
        ```python
        from collections import Counter
        # ... inside main() after reading n words ...
        words_count = Counter(P) # P is the list of all words read
        V = [Info(word, count) for word, count in words_count.items()]
        # Then sort V as suggested above:
        V.sort(key=lambda x: (-x.num, x.par))
        ```
    *   This is an alternative for more concise frequency counting, but the primary fix for the "Wrong Answer" is the sorting comparator.

By implementing the corrected sorting key for `V`, the program should correctly pass the test cases.