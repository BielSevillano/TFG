Here's a feedback text for your program:

---

**Feedback for "Paraules més freqüents" Program**

**Verdict:** Wrong Answer

**1. Problem and Solution Approach Summary**

The problem asks to read a sequence of `n` words and print the `k` most frequent ones. In case of a tie in frequency, words should be sorted in ascending alphabetical order. The input consists of multiple test cases, each starting with `n` and `k`, followed by `n` lowercase words. The output for each case should be the `k` selected words, each on a new line, followed by a separator line of `----------`.

Your program implements the following approach:
1.  It reads all `n` input words into a list `P`.
2.  It sorts `P` alphabetically. This is a good initial step as it groups identical words together.
3.  It then iterates through the sorted list `P` to count the frequency of each unique word. These unique words and their counts are stored in a list `V` of `Info` objects (a custom class `Info` holds the word `par` and its frequency `num`).
4.  Finally, it attempts to sort `V` based on frequency (descending) and then alphabetical order (ascending for ties) and prints the first `k` words.

**2. Analysis of Code's Strengths and Weaknesses**

**Strengths:**

*   **Clear Data Structure:** The `Info` class is well-defined and clearly encapsulates the word and its frequency, making the code more readable and organized.
*   **Efficient Frequency Counting:** Sorting the initial list of words `P` alphabetically (`P.sort()`) is an efficient strategy to group identical words. The subsequent loop to count frequencies by iterating through `P` and tracking consecutive identical words is a standard and effective method.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly sets up the program to process multiple test cases as described in the problem statement.
*   **Readability:** Variable names like `par`, `num`, `P`, `V` are descriptive and contribute to the code's clarity.

**Weaknesses / Reason for "Wrong Answer":**

*   **Incorrect Sorting with `key=comp`:** The primary issue lies in the sorting step: `V.sort(key=comp, reverse=True)`.
    *   In Python 3, the `key` argument for `list.sort()` expects a callable (like a function or a lambda) that takes *one* argument (an element from the list `V`) and returns a value to be used for sorting (the "key").
    *   Your `comp` function, however, is defined to take *two* arguments (`a` and `b`), making it a comparison function, not a key function.
    *   Passing `key=comp` directly will likely result in a `TypeError` (e.g., `comp() missing 1 required positional argument: 'b'`) because `sort` will try to call `comp(V[some_index])`. If the judging system returned "Wrong Answer" instead of "Runtime Error", it implies either a peculiar environment where this doesn't immediately crash but leads to incorrect behavior, or "Wrong Answer" is a general catch-all for non-passing tests, including runtime errors.
    *   Even if `comp` were somehow adapted to work as a comparison function (e.g., via `functools.cmp_to_key`), the combination with `reverse=True` might further complicate the intended sorting logic, potentially leading to an incorrect order. The problem requires descending frequency and *ascending* alphabetical order for ties.

**3. Suggestions for Improvement**

The core logic of your program is correct; the fix primarily involves adapting the sorting step to standard Python 3 practices:

1.  **Correct the Sorting Logic (Recommended Fix):**
    Replace the line `V.sort(key=comp, reverse=True)` with a standard Python 3 `key` function using a lambda expression:
    ```python
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    *   `lambda x: (-x.num, x.par)` creates a key for each `Info` object `x`. This key is a tuple: `(-frequency, word)`.
    *   Python's sort will compare these tuples:
        *   It first compares the negated frequencies (`-x.num`). Sorting these in ascending order effectively sorts the original frequencies in *descending* order (e.g., -5 comes before -3).
        *   If the negated frequencies are equal (meaning original frequencies are equal), it then compares the words (`x.par`) in ascending alphabetical order.
    *   This perfectly matches the problem's requirements (most frequent first, then smallest alphabetical for ties) and removes the need for `reverse=True`.

2.  **Alternative (Encapsulate Comparison in Class):**
    As an alternative (often considered good practice for custom objects), you could define the "less than" comparison method directly within your `Info` class. This would allow `V.sort()` to be called without any arguments, as it would use the `__lt__` method.

    ```python
    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

      def __lt__(self, other):
        # Return True if 'self' should come BEFORE 'other' in the sorted list
        if self.num != other.num:
          return self.num > other.num # True if self has higher freq (descending freq)
        return self.par < other.par # True if self is alphabetically smaller (ascending alphabetical)
    ```
    Then, the sorting line would simply be:
    ```python
    V.sort() # Uses the __lt__ method defined in Info
    ```

Implementing either of these sorting corrections should resolve the "Wrong Answer" verdict.