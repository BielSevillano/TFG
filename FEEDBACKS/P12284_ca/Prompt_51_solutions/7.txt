Here's a feedback text for your program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**1. Summary of the Problem and Solution Approach**

The problem asks to read a sequence of `n` words and output the `k` most frequent ones. In case of a tie in frequency, words should be ordered lexicographically (alphabetically) in ascending order.

Your program approaches this problem by:
1.  Reading all `n` words into a list `P`.
2.  Sorting this list `P` alphabetically (`P.sort()`), which groups identical words together.
3.  Iterating through the sorted list `P` to count the occurrences of each unique word. These unique words and their counts are stored in a list `V` of custom `Info` objects (containing `par` for the word and `num` for its frequency).
4.  Defining a comparison function `comp` that prioritizes higher frequency and then smaller word lexicographically.
5.  Attempting to sort the list `V` using this `comp` function.
6.  Finally, printing the `par` attribute of the first `k` elements from the sorted `V`.

**2. Analysis of the Code's Strengths and Weaknesses**

**Strengths:**

*   **Clear Data Structure:** The use of a custom `Info` class (`par` for word, `num` for frequency) is a good way to encapsulate the necessary data for each unique word.
*   **Efficient Frequency Counting:** Sorting the initial list of words (`P`) allows for a very efficient single-pass frequency count, where you iterate through consecutive identical words. This is a common and effective technique.
*   **Readability:** The code is well-structured and easy to follow, clearly separating the input, processing, and output steps.
*   **Correct Logic for Comparison:** The `comp` function itself correctly defines the desired sorting criteria: `if a.num != b.num: return a.num > b.num` means higher frequency comes first. `return a.par < b.par` means for equal frequencies, the lexicographically smaller word comes first.

**Weaknesses:**

*   **Incorrect Use of `list.sort` with `key` for Comparison:** This is the primary reason for the "Wrong Answer". In Python 3, the `key` argument for `list.sort()` expects a function that takes *one* argument (a list element) and returns a value to be used for sorting. Your `comp` function takes *two* arguments (`a` and `b`) and is designed as a traditional comparison function (like Python 2's `cmp` or C++'s `std::sort` predicate).
    *   If executed in a standard Python 3 environment, `list.sort(key=comp)` would raise a `TypeError` because `comp` would be called with a single `Info` object instead of two.
    *   Given the "Wrong Answer" verdict, it's likely that the execution environment (e.g., `yogi` or `Jutge.org`) either has a non-standard `list.sort` implementation that attempts to interpret `key=comp` as a comparator, or it implicitly wraps `comp` with `functools.cmp_to_key`.
    *   **Crucially, even if it worked as a comparator, the `reverse=True` argument would then invert the correct order defined by `comp`.** Your `comp` function already defines the desired sort order (descending frequency, ascending alphabetical). Adding `reverse=True` would cause the list to be sorted by *ascending* frequency, and then *descending* alphabetical for ties, which is the opposite of the problem's requirements.

**3. Suggestions for Improvement**

The core issue lies in how `V` is sorted. Here are a few ways to fix it, ordered from most Pythonic to adapting your current approach:

1.  **Recommended Fix (Pythonic `key` function):**
    This is the most Pythonic and common way to handle custom sorting criteria with `list.sort()` in Python 3. It uses a `lambda` function to return a tuple `(-frequency, word)`. Python sorts tuples lexicographically, so `-x.num` ensures higher frequencies come first (because `-5` is less than `-3`), and `x.par` handles alphabetical ties.

    ```python
    # Remove the 'comp' function, it's not needed with this approach.

    # ... (rest of your code remains the same until sorting V) ...

    # Sort V using a lambda key that returns a tuple for comparison
    V.sort(key=lambda x: (-x.num, x.par))

    # ... (print the first k elements) ...
    ```

2.  **Alternative Fix (Defining `__lt__` in the `Info` class):**
    You can make your `Info` objects directly comparable by defining the `__lt__` (less than) method within the class. This makes `V.sort()` work intuitively.

    ```python
    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num
      
      # Define the "less than" relationship for Info objects
      def __lt__(self, other):
        if self.num != other.num:
          # If self has higher frequency, it should come "before" (be "less than") other
          return self.num > other.num 
        # If frequencies are equal, smaller word should come "before"
        return self.par < other.par

    # ... (rest of your code remains the same until sorting V) ...

    # Sort V directly; it will use the __lt__ method
    V.sort() 

    # ... (print the first k elements) ...
    ```

3.  **Adaptation of Your `comp` Function (using `functools.cmp_to_key`):**
    If for some reason you prefer to keep your `comp` function as a two-argument comparator, you can convert it into a key function using `functools.cmp_to_key`. **Crucially, remove `reverse=True`**, as your `comp` already specifies the desired order.

    ```python
    import functools # Add this import at the top

    # define struct Info
    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

    # define comparator function (as you have it)
    def comp(a, b):
      if a.num != b.num:
        return a.num > b.num  # a is "less" if it has higher frequency
      return a.par < b.par    # a is "less" if it's alphabetically smaller

    # main function
    def main():
      # ... (your existing code) ...

      # Sort V using functools.cmp_to_key and REMOVE reverse=True
      V.sort(key=functools.cmp_to_key(comp))

      # ... (print the first k elements) ...
    ```

Choose the first or second suggestion for the most idiomatic Python 3 solution. The first (lambda key) is often preferred for its conciseness for simple sorting rules.

---