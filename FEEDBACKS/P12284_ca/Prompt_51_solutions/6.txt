Here's a feedback text for your Python program:

---

### Feedback on "Paraules més freqüents" Program

**1. Problem Summary and Solution Approach:**

The problem asks to read a sequence of `n` words and output the `k` most frequent ones. If multiple words have the same frequency, they should be ordered alphabetically (smallest first). The output for each test case must be followed by a line of ten dashes.

Your program adopts a standard and generally correct approach:
1.  It reads all `n` words into a list `P`.
2.  It sorts `P` alphabetically. This is a clever step as it groups identical words together, making frequency counting easier.
3.  It then iterates through the sorted list `P` to count the occurrences of each unique word. These unique words and their counts are stored in custom `Info` objects (`par` for word, `num` for count). These objects are collected in a list `V`.
4.  Finally, it sorts `V` based on the problem's criteria: descending frequency, then ascending alphabetical order for ties.
5.  The first `k` words from the sorted `V` are printed.
6.  The program handles multiple test cases as required.

**2. Analysis of Code's Strengths and Weaknesses:**

**Strengths:**
*   **Clear Data Structure:** The `Info` class is well-defined and makes the word-frequency pairs easy to manage.
*   **Efficient Frequency Counting (after sorting):** Sorting the initial list `P` and then iterating through it to count frequencies for consecutive identical words is an effective way to generate the unique word-frequency pairs.
*   **Handles Multiple Test Cases:** The `while` loop for `n` and `k` correctly processes all input cases.

**Weaknesses / Reason for "Wrong Answer":**

The primary reason for the "Wrong Answer" likely lies in how the custom `comp` function is used for sorting in the line `V.sort(key=comp, reverse=True)`.

*   **Incorrect `key` function usage in Python:** In Python 3, the `key` argument for `list.sort()` expects a function that takes *one* argument (an element from the list) and returns a value to sort by. Your `comp` function, however, takes *two* arguments (`a` and `b`), designed for a traditional comparison (`cmp`) function. When `key=comp` is used directly, Python will attempt to pass a single `Info` object to `comp`, leading to a `TypeError` (e.g., `TypeError: comp() missing 1 required positional argument`). If the platform somehow suppresses this error or the code is run in an unusual environment, the sorting might not occur as intended or might default to object identity, leading to incorrect results.
*   **Comparator Logic (if `cmp` were used):** Even if `cmp` were allowed (e.g., in Python 2 or via `functools.cmp_to_key`), a `cmp` function needs to return a negative integer, zero, or a positive integer (representing `a < b`, `a == b`, or `a > b` respectively), not boolean values as your `comp` function does.

**3. Suggestions for Improvement:**

1.  **Correct the Sorting Logic (Critical Fix):**
    The most robust and Pythonic way to handle custom sorting criteria like yours is to use the `key` argument with a `lambda` function that returns a tuple. Python's default tuple comparison will then handle the multi-level sorting correctly.

    Replace your `comp` function and the sorting line with this:
    ```python
    # Remove the 'comp' function definition entirely.

    # ... (inside main function, after V is populated)
    # Sort V using a lambda key that returns a tuple (-frequency, word)
    V.sort(key=lambda item: (-item.num, item.par))
    # No need for reverse=True here, as -item.num sorts frequency descending
    # and item.par sorts alphabetically ascending.
    ```
    This `lambda` function works as follows:
    *   `item.num` is negated (`-item.num`) so that higher frequencies become smaller negative numbers, causing them to sort first (descending frequency).
    *   `item.par` is used directly, which will sort alphabetically (ascending) for items with equal (negative) frequencies.

2.  **Improve Initial Frequency Counting (Performance & Pythonic Style):**
    Instead of sorting the input list `P` first and then manually iterating to count, you can use a Python dictionary or `collections.Counter` for more efficient frequency counting. This avoids one full sort operation on the initial list of `n` words.

    ```python
    import yogi
    from collections import Counter # Add this import

    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        # Read words directly into a list suitable for Counter
        words_list = [yogi.read(str) for _ in range(n)]

        # Use Counter to get word frequencies
        word_counts = Counter(words_list)

        # Convert to Info objects for custom sorting
        V = []
        for word, count in word_counts.items():
          V.append(Info(word, count))

        # Apply the corrected sorting logic
        V.sort(key=lambda item: (-item.num, item.par))

        # Print the first k elements
        for j in range(k):
          print(V[j].par)

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```

Applying these changes, especially the sorting logic, should resolve the "Wrong Answer" issue.