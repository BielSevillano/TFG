The program aims to solve the "Most Frequent Words" problem. It reads a sequence of `n` words and outputs the `k` most frequent ones. In case of a tie in frequency, words are ordered lexicographically (alphabetically ascending).

**Solution Approach:**
The program first reads all `n` words into a list `P` and sorts `P` alphabetically. This clever first step groups identical words together. It then iterates through the sorted list `P` to count the frequency of each unique word. These unique words and their counts are stored in a list `V` of custom `Info` objects (each holding a word `par` and its count `num`). Finally, `V` is sorted according to the problem's criteria (descending frequency, then ascending alphabetical order for ties), and the first `k` words are printed. The process is repeated for multiple test cases.

**Code Analysis:**

**Strengths:**
*   **Clear Data Structure:** The `Info` class is well-defined to encapsulate a word and its frequency, improving readability.
*   **Efficient Frequency Counting:** Sorting the initial list of words (`P.sort()`) allows for a single-pass linear scan (`while i < n`) to count frequencies for all unique words, which is efficient.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly processes multiple input sets as required by the problem.

**Weaknesses and Cause of "Wrong Answer":**
*   **Incorrect `key` Usage in Sorting:** The primary issue lies in how `V` is sorted: `V.sort(key=comp, reverse=True)`.
    *   In Python 3 (standard for modern online judges), the `key` argument for `list.sort()` expects a function that takes *one* element from the list and returns a value to be used for comparison.
    *   Your `comp` function, however, takes *two* arguments (`a`, `b`) and returns a boolean, which is characteristic of a comparison function (like `cmp` in Python 2.x, or a predicate for `std::sort` in C++).
    *   When `key=comp` is used, Python tries to call `comp` with a single `Info` object, leading to a `TypeError` (e.g., `TypeError: comp() missing 1 required positional argument: 'b'`) in a standard Python environment. If the `yogi` environment has custom behavior that allows this, it likely does not sort as intended, leading to the "Wrong Answer".
    *   Even if it somehow worked, the `reverse=True` in conjunction with a custom `key` that itself defines order based on `>` or `<` makes the logic more prone to errors and difficult to reason about. The comparison logic within `comp` also had a slight logical inversion for lexicographical tie-breaking when used with `reverse=True`.

**Suggestions for Improvement:**

1.  **Correct Sorting Key (Primary Fix):**
    The most straightforward and Pythonic way to implement multi-criteria sorting is to use a `lambda` function with `key` that returns a tuple. Python's `sort` will compare these tuples lexicographically.

    Replace these lines:
    ```python
    # define comparator function
    def comp(a, b):
      if a.num != b.num:
        return a.num > b.num
      return a.par < b.par
    # ...
    # in main:
    V.sort(key=comp, reverse=True)
    ```
    With:
    ```python
    # No need for a separate 'comp' function, remove it.

    # In main, replace the sort line:
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    **Explanation:**
    *   `x.num` is multiplied by `-1` to achieve *descending* order for frequencies (e.g., -3 comes before -2).
    *   `x.par` is kept as is to achieve *ascending* (lexicographical) order for words when frequencies are tied.
    *   Python's sort will compare the first elements of the tuples (`-x.num`). If they are equal, it will compare the second elements (`x.par`). This perfectly matches the problem's requirements.

2.  **Using `collections.Counter` (Optional, for conciseness):**
    For frequency counting, Python's `collections.Counter` can often simplify the code. While your current approach is valid, this alternative might be considered for cleaner code.

    ```python
    import yogi
    from collections import Counter # Import Counter

    # No need for Info class if using tuples for (word, count),
    # but keeping it is fine.
    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        
        # Read input and count frequencies using Counter
        # This replaces the entire block from `P = []` to `i = j`
        words_input = [yogi.read(str) for _ in range(n)]
        word_counts = Counter(words_input)

        # Create list V of Info objects
        V = []
        for word, count in word_counts.items():
          V.append(Info(word, count))

        # Sort V using the correct key
        V.sort(key=lambda x: (-x.num, x.par))

        # Print the first k elements of V
        for j in range(k):
          print(V[j].par)

        # print separator
        print("----------")

        # update n and k
        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```