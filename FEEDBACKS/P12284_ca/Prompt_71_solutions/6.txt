Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**Problem Summary:**
The problem asks you to read a sequence of `n` words and identify the `k` most frequent ones. The output should list these `k` words in order of decreasing frequency. In case of a tie in frequency, words should be ordered alphabetically (lexicographically ascending). The input consists of multiple test cases, and each output block should be followed by a line of ten dashes.

**Solution Approach:**
The program first reads all `n` words into a list `P`. It then sorts `P` alphabetically, which groups identical words together. After this, it iterates through the sorted list to count the frequency of each unique word. These unique words and their counts are stored in a list `V` of `Info` objects, where `Info` encapsulates a word (`par`) and its frequency (`num`). Finally, the program attempts to sort `V` based on the custom `comp` function and prints the `k` top elements. This process is repeated for subsequent test cases.

**Code Strengths:**

*   **Clear Data Structure:** The `Info` class is a well-designed way to bundle each word with its corresponding frequency, improving readability and organization.
*   **Efficient Frequency Counting:** The strategy of first sorting all words (`P.sort()`) and then iterating to count consecutive duplicates (`while j < n and P[j] == P[i]: j += 1`) is an efficient `O(N log N)` approach (dominated by the initial sort) for gathering word frequencies.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly processes multiple sets of input, adhering to the problem's requirements.
*   **Correct Output Separator:** The program correctly prints `----------` after each test case.

**Code Weaknesses (Reason for "Wrong Answer"):**

The primary reason for the "Wrong Answer" is the **incorrect usage of the `comp` function with Python's `list.sort()` method's `key` argument.**

1.  **Misuse of `key` with a Comparison Function:** In Python 3, the `key` argument for `list.sort()` (or `sorted()`) expects a function that takes *one argument* (an item from the list) and returns a value (the "key") that `list.sort()` will use for comparison. Your `comp` function, however, is defined to take *two arguments* (`a` and `b`) and returns a boolean, making it a traditional comparison function (like what was used with `cmp` in Python 2 or `std::sort` in C++). Passing a two-argument comparison function directly to `key` in Python 3 will either lead to a `TypeError` (because `list.sort` tries to call `comp` with a single argument) or unexpected sorting behavior if the `yogi` environment modifies standard Python `list.sort` behavior in a non-standard way.

    If the environment somehow *did* manage to apply the `comp` function as a comparator, the logic `a.num > b.num` combined with `reverse=True` would effectively sort by *ascending* frequency, not descending. This is because `reverse=True` reverses the order determined by the keys; if the keys are values from `comp`, it would reverse the order of `True/False` values.

**Suggestions for Improvement:**

To fix the "Wrong Answer" and make the code Pythonic and robust, you should modify how you sort the `V` list:

1.  **Correct `key` function for `list.sort()`:**
    Instead of defining a separate `comp` function that compares two `Info` objects, you should define a `key` function (often a `lambda` for conciseness) that, given a single `Info` object, returns a *tuple* that `list.sort()` can use for multi-criteria sorting. Python sorts tuples element by element.
    *   To sort by frequency in *descending* order, you can negate the frequency (`-item.num`). This makes higher frequencies "smaller" in value, so default ascending sort will place them first.
    *   To sort by word in *ascending* alphabetical order for ties, you simply use the word itself (`item.par`).

    Replace your `comp` function definition and the sorting line with:

    ```python
    # Remove the 'comp' function entirely

    # Inside main():
    # ...
    # V = []
    # ... (rest of frequency counting logic) ...

    # Sort V using a lambda function as the key
    V.sort(key=lambda item: (-item.num, item.par))

    # ... (rest of printing logic) ...
    ```

This change will correctly sort the `Info` objects according to the problem's requirements: most frequent first, and alphabetically for ties, directly addressing the core issue causing the "Wrong Answer."

---