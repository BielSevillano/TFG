
                Write a feedback text for the following program that solves the problem described below.
                
                Paraules més freqüents

Feu un programa que llegeixi una seqüència de n paraules, i n’escrigui
les k més freqüents (en cas d’empat, les més petites en ordre
alfabètic).

Entrada

L’entrada consisteix en diversos casos. Cada cas comença amb n i k,
seguides de n paraules només amb lletres minúscules. Podeu suposar que k
està entre 1 i el nombre de paraules diferents.

Sortida

Per a cada cas, escriviu les k paraules més freqüents en ordre. Primer
cal escriure les paraules més freqüents, i en cas d’empat les paraules
més petites en ordre lexicogràfic. Escriviu una línia amb 10 guions al
final de cada cas.

Autor

Salvador Roura

© Jutge.org, 2006–2025.
                

                This is the program:

                from yogi import read, scan
from dataclasses import dataclass



@dataclass
class Paraula:
    paraula: str
    frequencia: int


def freq(p: Paraula) -> int:
    return p.frequencia

def main() -> None:

    n = scan(int)
    k = scan(int)
    while n is not None and k is not None:
        
        #llegeixo la llista de paraules
        llista: list[str] = list()
        for _ in range(n):
            p = read(str)
            llista.append(p)
        
        llista.sort()
        llista.reverse()

        magatzem: list[Paraula] = list()

        i = 0
        while i < len(llista):
            compt = 1
            while i < len(llista)-1 and llista[i] == llista[i+1]:
                compt += 1
                i += 1
            magatzem.append(Paraula(llista[i],compt))
            i += 1

        ordenada = sorted(magatzem, key=freq)
        mida = len(ordenada)

        for x in range(k):
            print(ordenada[mida-1-x].paraula)


        print(10*'-')
        n = scan(int)
        k = scan(int)



if __name__ == "__main__":
    main()

                The result of the program is: Accepted

                The feedback should include:
                - A brief summary of the problem and the solution approach.
                - An analysis of the code's strengths and weaknesses.
                - Suggestions for improvement, if any.

                You can rely on the following other possible solutions to the same problem for reference:
                from jutge import read

n = read(int)
k = read(int)

while n is not None:

	freq = {}
	for i in range(n):
		w = read(str)
		if w not in freq:
			freq[w] = 1
		else:
			freq[w] += 1

	out = 0
	while out < k:
		mx = 0
		mxw = []
		for w in freq:
			if freq[w] > mx:
				mx = freq[w]
				mxw = [w]
			elif freq[w] == mx:
				mxw.append(w)
		mxw = sorted(mxw)
		for w in mxw:
			print(w)
			out += 1
			freq[w] = 0
			if out == k:
				break

	print("----------")

	n = read(int)
	k = read(int)

from jutge import read
from operator import itemgetter

def add_word(dic, pal):
    if pal in dic:
        dic[pal] += 1
    else:
	    dic[pal] = 1


def main(n):
	k = read(int)
	dic = {}
	for i in range(n):
		add_word(dic, read(str))
	lista_pal_freq = []
	for pal,freq in dic.items():
		lista_pal_freq.append((pal,freq))
	lista_pal_freq.sort(key = itemgetter(0))
	#print(lista_pal_freq)
	lista_pal_freq.sort(key = itemgetter(1), reverse = True)
	#print(lista_pal_freq)
	for i in range(k):
		print(lista_pal_freq[i][0])
	print(10*'-')
	
		
def main_main():
	n = read(int)
	while n is not None:
		main(n)
		n = read(int)


main_main()		

from jutge import read
from operator import itemgetter

def comptar_paraules(n):
    dic = {}
    for i in range(n):
        pal = read(str)
        if pal in dic:
            dic[pal] += 1
        else:
            dic[pal] = 1
    return dic

def generar_llista_ordenada(dic):
    l = []
    for pal,freq in dic.items():
        l.append((pal,freq))
    l.sort(key = itemgetter(0))
    #print(l)
    l.sort(key = itemgetter(1), reverse = True)
    return l

def escriure_k_primers(l,k):
    for i in range(k):
        print(l[i][0])

def main():
    k = read(int)
    n = read(int)
    while n is not None:
        dic = comptar_paraules(n)
        llista_pal_freq = generar_llista_ordenada(dic)
        escriure_k_primers(llista_pal_freq,k)
        #print(lista_pal_freq)
        print(10*'-')
        n = read(int)

main()		

from jutge import read
from operator import itemgetter

def comptar_paraules(n):
    dic = {}
    for i in range(n):
        pal = read(str)
        if pal in dic:
            dic[pal] += 1
        else:
            dic[pal] = 1
    return dic

def generar_llista_ordenada(dic):
    l = []
    for pal,freq in dic.items():
        l.append((pal,freq))
    l.sort(key = itemgetter(0))
    #print(l)
    l.sort(key = itemgetter(1), reverse = True)
    return l

def escriure_k_primers(l,k):
    for i in range(k):
        print(l[i][0])

def main():
    n = read(int)
    k = read(int)
    while n is not None:
        dic = comptar_paraules(n)
        llista_pal_freq = generar_llista_ordenada(dic)
        escriure_k_primers(llista_pal_freq,k)
        #print(lista_pal_freq)
        print(10*'-')
        n = read(int)
        k = read(int)

main()

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct Paraula {
	string s;
	int f;
};


bool ordena (const Paraula& a, const Paraula& b) {
	if (a.f > b.f) return true;
	if (b.f > a.f) return false;
	
	return a.s < b.s;
}


int main() {
	
	int n, k;
	while (cin >> n >> k) {
		
		//Llegim totes les paraules
		vector<string> paraules(n);
		for (int i = 0; i < n; i++) {
			cin >> paraules[i];
		}
		
		//Ordenem el vector de paraules
		sort(paraules.begin(), paraules.end());
		
		//Fem un vector buit de paraules i les seves repeticions
		vector<Paraula> frequencies(0);
		
		Paraula aux = {paraules[0], 1};
		for (int i = 1; i < n; i++) {
			
			if (aux.s == paraules[i]) aux.f++;
			else {
				frequencies.push_back(aux);
				aux = {paraules[i], 1};
			}
		}
		frequencies.push_back(aux);
		
		//Ordenem el vector en funcio de les repeticions
		sort(frequencies.begin(), frequencies.end(), ordena);
		
		//Imprimim les k paraules mes repetides
		for (int i = 0; i < k; i++)
			cout << frequencies[i].s << endl;
		cout << "----------" << endl;
	}
	
}

from jutge import read


def main():
    m, n = read(int, int)
    while m is not None:
        frase = []
        while m > 0:
            frase.append(read(str))
            m-=1
        while(n > 0):
            frase.sort()
            compte = 0
            comptemax = 0
            k = 0
            paraula = frase[0]
            while k < m:
                if(compte == comptemax):
                    paraula = frase[i]
                while frase[i] == frase[i-1]:
                    compte+=1
                    if(compte >= comptemax):
                        compte = comptemax
                        paraula = frase[i]
                    i+=1
                compte = 0
                i+=1
            print(paraula)
            for j in range(len(frase)):
                if(frase[j] == paraula):
                    frase[j] = "z"
            n-=1
            k+=1
            i = 1
        print("----------")
        m, n = read(int, int)
main()

from jutge import read


def main():
    m, n = read(int, int)
    while m is not None:
        frase = []
        x = 0
        while x < m:
            frase.append(read(str))
            x+=1
        while(n > 0):
            frase.sort()
            compte = 0
            comptemax = 0
            i = 1
            paraula = frase[0]
            while i < m:
                if(compte == comptemax):
                    paraula = frase[i]
                while i < m and frase[i] == frase[i-1]:
                    compte+=1
                    if(compte >= comptemax):
                        comptemax = compte
                        paraula = frase[i]
                    i+=1
                compte = 0
                i+=1
            print(paraula)
            n-=1
            for j in range(len(frase)):
                if(frase[j] == paraula):
                    frase[j] = "z"
        print("----------")
        m, n = read(int, int)
main()

from yogi import tokens, read
from functools import cmp_to_key

def ordenar(llista1: tuple[str,int], llista2: tuple[str,int]) -> int:
    if llista1[1] > llista2[1]:
        return 1
    elif llista1[1] < llista2[1]:
        return -1
    else:
        if llista1[0] > llista2[0]:
            return -1
        return 1


for n in tokens(int):
    k = read(int)
    llista = []

    for x in range(n):
        paraula = read(str)
        llista.append(paraula)

    llista.sort()

    paraula_anterior = llista[0]
    c = 1
    llista_def = []
    for paraula in llista[1:n-1]:
        if paraula == paraula_anterior:
            c += 1
        else:
            llista_def.append([paraula_anterior,c])
            c = 0
        paraula_anterior = paraula
    llista_def.append([paraula_anterior,c])

    sorted(llista_def,key=cmp_to_key(ordenar))

    for x in range(k):
        print(llista_def[x][0], end=' ')
    print('')
    print('-'*10)
from dataclasses import dataclass
from yogi import scan
from functools import cmp_to_key
 
@dataclass
class paraula:
    contingut: str
    vegades: int
 
def comparacio(p1: paraula, p2: paraula) -> int:
    if p1.vegades == p2.vegades:
        return 1 if p1.contingut > p2.contingut else -1
    return -1 if p1.vegades > p2.vegades else 1
 
def main():
    n = scan(int)
    k = scan(int)
    while n is not None:
        paraules: list[str] = [scan(str) for _ in range(n)]
        paraules.sort()
 
        numero_paraules: list[paraula] = []
        current_count = 1
 
        for i in range(1, n):
            if paraules[i - 1] != paraules[i]:
                numero_paraules.append(paraula(paraules[i - 1], current_count))
                current_count = 1
            else: current_count += 1
 
        numero_paraules.append(paraula(paraules[-1], current_count))
 
        numero_paraules_ordenades = sorted(numero_paraules, key=cmp_to_key(comparacio))
 
        for i in range (k):
            print (numero_paraules_ordenades[i].contingut)
        print ('-' * 10)
 
        n = scan(int)
        k = scan(int)
 
if __name__ == '__main__':
    main()
import yogi
#from dataclasses import dataclass

def freqüent(L : list[str], repeticions: int) -> None:
    
    conta = 1
    màxim = 0
    freq : str = ''
    if repeticions > 0:
        i = 0
        for j in range(1, len(L)):
            if L[j - 1] == L[j]:
                conta += 1
            else:
                if màxim == conta:
                    if L[j - 1] < freq:
                        freq = L[j - 1]
                elif màxim < conta:
                    màxim = conta
                    freq = L[j - 1]
                conta = 1
            i = j
        if màxim == conta:
            if L[i - 1] < freq:
                freq = L[i - 1]
        elif màxim < conta:
            màxim = conta
            freq = L[i - 1]
        print(freq)
        P: list[str] = []
        for elem in L:
            if elem != freq:
                P.append(elem)
        freqüent(list(sorted(P)), repeticions - 1)    

def main() -> None:
    for n in yogi.tokens(int):
        k = yogi.read(int)
        L : list[str] = []
        for i in range(n):
            L.append(yogi.read(str))
        freqüent(list(sorted(L)), k)
        
        print('-' * 10)
    
    
if __name__ == '__main__':
    main()  
from yogi import scan

def main():
    n = scan(int)
    k = scan(int)
    while n is not None:
        paraules: list[str] = []
        repeticions: list[int] = [0 for i in range(n)]
        for i in range(n):
            x = scan(str)
            j = 0
            while j < len(paraules) and paraules[j] != x:
                j += 1
            
            repeticions[j] += 1
            paraules.append(x)
        
        

        for i in range(k):
            max: int = 0
            index = -1
            for j in range(len(repeticions)):
                if repeticions[j] > max or (repeticions[j] == max and paraules[j] < paraules[index]):
                    max = repeticions[j]
                    index = j
            print(paraules[index])
            repeticions[index] = 0
            index = -1
            max = 0
        print('----------')
            
        n = scan(int)
        k = scan(int)


if __name__ == "__main__":
    main()
from yogi import scan

def main():
    n = scan(int)
    k = scan(int)
    while n is not None:
        paraules: list[str] = []
        maxims: list[int] = [0 for i in range(k)]
        indexs: list[int] = [-1 for i in range(k)]
        repeticions: list[int] = [0 for i in range(n)]
        for i in range(n):
            x = scan(str)
            j = 0
            while j < len(paraules) and paraules[j] != x:
                j += 1
            
            repeticions[j] += 1
            _ = 0
            while _ < k:
                if repeticions[j] > maxims[_] or (repeticions[j] == maxims[_] and x < indexs[_]):
                    if _ < k-1 and x != indexs[_]:
                        maxims[_+1] = maxims[_]
                        indexs[_+1] = indexs[_]
                    maxims[_] = repeticions[j]
                    indexs[_] = x

                    _ = k
                _ += 1
                
            paraules.append(x)
        
        for i in indexs:
            print(i)
        print('----------')
       
            
        n = scan(int)
        k = scan(int)


if __name__ == "__main__":
    main()
from yogi import scan

def merge_sort(v: list[str], esq: int, dre: int) -> None:
    if esq < dre:
        mig = (esq + dre) // 2

        merge_sort(v,esq, mig)
        merge_sort(v,mig + 1, dre)
        
        merge(v, esq, mig, dre)

def merge(v: list[str], esq: int, mig: int, dre: int) -> None:
    w: list[str] = []

    i, j = esq, mig + 1

    while i <= mig and j <= dre:
        if v[i] < v[j]:
            w.append(v[i])
            i += 1
        else:
            w.append(v[j])
            j += 1
    
    w.extend(v[i:mig+1])
    w.extend(v[j:dre+1])

    v[esq:dre+1] = w

def segon(x):
    return x[1]

def main():
    n = scan(int)
    while n is not None:
        v: list[str] = []
        k = scan(int)
        for i in range(n):
            v.append(scan(str))
        merge_sort(v,0,len(v)-1)
        
        cont = 0
        maxes: list[int] = []
        elements: list[str] = []
        for i in range(len(v)):
            if i == 0:
                elements.append(v[0])
                cont = 1
            elif v[i] != v[i-1]:             
                elements.append(v[i])
                maxes.append((len(maxes),cont))
                cont = 1
            elif v[i] == v[i-1]:
                cont += 1
        
        maxes.append((len(maxes),cont))
        maxes.sort(key=lambda x: x[1], reverse=True)

        for i in range(k):
            print(elements[maxes[i][0]])
        print('----------')
        

        n = scan(int)


if __name__ == "__main__":
    main()
from yogi import scan

def merge_sort(v: list[str], esq: int, dre: int) -> None:
    if esq < dre:
        mig = (esq + dre) // 2

        merge_sort(v,esq, mig)
        merge_sort(v,mig + 1, dre)
        
        merge(v, esq, mig, dre)

def merge(v: list[str], esq: int, mig: int, dre: int) -> None:
    w: list[str] = []

    i, j = esq, mig + 1

    while i <= mig and j <= dre:
        if v[i] < v[j]:
            w.append(v[i])
            i += 1
        else:
            w.append(v[j])
            j += 1
    
    w.extend(v[i:mig+1])
    w.extend(v[j:dre+1])

    v[esq:dre+1] = w

def segon(x):
    return x[1]

def main():
    n = scan(int)
    while n is not None:
        v: list[str] = []
        k = scan(int)
        for i in range(n):
            v.append(scan(str))
        v.sort()
        #merge_sort(v,0,len(v)-1)
        
        cont = 0
        maxes: list[int] = []
        elements: list[str] = []
        for i in range(len(v)):
            if i == 0:
                elements.append(v[0])
                cont = 1
            elif v[i] != v[i-1]:             
                elements.append(v[i])
                maxes.append((len(maxes),cont))
                cont = 1
            elif v[i] == v[i-1]:
                cont += 1
        
        maxes.append((len(maxes),cont))
        maxes.sort(key=lambda x: x[1], reverse=True)

        for i in range(k):
            print(elements[maxes[i][0]])
        print('----------')
        

        n = scan(int)


if __name__ == "__main__":
    main()
from dataclasses import dataclass
from functools import cmp_to_key
from yogi import scan

@dataclass
class Paraula:
    contingut: str
    repeticions: int


def comparacio(p1: Paraula, p2: Paraula)->int:
    """Compara dues paraules i retorna un valor positiu/negatiu per ordenar la llista"""
    if p1.repeticions == p2.repeticions:
        if p1.repeticions > p2.repeticions:
            return 1
        else:
            return -1

    if p1.repeticions > p2.repeticions:
        return -1
    else:
        return 1


def main()->None:
    n = scan(int)
    k = scan(int)

    while n is not None:
        llista_paraules: list[str] = [scan(str) for _ in range(n)]
        llista_paraules.sort()

        numero_paraules: list[Paraula]=[]
        comptador = 1

        for i in range(1, n):
            if llista_paraules[i-1] != llista_paraules[i]:
                numero_paraules.append(Paraula(llista_paraules[i-1], comptador))
                comptador = 1
            else:
                comptador += 1
        
        numero_paraules.append(Paraula(llista_paraules[-1], comptador))

        numero_paraules_ordenades = sorted(numero_paraules, key=cmp_to_key(comparacio))

        for i in range(k):
            print(numero_paraules_ordenades[i].contingut)
        print('-' * 10)

        n = scan(int)
        k = scan(int)

if __name__=="__main__":
    main()

        




from dataclasses import dataclass
from functools import cmp_to_key
from yogi import scan

@dataclass
class Paraula:
    contingut: str
    repeticions: int


def comparacio(p1: Paraula, p2: Paraula)->int:
    """Compara dues paraules i retorna un valor positiu/negatiu per ordenar la llista"""
    if p1.repeticions == p2.repeticions:
        if p1.contingut > p2.contingut:
            return 1
        else:
            return -1

    if p1.repeticions > p2.repeticions:
        return -1
    else:
        return 1


def main()->None:
    n = scan(int)
    k = scan(int)

    while n is not None:
        llista_paraules: list[str] = [scan(str) for _ in range(n)]
        llista_paraules.sort()

        numero_paraules: list[Paraula]=[]
        comptador = 1

        for i in range(1, n):
            if llista_paraules[i-1] != llista_paraules[i]:
                numero_paraules.append(Paraula(llista_paraules[i-1], comptador))
                comptador = 1
            else:
                comptador += 1
        
        numero_paraules.append(Paraula(llista_paraules[-1], comptador))

        numero_paraules_ordenades = sorted(numero_paraules, key=cmp_to_key(comparacio))

        for i in range(k):
            print(numero_paraules_ordenades[i].contingut)
        print('-' * 10)

        n = scan(int)
        k = scan(int)

if __name__=="__main__":
    main()

        




from yogi import read, scan
from dataclasses import dataclass

@dataclass
class Paraules:
    paraula: str
    repeticions: int


def comparacio(p1: Paraules, p2: Paraules) -> int:
    if p1.repeticions == p2.repeticions:
        if p1.paraula > p2.paraula:
            return 1
        else:
            return -1
    
    if p1.repeticions > p2.repeticions:
        return -1
    else:
        return 1


def main() -> None:
    n = scan(int)
    while n is not None:
        k = read(int)
        list_paraules = [read(str) for _ in range(n)]
        list_paraules.sort()

        num_paraules: list[Paraules] = []
        comptador = 1

        for i in range(1, n):
            if list_paraules[i - 1] != list_paraules[i]:
                num_paraules.append(Paraules(list_paraules[i - 1], comptador))
                comptador = 1
            else:
                comptador += 1
            
        num_paraules.append(Paraules(list_paraules[-1], comptador))
        num_paraules_ordenades = sorted(num_paraules, key=comparacio)

        for i in range(k):
            print(num_paraules_ordenades[i].paraula)
        print('-' * 10)

        n = scan(int)


if __name__ == "__main__":
    main()
from yogi import *
from dataclasses import dataclass
from functools import cmp_to_key

@dataclass
class Paraula:
    paraula: str
    repeticions: int


def comparacio(a: Paraula, b: Paraula) -> int:
    return b.repeticions - a.repeticions


def llegir_dades(n: int) -> list[str]:
    L = []

    for i in range(n):
        x = read(str)
        L.append(x)
    
    return L


def ordenar_dades(L: list[str]) -> list[str]:
    L_ord = sorted(L)

    return L_ord


def paraula_mes_frequent(L: list[str], n: int, k: int) -> None:
    paraules : list[Paraula] = [] #llista de paraules

    vegades = 1
    referencia = L[0] #primera paraula de la llista ja ordenada

    for i in range(1, n): 
        if L[i] != referencia:
            paraules.append(Paraula(referencia, vegades))

            vegades = 1
            referencia = L[i]

            #print(paraules)
        
        else:
            vegades += 1
            #print(paraules)
    
    paraules.append(Paraula(referencia, vegades))

    print(paraules)

    paraules_ordenades = sorted(paraules, key=cmp_to_key(comparacio)) #ERROR

    for i in range(k):
        print(paraules_ordenades[i].paraula)


def main() -> None:
    n, k = scan(int), scan(int)
    while n is not None :
        llista_paraules = llegir_dades(n)
        llista_paraules_ord = ordenar_dades(llista_paraules)
        print(llista_paraules_ord)
        paraula_mes_frequent(llista_paraules_ord, n, k)
        print('----------')

        n, k = scan(int), scan(int)


if __name__ == "__main__":
    main()

from yogi import *
from dataclasses import dataclass
from functools import cmp_to_key

@dataclass
class Paraula:
    paraula: str
    repeticions: int


def comparacio(a: Paraula, b: Paraula) -> int:
    return b.repeticions - a.repeticions


def llegir_dades(n: int) -> list[str]:
    L = []

    for i in range(n):
        x = read(str)
        L.append(x)
    
    return L


def ordenar_dades(L: list[str]) -> list[str]:
    L_ord = sorted(L)

    return L_ord


def paraula_mes_frequent(L: list[str], n: int, k: int) -> None:
    paraules : list[Paraula] = [] #llista de paraules

    vegades = 1
    referencia = L[0] #primera paraula de la llista ja ordenada

    for i in range(1, n): 
        if L[i] != referencia:
            paraules.append(Paraula(referencia, vegades))

            vegades = 1
            referencia = L[i]

            #print(paraules)
        
        else:
            vegades += 1
            #print(paraules)
    
    paraules.append(Paraula(referencia, vegades))

    paraules_ordenades = sorted(paraules, key=cmp_to_key(comparacio)) #ERROR

    for i in range(k):
        print(paraules_ordenades[i].paraula)


def main() -> None:
    n, k = scan(int), scan(int)
    while n is not None :
        llista_paraules = llegir_dades(n)
        llista_paraules_ord = ordenar_dades(llista_paraules)
        paraula_mes_frequent(llista_paraules_ord, n, k)
        print('----------')

        n, k = scan(int), scan(int)


if __name__ == "__main__":
    main()

from yogi import read,tokens
from dataclasses import dataclass

@dataclass
class Paraula: 
    paraula: str
    freq: int

def frequencia(p: Paraula) -> int:
    return p.freq

def main() -> None:

    for n in tokens(int):
        count = 1 # comptador de freqüències
        L: list[str] = list() # llista de les paraules que llegim
        f = read(int)

        for _ in range(n):
            p = read(str)
            L.append(p)
        L.sort()
        L.reverse()

        Paraules: list[Paraula] = list()

        i = 0
        while i < n:
            count = 1
            while i < n-1 and L[i] == L[i+1]:
                count += 1
                i += 1
            Paraules.append(Paraula(L[i],count))
            i += 1

        ordenada = sorted(Paraules, key=frequencia)
        
        for x in range(f): 
           print(ordenada[len(ordenada)-1-x].paraula)
        
        print(10*"-")







if __name__ == '__main__':
    main()


from yogi import scan, read

l = scan(int)
while l is not None:
    k = read(int)   # les k paraules més freqüents
    v: list[str] = []
    for j in range(l):
        v.append(read(str))
    v.sort()
    b = 1
    for _ in range(k):
        comptador = 1
        max = comptador
        paraula = v[0]
        for i in range(l - b):
            if v[i] == v[i + 1]:
                comptador += 1
                if max < comptador:
                    max = comptador
                    paraula = v[i]
                    comptador = 1
        print(paraula)
        for _ in range(comptador):
            v.remove(paraula)
            b += 1
    
    print("-" * 10)
    l = scan(int)


from yogi import scan, read

l = scan(int)
while l is not None:
    k = read(int)   # les k paraules més freqüents
    v: list[str] = []
    for j in range(l):
        v.append(read(str))
    v.sort()
    b = 1
    for _ in range(k):
        comptador = 1
        max = comptador
        paraula = v[0]
        for i in range(l - b):
            if v[i] == v[i + 1]:
                comptador += 1
                if max < comptador:
                    max = comptador
                    paraula = v[i]
                    comptador = 1
        print(paraula)
        for _ in range(max):
            v.remove(paraula)
            b += 1
    
    print("-" * 10)
    l = scan(int)


import yogi

def conta_freqüent(paraules: list[str]) -> str:
    n = len(paraules)
    conta = 1
    frequent = paraules[0]
    màxim = 0
    for i in range(n - 1):
        if paraules[i] == paraules[i + 1]:
            conta += 1
        else:
            if màxim < conta:
                màxim = conta
                frequent = paraules[i]
            
            elif màxim == conta and paraules[i] < frequent:
                màxim = conta
                frequent = paraules[i]
            conta = 1
    if màxim < conta:
        return paraules[-1]
    elif màxim == conta and paraules[-1] < frequent:
        return paraules[-1]
    else:
        return frequent    

def paraules_frequents(paraules: list[str], k: int) -> None:
    """Donada la llista paraules retorna les k més freqüents amb ordre."""
    n = len(paraules)
    restants : list[str] = []
    if k > 0:
        f = conta_freqüent(paraules)
        print(f)
        for x in paraules:
            if x != f:
                restants.append(x)
        paraules_frequents(restants, k - 1)
        

def main() -> None:
    for n in yogi.tokens(int):
        k = yogi.read(int)
        paraules: list[str] = []
        for i in range(n):
            paraules.append(yogi.read(str))
        paraules_frequents(list(sorted(paraules)), k)
        print('---------')
if __name__ == '__main__':
    main()
import yogi

def conta_freqüent(paraules: list[str]) -> str:
    n = len(paraules)
    conta = 1
    frequent = paraules[0]
    màxim = 0
    for i in range(n - 1):
        if paraules[i] == paraules[i + 1]:
            conta += 1
            if conta > n // 2:
                return paraules[i]
        else:
            if màxim < conta:
                màxim = conta
                frequent = paraules[i]
            
            elif màxim == conta and paraules[i] < frequent:
                màxim = conta
                frequent = paraules[i]
            conta = 1
    if màxim < conta:
        return paraules[-1]
    elif màxim == conta and paraules[-1] < frequent:
        return paraules[-1]
    else:
        return frequent    

def paraules_frequents(paraules: list[str], k: int) -> None:
    """Donada la llista paraules retorna les k més freqüents amb ordre."""
    n = len(paraules)
    restants : list[str] = []
    if k > 0:
        f = conta_freqüent(paraules)
        print(f)
        for x in paraules:
            if x != f:
                restants.append(x)
        paraules_frequents(restants, k - 1)
        

def main() -> None:
    for n in yogi.tokens(int):
        k = yogi.read(int)
        paraules: list[str] = []
        for i in range(n):
            paraules.append(yogi.read(str))
        paraules_frequents(list(sorted(paraules)), k)
        print('---------')
if __name__ == '__main__':
    main()
import yogi
from dataclasses import dataclass

@dataclass
class Paraula:
    escrita : str
    rep : int

@dataclass
class Posició:
    pos : int
    rep : int

def escriu_repeticions(paraules: list[Paraula], k: int):
    
    ordena_per_fusio(paraules)
    for i in range(k):
        print(paraules[i].escrita)
        
        
def ordena_per_fusio(v: list[Paraula]) -> None:

    ordena_rec(v, 0, len(v) - 1)
    
def ordena_rec(v: list[Paraula], esq: int, dre: int) -> None:
    
    if esq < dre:
        mig = (esq + dre) // 2
        ordena_rec(v, esq, mig)
        ordena_rec(v, mig + 1, dre)
        ordena(v, esq, mig, dre)
        
def ordena(v: list[Paraula], esq: int, mig: int, dre: int) -> None:
    
    L: list[Paraula] = []
    i = esq
    j = mig + 1
       
    while i <= mig and j <= dre:
        if v[i].rep > v[j].rep:
            L.append(v[i])
            i += 1
        elif v[i].rep == v[j].rep and v[i].escrita < v[j].escrita:
            L.append(v[i])
            i += 1
        else:
            L.append(v[j])
            j += 1
    L.extend(v[i:mig + 1])
    L.extend(v[j:dre + 1])
    v[esq:dre + 1] = L
                
def conta_repeticions(paraules: list[Paraula]) -> list[Paraula]:
    paraules.append(Paraula('0', 0))
    n = len(paraules)
    conta = 1

    for i in range(n - 1):
        if paraules[i].escrita == paraules[i + 1].escrita:
            conta += 1
        else:
            paraules[i].rep = conta
            conta = 1
    return [paraules[i] for i in range(n) if paraules[i].rep > 0]   

def paraules_frequents(paraules: list[Paraula], k: int) -> None:
    """Donada la llista paraules retorna les k més freqüents amb ordre."""
    
    repeticions = conta_repeticions(paraules)
        
    escriu_repeticions(repeticions, k)
        

def main() -> None:
    for n in yogi.tokens(int):
        k = yogi.read(int)
        escrits: list[str] = []
        for i in range(n):
            escrits.append(yogi.read(str))
        ordenades = list(sorted(escrits))
        ordenades.append('0')
        paraules : list[Paraula] = [Paraula(ordenades[i], 0) for i in range(n)]
        paraules_frequents(paraules, k)
        print('----------')

if __name__ == '__main__':
    main()
from yogi import read, tokens


def mes_frequent(L: list[str], n: int) -> str:
    """Donada una llista L ordenada de llargada n, retorna l'element més freqüent de la llista."""

    element_mes_frequent = L[0]
    repeticions_maximes = 1
    repeticions = 1

    for i in range(1, n):
        if L[i-1] == L[i]:
            repeticions += 1
        else:
            if repeticions > repeticions_maximes:
                repeticions_maximes = repeticions
                element_mes_frequent = L[i-1]
                repeticions = 1
            elif repeticions == repeticions_maximes:
                if element_mes_frequent > L[i-1]:
                    element_mes_frequent = L[i-1]
                repeticions = 1
            else:
                repeticons = 1

    if repeticions > repeticions_maximes:
        element_mes_frequent = L[n-1]
        repeticions_maximes = repeticions
    elif repeticions_maximes == 1:
        if L[n-2] < element_mes_frequent:
            element_mes_frequent = L[n-2]
        if L[n-1] < element_mes_frequent:
            element_mes_frequent = L[n-1]
    elif repeticions == repeticions_maximes:
            if element_mes_frequent > L[n-1]:
                element_mes_frequent = L[i-1]
    
    return element_mes_frequent


def elimina_paraula(L: list[str], paraula: str, n: int) -> None:
    """Donada una llista L ordenada de llargada n, elimina la paraula de la llista."""

    i = 0
    while i<n and paraula != L[i]:
        i += 1
    while i<n and paraula == L[i]:
        del(L[i])
        n = len(L)



def main() -> None:
    """Programa principal."""

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]

        L = sorted(L) # ordeno la llista per a que em sigui més fàcil trobar l'element/s més freqüent

        for i in range(k):
            if i < k - 1:
                a = mes_frequent(L,n)
                print(a)
                elimina_paraula(L, a, n)
                n = len(L)
            else:
                a = mes_frequent(L,n)
                print(a)
        print('----------')
    



if __name__ == '__main__':
    main()
from yogi import read, tokens

def moda(L:list[str], n: int)->tuple[str , int]:
    """Retorna la paraula mes frequent de L (llista ordenada) i la seva posicio, de longuitud n i que sigui diferent a "-". Si hi ha empat la mes petita."""
    
    i = 0
    mes_frec = "*"
    max_vegades = 0
    posicio_interes = 0
    while i < n:

        veg = comptant_frec(L, i, n) 
        if veg > max_vegades and L[i] != "-":
            max_vegades = veg
            mes_frec = L[i]
            posicio_interes = i
        i += veg

    return (mes_frec, posicio_interes)

def substitur(L:list[str], i: int, n:int)->None:
    """Substitueix tots els elements que siguin igual a L[i] de la llista ordenada L per -. n es la longuitud de la llista."""
    
    vegades_apareix = comptant_frec(L, i, n)
    for i in range(i, i + vegades_apareix , 1):
        L[i] = "-"

def comptant_frec(L:list[str], i:int, n:int)->int:
    """Retorna el num de vegades que apareix l element de la posicio i a la llista ordenada L de longuitud n."""
    suma = 1
    
    while i+1 < n and L[i] == L[i+1]:
        suma += 1
        i += 1

    return suma
            
def paraules_mes_frec(L:list[str], n:int, k:int)->None:
    """Printeja les k paraules mes frequents de L en ordre de frequencia. L te longuitud n."""
    mes_frec = "*"
    for _ in range(k):
        mes_frec = moda(L,n)
        print(mes_frec[0])
        substitur(L, mes_frec[1], n)
    print("----------")


def main():

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]
        L.sort()
        paraules_mes_frec(L, n, k)
    

if __name__ == """__main__""":
    main()
from yogi import read, tokens
from dataclasses import dataclass
from functools import cmp_to_key


@dataclass
class Paraula:
    repeticions: int
    paraula: str


def repeticions(L: list[str]) -> list[Paraula]:
    """Donada una llista de paraules L ordenada, retorna una llista de Paraula on s'indica el número de repeticions que apareix la paraula en L."""

    n = len(L)
    repeticions = 1
    paraules_i_repeticions: list[Paraula] = list()

    for i in range(n-1):
        if L[i] == L[i+1]:
            repeticions += 1
        else:
            p1 = Paraula (
                repeticions,
                L[i],
            )
            paraules_i_repeticions.append(p1)
            repeticions = 1
    
    if L[n-1] == L[n-2]: #en l'anterior bucle no hem pogut comparar el darrer element de la llista L
        p1 = Paraula(
            repeticions,
            L[n-1]
        )
        paraules_i_repeticions.append(p1)
    else:
        p1 = Paraula(
            repeticions,
            L[n-1]
        )
        paraules_i_repeticions.append(p1)

    return paraules_i_repeticions


def comparacio(p1: Paraula, p2: Paraula) -> int:
    """Donades dos paraules p1 i p2, ens retorna 1 si la primera es més petita que la segona, i -1 si la primera és més gran que la segona."""

    if p1.repeticions > p2.repeticions:
        return -1
    elif p1.repeticions == p2.repeticions:
        if p1.paraula < p2.paraula:
            return -1
        else:
            return 1
    else:
        return 1




def main() -> None:
    """Programa principal."""

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]

        L = sorted(L) # ordeno la llista per a que em sigui més fàcil trobar l'element/s més freqüent
        L = sorted(repeticions(L), key=cmp_to_key(comparacio))

        for i in range(k):
            print(L[i].paraula)
        print('----------')
    



if __name__ == '__main__':
    main()
from dataclasses import dataclass
from yogi import read, scan
from functools import cmp_to_key

@dataclass
class Karaula:                      # Nuestra estrucura tendrá la palabra junto al # de veces que sale
    paraula: str
    vegades: int

def funct(p1: Karaula, p2: Karaula) -> int:
    """ Retorna un nombre negatiu o positiu segons el nombre de vegades que surt una paraula (Karaula) """
    if p1.vegades == p2.vegades:
        if p1.paraula > p2.paraula:
            return 1
        else:
            return -1
    if p1.vegades > p2.vegades:
        return -1
    else:
        return 1

def main() -> None:
    n = scan(int)

    while n is not None:
        m = read(int)
        L: list[str] = []
        for _ in range(n):
            L.append(read(str))     # Leemos la lista de palabras
        L.sort()

        comptador = 1
        kara: list[Karaula] = []    # Creamos una lista vacía de Karaula's

        for i in range(n - 1):
            if L[i] != L[i + 1]:
                kara.append(Karaula(L[i], comptador))       # Añadimos a la lista las palabras que salen junto al # de veces que aparecen
                comptador = 1                               # transformando str + int en Karaula's
            elif L[i] == L[i + 1]:
                comptador += 1
        kara.append(Karaula(L[i], comptador))

        h = sorted(kara, key=cmp_to_key(funct))                 # Ordenamos segun el resultado que den en la función vegades (es decir, por el # de veces que salen)

        for p in range(m):          # Imprimimos las m palabras más frecuentes (ya que la lista estaba ordenada previamente por el # de veces que salían)
            print(h[p].paraula)
        print(10*'-')

        n = scan(int)               # Recordar acabar los while's con un scan

if __name__ == '__main__':
    main()


from dataclasses import dataclass
from yogi import read, scan
from functools import cmp_to_key

@dataclass
class Karaula:                      # Nuestra estrucura tendrá la palabra junto al # de veces que sale
    paraula: str
    vegades: int

def funct(p1: Karaula, p2: Karaula) -> int:
    """ Retorna un nombre negatiu o positiu segons el nombre de vegades que surt una paraula (Karaula) """
    if p1.vegades == p2.vegades:
        if p1.paraula > p2.paraula:
            return 1
        else:
            return -1
    if p1.vegades > p2.vegades:
        return -1
    else:
        return 1

def main() -> None:
    n = scan(int)

    while n is not None:
        m = read(int)
        L: list[str] = []
        for _ in range(n):
            L.append(read(str))     # Leemos la lista de palabras
        L.sort()

        comptador = 1
        kara: list[Karaula] = []    # Creamos una lista vacía de Karaula's
        i = 0
        for i in range(n - 1):
            if L[i] != L[i + 1]:
                kara.append(Karaula(L[i], comptador))       # Añadimos a la lista las palabras que salen junto al # de veces que aparecen
                comptador = 1                               # transformando str + int en Karaula's
            elif L[i] == L[i + 1]:
                comptador += 1
        kara.append(Karaula(L[i], comptador))

        h = sorted(kara, key=cmp_to_key(funct))                 # Ordenamos segun el resultado que den en la función vegades (es decir, por el # de veces que salen)

        for p in range(m):          # Imprimimos las m palabras más frecuentes (ya que la lista estaba ordenada previamente por el # de veces que salían)
            print(h[p].paraula)
        print(10*'-')

        n = scan(int)               # Recordar acabar los while's con un scan

if __name__ == '__main__':
    main()


from dataclasses import dataclass
from yogi import scan, read
from functools import cmp_to_key

@dataclass
class paraula:
    contingut: str
    vegades: int

def comparacio(p1: paraula, p2: paraula) -> int:
    if p1.vegades == p2.vegades:
        if p1.contingut > p2.contingut:
            return 1
        else:
            return -1
    if p1.vegades > p2.vegades:
        return -1
    else:
        return 1

def main() -> None:
    n = scan(int)

    while n is not None:
        m = read(int)
        llista_paraules: list[str] = [read(str) for _ in range(n)]
        llista_paraules.sort()

        numero_paraules: list[paraula] = []
        comptador = 1

        for i in range(1, n):
            if llista_paraules[i] != llista_paraules[i - 1]:
                numero_paraules.append(paraula(llista_paraules[i - 1], comptador))
                comptador = 1
            else:
                comptador += 1

        numero_paraules.append(paraula(llista_paraules[-1], comptador))

        numero_paraules_ordenades = sorted(numero_paraules, key=cmp_to_key(comparacio))

        for i in range(m):
            print(numero_paraules_ordenades[i].contingut)
        print('-' * 10)

        n = scan(int)
        
if __name__ == '__main__':
    main()

from yogi import read,scan
from dataclasses import dataclass
from functools import cmp_to_key
@dataclass
class Paraula:
    nom:str
    repeticions:int


def classifica(L:list[str]) -> list[Paraula]:
    R:list[Paraula]=list()
    L.sort(reverse = True)
    for paraula in L:
        p = Paraula(
            paraula, 
            0)
        if p not in R:
            R.append(p)
    for p2 in R:
        for p1 in L:
            if p2.nom == p1:
                p2.repeticions += 1
    return R
def nombre_repeticions(p : Paraula) -> int:
    return p.repeticions    
        
def escriu(R:list[Paraula], k) -> None:
    R.sort(key = nombre_repeticions)
    for i in range(k):
        print(R[-i-1].nom)
    print('----------')

def main() -> None:
    n:int = read(int)
    while n is not None:
        k:int = read(int)
        L:list[str] = [read(str) for _ in range(n)]
        R : list[Paraula] = classifica(L)
        escriu(R,k)
        n = scan(int)



if __name__ == '__main__':
    main()
from yogi import read,scan
from dataclasses import dataclass
from functools import cmp_to_key
@dataclass
class Paraula:
    nom:str
    repeticions:int


def classifica(L:list[str]) -> list[Paraula]:
    R:list[Paraula]=list()
    L.sort(reverse = True)
    for paraula in L:
        p = Paraula(
            paraula, 
            1)
        word_found = False
        for p_ in R:
            if p.nom == p_.nom:
                p_.repeticions += 1
                word_found = True
        if not word_found:
            R.append(p)
#    for p2 in R:
#        for p1 in L:
 #           if p2.nom == p1:
  #              p2.repeticions += 1
    return R
def nombre_repeticions(p : Paraula) -> int:
    return p.repeticions    
        
def escriu(R:list[Paraula], k) -> None:
    R.sort(key = nombre_repeticions)
    for i in range(k):
        print(R[-i-1].nom)
    print('----------')

def main() -> None:
    n:int = read(int)
    while n is not None:
        k:int = read(int)
        L:list[str] = [read(str) for _ in range(n)]
        R : list[Paraula] = classifica(L)
        escriu(R,k)
        n = scan(int)



if __name__ == '__main__':
    main()
from yogi import read, scan
from dataclasses import dataclass


@dataclass
class Paraula():
    paraula: str
    frequencia: int

def freq(p: Paraula) -> int:
    return p.frequencia     


def main() -> None:
    
    n = scan(int)
    k = scan(int)

    while n is not None and k is not None:
        #llegeixo la llista de paraules
        llista = [read(str) for _ in range(n)]

        llista.sort()
        

        magatzem: list[Paraula] = list()

        i = 0
        while i < len(llista):
            compt = 1
            while i < len(llista)-1 and llista[i] == llista[i+1]:
                compt += 1
                i += 1
            magatzem.append(Paraula(llista[i], compt))
            i += 1
        
        ordenada = sorted(magatzem, key=freq)
        

        for x in range(k):
            print(ordenada[x].paraula)

        print('----------')
        n = scan(int)
        k = scan(int)

if __name__ == '__main__':
    main()
from yogi import read, scan
from dataclasses import dataclass


@dataclass
class Paraula():
    paraula: str
    frequencia: int

def freq(p: Paraula) -> int:
    return p.frequencia     


def main() -> None:
    
    n = scan(int)
    k = scan(int)

    while n is not None and k is not None:
        #llegeixo la llista de paraules
        llista = [read(str) for _ in range(n)]

        llista.sort()
        

        magatzem: list[Paraula] = list()

        i = 0
        while i < len(llista):
            compt = 1
            while i < len(llista)-1 and llista[i] == llista[i+1]:
                compt += 1
                i += 1
            magatzem.append(Paraula(llista[i], compt))
            i += 1
        
        ordenada = sorted(magatzem, key=freq)
        mida = len(ordenada)

        for x in range(k):
            print(ordenada[mida-x-1].paraula)

        print('----------')
        n = scan(int)
        k = scan(int)

if __name__ == '__main__':
    main()
from yogi import read, scan
from dataclasses import dataclass


@dataclass
class Paraula():
    paraula: str
    frequencia: int

def freq(p: Paraula) -> int:
    return p.frequencia     


def main() -> None:
    
    n = scan(int)
    k = scan(int)

    while n is not None and k is not None:
        #llegeixo la llista de paraules
        llista = [read(str) for _ in range(n)]

        llista.sort()
        llista.reverse()

        magatzem: list[Paraula] = list()

        i = 0
        while i < len(llista):
            compt = 1
            while i < len(llista)-1 and llista[i] == llista[i+1]:
                compt += 1
                i += 1
            magatzem.append(Paraula(llista[i], compt))
            i += 1
        
        ordenada = sorted(magatzem, key=freq)
        mida = len(ordenada)

        for x in range(k):
            print(ordenada[mida-x-1].paraula)

        print('----------')
        n = scan(int)
        k = scan(int)

if __name__ == '__main__':
    main()
from yogi import read,scan
from dataclasses import dataclass
from functools import cmp_to_key
@dataclass
class Paraula:
    nom:str
    repeticions:int


def classifica(L:list[str],n:int) -> list[Paraula]:
    R:list[Paraula]=list()
    L.sort(reverse = True)
    k = 0 
    p0 =  Paraula(L[0],1)
    R.append(p0)
    for i in range(1,n):
        if L[i-1] == L[i]:
            R[k].repeticions += 1
        else:
            pi = Paraula(L[i],1)
            k+=1
            R.append(pi)
        
#    for p2 in R:
#        for p1 in L:
 #           if p2.nom == p1:
  #              p2.repeticions += 1
    return R
def nombre_repeticions(p : Paraula) -> int:
    return p.repeticions    
        
def escriu(R:list[Paraula], k) -> None:
    R.sort(key = nombre_repeticions)
    for i in range(k):
        print(R[-i-1].nom)
    print('----------')

def main() -> None:
    n:int = read(int)
    while n is not None:
        k:int = read(int)
        L:list[str] = [read(str) for _ in range(n)]
        R : list[Paraula] = classifica(L,n)
        escriu(R,k)
        n = scan(int)



if __name__ == '__main__':
    main()
from yogi import read,scan
from dataclasses import dataclass
from functools import cmp_to_key

@dataclass
class Paraula:
    nom:str
    repeticions:int


def classifica(L:list[str],n:int) -> list[Paraula]:
    R:list[Paraula]=list()
    L.sort(reverse = True)
    k = 0 
    p0 =  Paraula(L[0],1)
    R.append(p0)
    for i in range(1,n):
        if L[i-1] == L[i]:
            R[k].repeticions += 1
        else:
            pi = Paraula(L[i],1)
            k+=1
            R.append(pi)
 
    return R
def nombre_repeticions(p : Paraula) -> int:
    return p.repeticions    
        
def escriu(R:list[Paraula], k) -> None:
    R.sort(key = nombre_repeticions)
    for i in range(k):
        print(R[-i-1].nom)
    print(10*'-')

def main() -> None:
    n:int = read(int)
    while n is not None:
        k:int = read(int)
        L:list[str] = [read(str) for _ in range(n)]
        R : list[Paraula] = classifica(L,n)
        escriu(R,k)
        n = scan(int)



if __name__ == '__main__':
    main()
from yogi import read, tokens
from dataclasses import dataclass
from functools import cmp_to_key

@dataclass
class Paraula:
    nom : str
    vegades : int

def comparacio(a:Paraula,b:Paraula)->int:
    return b.vegades-a.vegades


def Paraules_frequents(l:list[str], b:int)->None:
    L_ordenada = sorted(l)

    Paraules:list[Paraula] = []

    repeticions = 1
    referencia = L_ordenada[0]

    for i in range(1,len(L_ordenada)):
        if L_ordenada[i] != referencia:
            Paraules.append(Paraula(referencia, repeticions))

            repeticions = 1
            referencia = L_ordenada[i]
    else:
        repeticions +=1

    Paraules.append(Paraula(referencia, repeticions))

    Paraules_ordenades = sorted(Paraules, key=cmp_to_key(comparacio))


    for i in range(b):
        print(Paraules_ordenades[i].nom)
        
def main()->None:
    for a in tokens(int):
        Llista_Paraules: list[str]=[]
        b = read(int)
        for _ in range(a):
            Llista_Paraules.append(read(str))
        Paraules_frequents(Llista_Paraules, b)

    


if __name__ =="__main__":
    main()
from yogi import read, scan
from functools import cmp_to_key


def comparar_paraules(t1:tuple[str, int], t2:tuple[str, int])->int:
    '''funcio que retorna un nombre negatiu si t1 va abans de t2,
    un nombre positiu si t2 va abans que t1 i 0 si son iguals'''
    if t1[1] != t2[1]: return t2[1] - t1[1]
    
    if t1[0]>t2[0]: return 1
    elif t2[0]>t1[0]: return -1
    return 0

def paraules_mes_frequents(n:int, k:int)->None:

    paraules: dict[str, int] = {}

    for _ in range(n):
        x = read(str).lower()
        if x in paraules: paraules[x] += 1
        else: paraules[x] = 1

    L = [(k, v) for k, v in paraules.items()]
    for paraula, vegades in sorted(L, key = cmp_to_key(comparar_paraules) )[:k]:
        print(paraula)


def main():
    n = read(int)

    while n is not None:
        k = read(int)
        paraules_mes_frequents(n, k)
        print('----------')
        n = scan(int)


if __name__ == "__main__":
    main()
from yogi import scan, read

def main():
    n = scan(int)
    k = scan(int)
    
    while n is not None:
        paraules: dict[str, int] = {}
        for _ in range(n):
            paraula = read(str)
            if paraula not in paraules:
                paraules[paraula] = 1
            else:
                paraules[paraula] += 1
        
        paraula_freq = ""
        for _ in range(k):
            max = 0
            for paraula in paraules:
                if paraules[paraula] > max:
                    max = paraules[paraula]
                    paraula_freq = paraula
                if paraules[paraula] == max:
                    if paraula < paraula_freq:
                        paraula_freq = paraula

            print(paraula_freq)
            del paraules[paraula_freq]
        
        print("----------")

        n = scan(int)
        k = scan(int)
                

main()

        
from yogi import scan, read

def main():
    n = scan(int)
    k = scan(int)
    
    while n is not None:
        paraules: dict[str, int] = {}
        for _ in range(n):
            paraula = read(str)
            if paraula not in paraules:
                paraules[paraula] = 1
            else:
                paraules[paraula] += 1
        
        p_ord = list(sorted(paraules.items(), key=lambda x: (x[1],x[0]), reverse=True))

        for _ in range(k):
            if len(p_ord) > 1:
                if p_ord[0][1] == p_ord[1][1]:
                    if p_ord[0] < p_ord[1]:
                        print(p_ord[0][0])
                        del(p_ord[0])
                    else: 
                        print(p_ord[1][0])
                        del(p_ord[1])
                else:
                    print(p_ord[0][0])
                    del(p_ord[0])
            else: 
                print(p_ord[0][0])

        
        print("----------")

        n = scan(int)
        k = scan(int)
                

main()

        
from yogi import scan, read

def main():
    n = scan(int)
    k = scan(int)
    
    while n is not None:
        paraules: dict[str, int] = {}
        for _ in range(n):
            paraula = read(str)
            if paraula not in paraules:
                paraules[paraula] = 1
            else:
                paraules[paraula] += 1
        
        p_ord = dict(sorted(paraules.items(), key=lambda x: (x[0])))
       
        paraules_ordenades: list[str] = []
        for paraula, nombre in (sorted(p_ord.items(), key=lambda x: (x[1]), reverse=True)):
            paraules_ordenades.append(paraula)
        
        for i in range(k):
            print(paraules_ordenades[i])
            

        
        print("----------")

        n = scan(int)
        k = scan(int)
                

main()

        
from yogi import scan, read

def main():
    n = scan(int)
    k = scan(int)
    
    while n is not None:
        paraules: dict[str, int] = {}
        for _ in range(n):
            paraula = read(str)
            if paraula not in paraules:
                paraules[paraula] = 1
            else:
                paraules[paraula] += 1
        
        paraules = dict(sorted(paraules.items(), key=lambda x: (x[0])))
       
        paraules_ordenades: list[str] = []
        for paraula, nombre in (sorted(paraules.items(), key=lambda x: (x[1]), reverse=True)):
            paraules_ordenades.append(paraula)
        
        for i in range(k):
            print(paraules_ordenades[i])
            

        
        print("----------")

        n = scan(int)
        k = scan(int)
                

main()

        
import yogi as yg






def main() -> None:
    for n in yg.tokens(int):
        k  = yg.read(int)
        D:dict[str:int] = dict()
        for _ in range(n):
            word = yg.read(str)
            if word not in D:
                D[word] = 1
            else:
                D[word] += 1
        D_ = sorted(D.items(), key = lambda x: x[0])
        D_.sort(key = lambda x: -x[1])
        for i in range(k):
            print(D_[i][0])
        print(10*'-')


if __name__ == '__main__':
    main()
from yogi import read

def main():

    entrada = read(int)
    sortida = read(int)
    recompte: dict[str, int] = dict()
    for _ in range(entrada):
        paraula = read(str)
        if paraula in recompte:
            recompte[paraula] += 1
        else:
            recompte[paraula] = 1
    
    for paraula, repeticions in sorted(recompte.items(), key=lambda item: (item[0],item[1])):
        for _ in range(sortida):
            print(paraula)
    print("----------")
from yogi import read

def main():

    entrada = read(int)
    sortida = read(int)
    recompte: dict[str, int] = dict()
    for _ in range(entrada):
        paraula = read(str)
        if paraula in recompte:
            recompte[paraula] += 1
        else:
            recompte[paraula] = 1
    
    for paraula, repeticions in sorted(recompte.items(), key=lambda item: (item[1],item[0])):
        for _ in range(sortida):
            print(paraula)
    print("----------")

if __name__ == '__main__':
    main()
import sys
from collections import Counter

for line in sys.stdin:
    n, k = map(int, line.split())
    words = input().split()
    count = Counter(words)
    top_k = sorted(count.items(), key=lambda x: (-x[1], x[0]))[:k]
    for word, freq in top_k:
        print(word)
    print('-'*10)
from yogi import tokens, read



def main() -> None:
    diec: dict[str, int] = dict()
    for n in tokens(int):
        k = read(int)

        for _ in range(n):
            paraula = read(str)
            if paraula.lower() in diec:
                diec[paraula.lower()] += 1
            else:
                diec[paraula.lower()] = 1

        l = sorted(diec.items(), key = lambda x: (-x[1], x[0]))

        for i in range(k):
            par = l[len(l)-i-1][0]
            print(par)
        print("----------")


if __name__ == "__main__":
    main()
from yogi import tokens, read



def main() -> None:
    diec: dict[str, int] = dict()
    for n in tokens(int):
        k = read(int)

        for _ in range(n):
            paraula = read(str).lower()
            if paraula in diec:
                diec[paraula] += 1
            else:
                diec[paraula] = 1

        l = sorted(diec.items(), key = lambda x: (-x[1], x[0]))

        for i in range(k):
            print(l[i][0])
        print("----------")


if __name__ == "__main__":
    main()
from yogi import *



def main():
    dic: Dict()= {}
    for n in tokens(int):
        k = read(int)
        for i in range(n):
            word = read(str)
            if word not in dic:
                dic[word] = 0
            dic[word] += 1
        sorted_dict = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))
        compt = 0
        for el in sorted_dict:
            if compt < k:
                print(el)
                compt += 1
        print("----------")


if __name__ == "__main__":
    main()

from yogi import *



def main():
    dic: Dict()= {}
    for n in tokens(int):
        k = read(int)
        for i in range(n):
            word = read(str)
            if word not in dic:
                dic[word] = 0
            dic[word] += 1
        quasi_sorted_dict = dict(sorted(dic.items(), key = lambda x: x[0]))
        sorted_dict = dict(sorted(quasi_sorted_dict.items(), key=lambda x: x[1], reverse=True))
        compt = 0
        for el in sorted_dict:
            if compt < k:
                print(el)
                compt += 1
        print("----------")


if __name__ == "__main__":
    main()

from yogi import *



def main():
    dic: Dict()= {}
    for n in tokens(int):
        k = read(int)
        for i in range(n):
            word = read(str)
            if word not in dic:
                dic[word] = 1
            else: dic[word] += 1
        sorted_dict = dict(sorted(dic.items(), key=lambda x: (x[1],x[0]), reverse = True))
        compt = 0
        for el in sorted_dict:
            if compt < k:
                print(el)
                compt += 1
        print("----------")


if __name__ == "__main__":
    main()

from yogi import *



def main():
    dic: Dict()= {}
    for n in tokens(int):
        k = read(int)
        for i in range(n):
            word = read(str)
            if word not in dic:
                dic[word] = 1
            else: dic[word] += 1
        quasi_sorted_dict = dict(sorted(dic.items(), key = lambda x: x[0]))
        sorted_dict = dict(sorted(quasi_sorted_dict.items(), key=lambda x: x[1], reverse=True))
        compt = 0
        for el in sorted_dict:
            if compt < k:
                print(el)
                compt += 1
        print("----------")


if __name__ == "__main__":
    main()

from yogi import scan, read

def main():
    n = scan(int)
    k = scan(int)
    
    while n is not None:
        paraules: dict[str, int] = {}
        for _ in range(n):
            paraula = read(str)
            if paraula not in paraules:
                paraules[paraula] = 1
            else:
                paraules[paraula] += 1
        
        paraules = dict(sorted(paraules.items()))
       
        paraules_ordenades: list[str] = []
        for paraula, nombre in (sorted(paraules.items(), key=lambda x: (x[1]), reverse=True)):
            paraules_ordenades.append(paraula)
        
        for i in range(k):
            print(paraules_ordenades[i])
            

        
        print("----------")

        n = scan(int)
        k = scan(int)
                

main()

from yogi import tokens, read
from typing import TypeAlias
from dataclasses import dataclass

@dataclass
class Paraula:
    nom: str
    cops: int

def ordenada(v: list[str]) -> list[Paraula]:  
    """
    retorna una llista de Paraula ordenada des de la paraula més repetida a la menys repetida
    """
    v.sort()
    u = [Paraula(nom = "", cops = 0) for _ in range(len(set(v)))]
    anterior = None
    c = -1
    for paraula in v:
        if anterior != paraula:
            c += 1
            u[c] = Paraula(nom = paraula, cops = 1)
            anterior = paraula 
        else:
            u[c].cops += 1
    return sorted(u, key=lambda x: x.cops, reverse=True)          


def main():
    for n in tokens(int):
        k = read(int)
        v = [read(str) for _ in range(n)]
        z = ordenada(v)
        for i in range(k):
            print(z[i].nom)
        print("-" * 10)
main()
from yogi import * 

def novallista(lst: list[str], a: str) -> list[str]:
    """Retorna la llista original sense el valor més frequent"""
    r: list[str] = []
    for x in lst:
        if x != a: 
            r.append(x)
    return r

def mesfreq(lst: list[str]) -> str:
    """Retorna la paraula més frequent d'una llista de paraules"""
    max = 0
    act = 0
    primer = True
    n = len(lst)
    if n > 1:
        for i in range(n):
            if primer:
                primer = False
                if lst[i] == lst[i + 1]:
                    act += 1
                    if act > max:
                        max = i
            else:
                if lst[i] == lst[i-1]:
                    act += 1
                    if act > max:
                        max = i
                else:
                    act = 0
    return lst[max]


def main() -> None:
    for n in tokens(int):
        k = read(int)
        lst: list[str] = []
        for i in range(n):
            lst.append(read(str))
        lst.sort()
        while k > 0:
            k -= 1
            a = mesfreq(lst)
            print(a)
            lst = novallista(lst, a)
        print("-" * 10)
main()
from yogi import * 

def novallista(lst: list[str], a: str) -> list[str]:
    """Retorna la llista original sense el valor més frequent"""
    while a in lst:
        lst.remove(a)
    return lst

def mesfreq(lst: list[str]) -> str:
    """Retorna la paraula més frequent d'una llista de paraules"""
    max = 0
    act = 0
    primer = True
    n = len(lst)
    if n > 1:
        for i in range(n):
            if primer:
                primer = False
                if lst[i] == lst[i + 1]:
                    act += 1
                    if act > max:
                        max = i
            else:
                if lst[i] == lst[i-1]:
                    act += 1
                    if act > max:
                        max = i
                else:
                    act = 0
    return lst[max]


def main() -> None:
    for n in tokens(int):
        k = read(int)
        lst: list[str] = []
        for i in range(n):
            lst.append(read(str))
        lst.sort()
        while k > 0:
            k -= 1
            a = mesfreq(lst)
            print(a)
            lst = novallista(lst, a)
        print("-" * 10)
main()
from yogi import read, tokens
from typing import TypeAlias

def max_ind(seq: list[int]) -> int:
    """Retorna l'índex de l'element més gran"""
    ind = 0
    for i in range(len(seq)):
        if seq[i] > seq[ind]:
            ind = i
    return ind

def p_mes_freq(n: int, m: int) -> None:
    """
    Llegeix una seqüència de n paraules de l'entrada i n'escriu les m més freqüents en ordre.
    """
    seq = [read(str) for _ in range(n)]
    seq.sort()

    paraules = [seq[0]]
    conts = [1]
    for word in seq:
        if word != paraules[-1]:
            paraules.append(word)
            conts.append(1)
        else:
            conts[-1] += 1

    for i in range(m):
        max_ind_ = max_ind(conts)
        print(paraules[max_ind_])
        conts.pop(max_ind_)
        paraules.pop(max_ind_)


def main():
    for n in tokens(int):
        m = read(int)
        p_mes_freq(n, m)
        print('-' * 10)
 
main()
from dataclasses import dataclass
from typing import TypeAlias
from yogi import read, tokens


@dataclass
class paraula:
    paraula: str
    freq: int

Paraules: TypeAlias = list[paraula]


def llista_de_paraules(seq: list[str]) -> Paraules:
    if len(seq) > 0:
        ant = seq[0]
        paraules = [paraula(ant, 1)]

        for p in seq:
            if p == ant:
                paraules[-1].freq += 1
            else:
                paraules.append(paraula(p, 1))
                ant = p

        return paraules
    else:
        return []

def freq(p: paraula) -> int:
    return p.freq
def paraules_mes_freq(n: int, m: int) -> None:
    """Llegeix una seqüència de n paraules i escriu les m més freqüents en ordre. """
    
    seq = [read(str) for _ in range(n)]
    seq.sort()
    
    paraules = llista_de_paraules(seq)

    paraules.sort(key = freq, reverse =  True)

    for i in range(m):
        print(paraules[i].paraula)

    print('-' * 10)
        

def main():
    for n in tokens(int):
        m = read(int)
        paraules_mes_freq(n, m)

main()
from dataclasses import dataclass
from typing import TypeAlias
from yogi import read, tokens


@dataclass
class Paraula:
    paraula: str
    freq: int

Paraules: TypeAlias = list[Paraula]


def llista_de_paraules(seq: list[str]) -> Paraules:
    if len(seq) > 0:
        ant = seq[0]
        paraules = [Paraula(ant, 1)]

        for p in seq:
            if p == ant:
                paraules[-1].freq += 1
            else:
                paraules.append(Paraula(p, 1))
                ant = p

        return paraules
    else:
        return []

def freq(p: Paraula) -> float:
    return 1 / p.freq

def paraules_mes_freq(n: int, m: int) -> None:
    """Llegeix una seqüència de n paraules i escriu les m més freqüents en ordre. """
    
    seq = [read(str) for _ in range(n)]
    seq.sort()
    
    paraules = llista_de_paraules(seq)

    paraules.sort(key = freq)

    for i in range(m):
        print(paraules[i].paraula)

    print('-' * 10)
        

def main():
    for n in tokens(int):
        m = read(int)
        paraules_mes_freq(n, m)

main()
from yogi import * 
from dataclasses import *
from typing import *
from functools import *

@dataclass
class Info:
    word: str
    n: int

Frequences: TypeAlias = list[Info]

def print_words(f: Frequences, k:int) -> None:
    for i in range(k):
        print(f[i].word)
    print('-'*10)

def cmp(a:Info, b: Info) -> int:
    '''
    Criteris:
    (1): mas n
    (2): menor lexicografico word
    '''
    if a.n != b.n:
        return b.n - a.n #negativo si a mayor (a mejor); positivo si b mejor
    if a.word != b.word:
        return -1 if a.word < b.word else 1
    return 0 #en nuestro ejercicio nunca se dara (no hay repes)



def repetitions(lst: list[str], i: int) -> int:
    '''
    Pre: lst esta ordenado: 0 <= i < len(lst)
    Post: retorna el numero de repeticiones del valor lst[i] a partir de i (incluida)
    '''
    
    n = len(lst)
    r = 1
    j = i + 1
    while j < n and lst[j] == lst[i]:
        r += 1
        j += 1
    return r

def build_frequences(lst: list[str]) -> Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i = 0
    while i < n:
        r = repetitions(lst, i)
        f.append(Info(lst[i], r))
        i += r
    return f

def main() -> None:
    for n in tokens(int):
        k = read(int)
        f: Frequences = build_frequences([read(str) for _ in range(n)])
        f.sort (key = cmp_to_key(cmp))
        print_words(f, k)

if __name__ == "__main__":
    main()
from yogi import *
from typing import TypeAlias
from dataclasses import dataclass
from functools import *

@dataclass
class Info:
    word:str
    n:int
Frequences: TypeAlias = list[Info]

def print_words(f:Frequences, k:int):
    for i in range(k):
        print(f[i].word)
    print("-"*10)
    
def cmp(a:Info,b:Info)->int:
    '''
    Estructura obligatoria
    '''
    if a.n != b.n:
        return b.n - a.n
    if a.word != b.word:
        return -1 if a.word < b.word else 1
    return 0
def repeticions(lst:list[str], i:int)->int:
    n = len(lst)
    r = 1
    j = i+1
    while j<n and lst[j]==lst[i]:
        r += 1 
        j += 1
    return r

def build_frequences(lst:list[str])->Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i=0
    while i<n:
        r = repeticions(lst,i)
        f.append(Info(lst[i],r))
        i +=r
    return f


def main()->None:
    for n in tokens(int):
        k = read(int) # nombre de paraules que hem de dir que estan repetides
        f:Frequences = build_frequences([read(str) for _ in range(n)])
        f.sort (key = cmp_to_key(cmp))
        print_words(f,k)

main()
from dataclasses import dataclass
from yogi import *
from typing import TypeAlias
from functools import cmp_to_key

@dataclass
class Info:
    word: str
    n: int

Frequences: TypeAlias = list[Info]

def print_words(f: Frequences, k:int) -> None:
    for i in range(k):
        print(f[i].word)
    print("-" * 10)

def cmp(a:Info, b:Info) -> int: #Esta funcion se define SIEMPRE de esta manera: Dos parametros de entrada y devuelve un entero
                                #Las dos son de tipo info ya que queremos determinar que quiere decir que una info "a" sea mejor que una
                                #info "b". Si a es mejor que b, retorna un valor negativo. Si b es mejor que a, retorna un valor positivo.
                                #Si ambos valores son "iguales" de buenos/malos, retorna un 0
    """
    Crtierios
    1) mas "n", mayor cantidad
    2) menor lexicografico word
    """
    if a.n != b.n:
        return b.n - a.n
    if a.word != b.word:
        return -1 if a.word < b.word else 1
    return 0

def repetitions(lst: list[str], i: int) -> int:
    """Pre : lst esta ordenado: 0 <= n <= lst
        Post: retorna el numero de repeticiones de  valor lst[i] a partir de i(incluida)
    """
    n = len(lst)
    r = 1 
    j = i + 1
    while j < n and lst[j] == lst[i]:
        r += 1
        j += 1
    return r    

def build_frequences(lst : list[str]) -> Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i = 0
    while i < n:
        r = repetitions(lst, i)
        f.append(Info(lst[i], r))
        i += r
    return f


def main() -> None:
    for n in tokens(int):
        k = read(int) #1 <= k <= n
        f : Frequences = build_frequences([read(str) for _ in range(n)]) 
        f.sort(key = cmp_to_key(cmp)) #Para decir segun que criterio tiene que ordenar utilizamos el cmp_to_key(cmp) 
                                    #donde cmp es la funcion booleana que tenemos que definir y será el criterio a seguir para ordenar.
        print_words(f,k)

main()


from dataclasses import dataclass
from typing import TypeAlias
from yogi import read, tokens
from functools import cmp_to_key

@dataclass
class Info:
    paraula: str
    freq: int

Frequences: TypeAlias = list[Info]

def repetitons(lst: list[str], i: int) -> int:
    """
    Pre: lst està ordenada, 0 <= i <= 
    """
    n = len(lst)
    r = 1
    j = i + 1
    while j < n and lst[j] == lst[i]:
        r += 1
        j += 1
    
    return r

def build_frequencies(lst: list[str]) -> Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i = 0
    while i < n:
        r = repetitons(lst, i)
        f.append(Info(lst[i], r))
        i += r
    return f

def cmp(a: Info, b: Info) -> int:
    """
    Criteris:
    (1) més freqüencia (freq)
    (2) paraula menor lexicografica
    """
    if a.freq != b.freq:
        return b.freq - a.freq
    if a.paraula != b.paraula: #En realitat en aquest exercici no és necessari
        return -1 if a.paraula < b.paraula else 1
    return 0

def print_words(f: Frequences, k: int) -> None:
    """Escriu les k primeres paraules de Frequences separades per salts de línia, 
    i al final escriu deu guions."""
    for i in range(k):
        print(f[i].paraula)
    print('-' * 10)

def main():
    for n in tokens(int):
        k = read(int)
        f: Frequences = build_frequencies([read(str) for _ in range(n)])
        f.sort(key = cmp_to_key(cmp))
        print_words(f, k)

if __name__ == '__main__':
    main()
from yogi import*
from dataclasses import dataclass
from typing import TypeAlias
from functools import cmp_to_key

@dataclass
class Info:
    word:str
    n:int

Frequences:TypeAlias=list[Info]

def print_words(f:Frequences, k:int)->None:
    for i in range(k):
        print(f[i].word)
    print("-"*10)

def cmp(a:Info, b:Info)->int:
    """
    criteris: 1) más n
    2) menor lexicografico word
    """
    if a.n!=b.n:
        return b.n-a.n # negativo si a mayor (a  mwjor): positivo si b mejor
    if a.word != b.word:
        return -1 if a.word<b.word else 1
    return 0

def repeticions(lst:list[str],i:int)->int:

    n=len(lst)
    r =1
    j=i+1

    while j<n and lst[j]==lst[i]:
        r +=1
        j +=1
    return r

def build_frecuencies(lst:list[str])->Frequences:
    n=len(lst)
    lst.sort()
    f:Frequences= []
    i=0
    while i<n:
        r=repeticions(lst,i)
        f.append(Info(lst[i],r))
        i += r
    return f

def main()->None:
    for n in tokens(int):
        k=read(int)
        f:Frequences=build_frecuencies([read(str)for _ in range(n)])
        f.sort(key=cmp_to_key(cmp))
        print_words(f,k)

main()
from dataclasses import dataclass
from yogi import read, tokens
from functools import cmp_to_key

@dataclass
class Word:
    word: str
    frec: int

def cmp(a: Word, b: Word) -> int: #a mejor que b -> retorna negativo (-1), si b mejor que a -> retorna positivo (1) y iguales -> retorna 0
    if a.frec != b.frec:
        return b.frec - a.frec
    elif a.word != b.word:
        return -1 if a.word < b.word else 1
    else:
        return 0   

def repeticions(seq:list[str], i:int, n:int) -> int:
    r = 1
    j = i + 1
    while j < n and seq[j] == seq[i]:
        r += 1
        j +=1
    return r

def compta(seq:list[str], n:int) -> list[Word]:
    paraules: list[Word] = []
    i = 0
    while i < n:
        reps = repeticions(seq, i, n)
        paraules.append(Word(seq[i], reps))
        i += reps
    return paraules

def escriure(paraules:list[Word], k:int) -> None:
    for i in range(k):
        print(paraules[i].word)
    print('----------')

def main() -> None:
    for n in tokens(int):
        k = read(int)
        seq = [read(str) for _ in range(n)]
        seq.sort()
        paraules = compta(seq, n)
        escriure(sorted(paraules, key=cmp_to_key(cmp)), k)
main()
import yogi
from typing import TypeAlias
from functools import cmp_to_key
from dataclasses import dataclass


def mainq() -> None:
    paraules: list[str] = []
    n = yogi.read(int)
    k = yogi.read(int)

    # lectura paraules
    for i in range(n):
        paraula = yogi.read(str)
        paraules.append(paraula)
    paraules.sort()

    # recompte repeticions
    recomptes: list[int] = [1] * len(paraules)
    i = 0
    while i <= len(paraules) - 1:
        if paraules[i] == paraules[i + 1]:
            recomptes[i] += 1
            recomptes.pop(-1)
            paraules.pop(i)
        i += 1

    # cerca dels k maxims recomptes
    maxims: list[int] = []
    p = 1
    while p <= k:
        maxims.append(p)
        p += 1
    print(maxims)
    print(recomptes)
    utilitzats: list[bool] = [False] * len(recomptes)
    for q in range(len(maxims)):
        for _ in range(len(recomptes)):
            if recomptes[_] >= recomptes[maxims[q]] and not utilitzats[_]:
                maxims[q] = _
                utilitzats[_] = True
    maxims.sort()

    """
    i = 0
    while i <= len(maxims) - 1:
        print(paraules[maxims[i]])
        i += 1
    print("-" * 10)"""


@dataclass
class Info:
    word: str
    n: int


Frequences: TypeAlias = list[Info]


def print_words(f: Frequences, k: int) -> None:
    for i in range(k):
        print(f[i].word)
    print("-" * 10)


def cmp(a: Info, b: Info) -> int:
    if a.n != b.n:
        return b.n - a.n
    if a.word != b.word:
        return -1 if a.word < b.word else 1
    return 0


def repetitions(lst: list[str], i: int) -> int:
    n = len(lst)
    r = 1
    j = i + 1
    while j < n and lst[j] == lst[i]:
        r += 1
        j += 1
    return r


def build_frequences(lst: list[str]) -> Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i = 0
    while i < n:
        r = repetitions(lst, i)
        f.append(Info(lst[i], r))
        i += r
    return f


def main() -> None:
    for n in yogi.tokens(int):
        k = yogi.read(int)
        f: Frequences = build_frequences([yogi.read(str) for _ in range(n)])
        f.sort(key=cmp_to_key(cmp))
        print_words(f, k)


if __name__ == "__main__":
    main()


"""
struct Info { //estructura
    string word;
    int n;
};


#función cmp en C++
bool cmp(const Info& a, const Info& b) {
    if (a.n != b.n) {
        /*
        if (a.n > b.n) return true;
        else return false;
        */
    if (a.n != b.n) return a.n > b.n;
    return a.word < b.word
}

}

int main() {
    vector<Info> f(...);
    ...
    sort(f.begin(), f.end(), cmp);
}
"""

from yogi import tokens, read
from dataclasses import dataclass

@dataclass
class Words:
    words: list[str]
    frequency: list[int]

def llegeix(lst: Words) -> None:
    """Llegeix les paraules i, si estan repetides, augmenta el contador de la seva freqüencia."""
    s = len(lst.words)
    paraula = read(str)
    repeated = False
    for i in range(s):
        if lst.words[i] == paraula:
            lst.frequency[i] += 1
            ordena(lst, i)
            repeated = True
    if not repeated:
        lst.words.append(paraula)
        lst.frequency.append(1)

def ordena(lst: Words, i: int) -> None:
    """Ordena les llistes de paraules i freqüència, sabent que estan ordenades de major a menor
    freqüència (i en empats, alfabèticament), i que la única que pot estar a un lloc menor del que li correspon està en la posició i."""
    while i > 0 and lst.frequency[i] > lst.frequency[i-1]:
        lst.frequency[i], lst.frequency[i-1] = lst.frequency[i-1], lst.frequency[i]
        lst.words[i], lst.words[i-1] = lst.words[i-1], lst.words[i]
        i -= 1
    while i > 0 and lst.words[i] < lst.words[i-1]:
        lst.words[i], lst.words[i-1] = lst.words[i-1], lst.words[i]

def escriu_paraules(lst: Words, k: int) -> None:
    """Escriu les k paraules més frequüents. En cas d'empat, escriu la primera en ordre alfabètic."""
    for i in range(k):
        print(lst.words[i])
    print('----------')

def main() -> None:
    for n in tokens(int):
        k = read(int)
        lst = Words (words=[], frequency=[])
        for _ in range(n):
            llegeix(lst)
        escriu_paraules(lst, k)

if __name__ == "__main__":
    main()
from dataclasses import dataclass
from yogi import read, tokens
from functools import cmp_to_key

@dataclass
class Paraula:
    paraula: str
    frequencia: int = 0

def compara(p1: Paraula, p2: Paraula) -> int:
    """Donades dues paraules retorna un valor positiu si la 1a és més gran, un negatiu si la 2a 
    és més gran i un 0 si són iguals"""
    if p1.frequencia != p2.frequencia:
        return p2.frequencia - p1.frequencia
    
    if p1.paraula > p2.paraula:
        return 1
    elif p1.paraula < p2.paraula:
        return -1
    else:
        return 0

def main():
    for n in tokens(int):
        k = read(int)
        par = sorted([read(str) for _ in range(n)])
        classes:list[Paraula] = []
        i = 0
        while i < n:
            c = 1
            j = i + 1
            while j < n and par[j] == par[i]:
                c += 1
                j += 1
            classes.append(Paraula(par[i], c))
            i = j
        
        freq = sorted(classes, key=cmp_to_key(compara))
        for i in range(k):
            print(freq[i].paraula)
        print("----------")
  
main()
from yogi import *
from dataclasses import dataclass
from functools import cmp_to_key


@dataclass
class Paraula:
    word: str
    freq: int

P: list[Paraula]

def comparacio(p1: Paraula, p2: Paraula) -> int:
    if p1.freq < p2.freq:
        return p1.freq - p2.freq
    elif p1.freq > p2.freq:
        return p1.freq - p2.freq
    else:
        if p1.word < p2.word:
            return -1
        elif p1.word > p2.word:
            return 1
        else:
            return 0    

def counting(L: list[str]) -> list[Paraula]:
    P: list[Paraula] = []
    m = len(L)
    last = L[0]
    c = 1
    for i in range(1, m):
        if L[i] == last:
            c += 1
        else:
            P.append(Paraula(last, c))
            c = 1
            last = L[i]
    P.append(Paraula(last, c))
    return P

def comparacio(p1: Paraula, p2: Paraula) -> int:
    if p1.freq < p2.freq:
        return 1
    elif p1.freq > p2.freq:
        return -1
    else:
        if p1.word < p2.word:
            return -1
        elif p1.word > p2.word:
            return 1
        else:
            return 0

def escriure(P: list[Paraula], m: int) -> None:
    for i in range(m):
        print(f"{P[i].word}")

def main() -> None:
    for n in tokens(int):
        m = read(int)
        L: list[str] = [read(str) for _ in range(n)]
        L.sort()
        escriure(sorted(counting(L), key=cmp_to_key(comparacio)), m)
        print('----------')

main()

                