The problem asks us to find the `k` most frequent words from a given sequence of `n` words. In case of ties in frequency, words should be ordered lexicographically (alphabetically). The input consists of multiple test cases, each starting with `n` and `k`, followed by `n` words.

The provided solution attempts to solve this problem by:
1. Reading the input `n` and `k`.
2. Reading `n` words and storing them in a list `P`.
3. Sorting the list `P` alphabetically.
4. Iterating through the sorted list to count the occurrences of each unique word and storing them as `Info` objects (containing the word and its count) in a list `V`.
5. Sorting the list `V` based on frequency (descending) and then alphabetically for ties.
6. Printing the first `k` words from the sorted `V` list.
7. Repeating this process until `n` becomes `None`.

**Analysis of the Code:**

**Strengths:**

*   **Correct Logic for Frequency Counting and Sorting:** The core logic of counting word frequencies and then sorting based on frequency and alphabetical order is generally correct. The use of a custom comparison function (`comp`) for sorting is appropriate for handling the tie-breaking condition.
*   **Handling Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly handles multiple test cases.
*   **Clear Data Structure for Word Information:** The `Info` class is a good choice to encapsulate the word and its frequency.
*   **Use of `yogi.read`:** This is appropriate for reading input token by token as expected by the `yogi` judging system.

**Weaknesses and Potential Issues:**

1.  **Incorrect Sorting Logic in `comp` function for ties:**
    The `comp` function returns `a.num > b.num` if frequencies are different. This means it sorts in descending order of frequency, which is correct.
    However, when frequencies are equal (`a.num == b.num`), it returns `a.par < b.par`. This condition correctly sorts alphabetically in ascending order for ties. The issue might be in how `V.sort(key=comp, reverse=True)` is used. When `reverse=True` is used with a custom `key` function that already dictates a specific order, it can lead to unexpected results or override the intended logic. The `comp` function itself is designed to sort in the desired order (frequency descending, then word ascending). Applying `reverse=True` to a sort that's already defined to handle both criteria might be problematic or redundant.

2.  **Potential Inefficiency in Counting:**
    The way the code counts frequencies involves sorting the entire list of `n` words first (`P.sort()`) and then iterating through it again to create `V`. While this works, it's not the most efficient way. Using a dictionary (like `collections.Counter` in Python) to store word counts directly is generally more performant for frequency counting, especially for large inputs.

3.  **Redundant Sorting for Initial Input:**
    The code sorts `P` alphabetically (`P.sort()`) and then iterates to create `V`. The initial sort of `P` is necessary for efficiently counting consecutive identical words. However, the `V.sort(key=comp, reverse=True)` is the crucial sorting step. The `reverse=True` here is likely the source of the "Wrong Answer" as it might be reversing the order established by `comp` incorrectly.

**Example of the issue with `reverse=True`:**

Let's say `comp` is designed to sort elements such that 'better' elements come first. If `comp(a, b)` returns `True` when `a` is "better" than `b`, then `list.sort(key=comp)` will sort in ascending order of "betterness". If you then use `reverse=True`, it reverses this order, potentially putting "worse" elements first.

In this case, `comp` returns `True` if `a.num > b.num` or if `a.num == b.num` and `a.par < b.par`. This means `comp` returns `True` when `a` is "better" (higher frequency, or alphabetically smaller if frequencies are equal). So, `V.sort(key=comp)` without `reverse=True` should already produce the desired order. Adding `reverse=True` might be what's causing the incorrect ordering.

**Suggested Improvements:**

1.  **Correct the Sorting:**
    Remove `reverse=True` from `V.sort(key=comp, reverse=True)`. The `comp` function is designed to define the correct order directly.

    ```python
    # Original:
    # V.sort(key=comp, reverse=True)
    # Corrected:
    V.sort(key=comp)
    ```

2.  **Consider Using a Dictionary for Counting:**
    A more Pythonic and potentially efficient approach for counting frequencies is to use a dictionary or `collections.Counter`. This avoids the initial sort of all words and then a second pass to count.

    Here's an example of how that could look:

    ```python
    from collections import Counter

    # ... (inside the while loop) ...

    word_counts = Counter(P) # P is the list of n words read

    # Convert to a list of (word, count) tuples
    # The problem requires sorting by count (descending) then word (ascending)
    # So we need a custom key for sorting the items
    sorted_words = sorted(word_counts.items(), key=lambda item: (-item[1], item[0]))

    # Print the first k words
    for i in range(k):
        print(sorted_words[i][0])
    print("----------")
    ```
    This approach is generally more straightforward and idiomatic in Python.

**Revised `comp` function and its application:**

Let's re-examine the `comp` function and its usage.

```python
# define comparator function
def comp(a, b):
  if a.num != b.num:
    return a.num > b.num # True if a is "better" (higher freq)
  return a.par < b.par  # True if a is "better" (alphabetically smaller)
```

This `comp` function is designed to return `True` if the first argument (`a`) should come *before* the second argument (`b`) in the sorted list.

When you use `V.sort(key=comp, reverse=True)`:
*   `key=comp` means `sort` will use the `comp` function to compare elements.
*   `reverse=True` means the sort order will be reversed from what `comp` normally dictates.

If `comp` returns `True` when `a` is *better*, then `V.sort(key=comp)` would sort such that better elements come first (ascending order of "betterness"). Applying `reverse=True` would then reverse this, putting worse elements first.

The problem requires:
1.  Highest frequency first.
2.  If frequencies are equal, smallest word (lexicographically) first.

Let's consider two items: `item_A = Info("apple", 5)` and `item_B = Info("banana", 5)`.
`comp(item_A, item_B)`: `a.num == b.num` (5 == 5). Then `a.par < b.par` ("apple" < "banana") returns `True`. So, `comp` says `item_A` is "better".

Now consider `item_C = Info("apple", 5)` and `item_D = Info("apricot", 3)`.
`comp(item_C, item_D)`: `a.num != b.num` (5 != 3). `a.num > b.num` (5 > 3) returns `True`. So, `comp` says `item_C` is "better".

The `comp` function correctly defines the "better" item according to the problem's criteria. When used with `sort()` (without `reverse=True`), `sort()` arranges elements such that if `comp(a, b)` is `True`, `a` comes before `b`. This is precisely what's needed. Therefore, `reverse=True` is incorrect.

**Conclusion:**

The primary reason for the "Wrong Answer" is likely the incorrect usage of `reverse=True` with a custom comparison function that already defines the desired sorting order. Removing `reverse=True` should fix the issue. For a more Pythonic approach, using `collections.Counter` is recommended for frequency counting.

**Feedback Text:**

---

**Problem:** Paraules més freqüents (Most Frequent Words)

**Solution Approach:**
The program aims to find the `k` most frequent words from a sequence of `n` words. It first reads the input, counts the occurrences of each word, and then sorts these words based on their frequency in descending order. In case of a tie in frequency, words are sorted alphabetically in ascending order.

**Code Analysis:**

*   **Strengths:**
    *   The `Info` class effectively stores word-frequency pairs.
    *   The `comp` function correctly implements the comparison logic for frequency (descending) and alphabetical order (ascending) for ties.
    *   The main loop correctly handles multiple test cases.

*   **Weaknesses:**
    *   **Incorrect Sorting with `reverse=True`:** The primary issue appears to be the use of `V.sort(key=comp, reverse=True)`. The `comp` function already defines the desired order (higher frequency first, then alphabetical for ties). Applying `reverse=True` negates this logic, leading to incorrect sorting. When `comp(a, b)` returns `True`, it signifies that `a` is "better" than `b`. `list.sort()` without `reverse=True` will place "better" elements earlier, which is the desired outcome.
    *   **Potential for Inefficiency:** While the current method of sorting the entire list first and then iterating to count works, it might not be the most efficient approach for very large inputs. Using a dictionary (like `collections.Counter`) for frequency counting is often more performant.

**Suggestions for Improvement:**

1.  **Correct the Sorting Call:**
    Remove the `reverse=True` argument from the `V.sort()` call. The `comp` function correctly defines the sorting criteria, and `reverse=True` is causing the issue.

    Change:
    `V.sort(key=comp, reverse=True)`
    To:
    `V.sort(key=comp)`

2.  **Consider Using `collections.Counter` (Optional but Recommended):**
    For a more idiomatic and often more efficient solution in Python, consider using `collections.Counter` to tally word frequencies. This avoids the need for an initial sort of all words and then a manual counting loop.

    Example using `Counter`:
    ```python
    from collections import Counter
    # ... inside the while loop ...
    # P is the list of n words read
    word_counts = Counter(P)
    # Sort items by frequency (descending) then word (ascending)
    sorted_words = sorted(word_counts.items(), key=lambda item: (-item[1], item[0]))
    # Print the first k words
    for i in range(k):
        print(sorted_words[i][0])
    print("----------")
    ```

By fixing the sorting call, the current approach should correctly solve the problem. The suggestion to use `Counter` is for improved efficiency and Pythonic style.

---