This feedback analyzes the provided Python program for the "Paraules més freqüents" problem, which resulted in a "Wrong Answer".

---

### Feedback on "Paraules més freqüents" Program

**1. Problem and Solution Approach Summary**

The problem requires reading a sequence of `n` words and identifying the `k` most frequent ones. If multiple words have the same frequency, they should be ordered lexicographically (alphabetically).

The submitted Python program implements a common and generally efficient approach:
1.  Read all `n` words into a list (`P`).
2.  Sort this list alphabetically (`P.sort()`). This groups identical words together.
3.  Iterate through the sorted list to count the frequency of each unique word. Store these unique words and their counts in a new list of custom `Info` objects (`V`).
4.  Sort the `V` list based on the problem's criteria:
    *   Primary sort: descending by frequency.
    *   Secondary sort (tie-breaker): ascending by word (lexicographical order).
5.  Print the first `k` words from the sorted `V` list, followed by a separator.
6.  The program correctly handles multiple test cases.

**2. Code Strengths and Weaknesses**

**Strengths:**

*   **Clear Data Structure:** The `Info` class (with `par` for word and `num` for count) is well-defined and clearly encapsulates the necessary data for each unique word.
*   **Efficient Frequency Counting:** Sorting the initial list of all words (`P.sort()`) and then iterating through it to count frequencies for unique words (`while i < n: ... while j < n and P[j] == P[i]:`) is an efficient and standard way to solve this part of the problem. It avoids repeated linear scans or hash table lookups during counting after the initial sort.
*   **Modular Comparison Logic:** The `comp` function clearly defines the desired sorting logic (more frequent first, then lexicographically smaller).
*   **Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly handles multiple sets of input, as required by the problem.
*   **Output Format:** The program adheres to the specified output format, including the `----------` separator.

**Weaknesses:**

*   **Incorrect Usage of `key` in `list.sort()`:** This is the primary reason for the "Wrong Answer". The `list.sort()` method's `key` argument expects a function that takes a single element from the list and returns a value to be used for comparison. However, the `comp` function is defined to take *two* arguments (`a` and `b`) and return a boolean indicating their relative order.
    *   When `V.sort(key=comp, reverse=True)` is executed, Python tries to call `comp` with a single `Info` object as its argument, which will likely result in a `TypeError` (missing required argument `b`). Even if it didn't error, passing `comp` (which returns a boolean) as a `key` directly would not produce the desired sorting behavior. Python's `sort` would attempt to sort the boolean results of `comp(element)` which makes no sense for ordering `Info` objects.

**3. Suggestions for Improvement**

The core issue lies in how the `V` list is sorted. Here's how to fix it:

1.  **Modify the `V.sort()` call to use a `lambda` function for the `key`:**
    The most Pythonic and correct way to sort by multiple criteria (first by frequency descending, then by word ascending) is to provide a `key` function that returns a tuple. Python sorts tuples element by element. To achieve descending order for frequency, you can negate the frequency count.

    **Current problematic line:**
    ```python
    V.sort(key=comp, reverse=True)
    ```

    **Corrected line:**
    ```python
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    *   `x.num` (frequency) is negated (`-x.num`) so that higher frequencies appear earlier when sorting in ascending order by this key.
    *   `x.par` (word) is left as is, so that for equal (negated) frequencies, words are sorted alphabetically.

2.  **(Alternative, less direct but uses `comp` logic): Use `functools.cmp_to_key` (if `comp` was a classic comparison function):**
    If `comp` were defined to return -1, 0, or 1 (like a traditional C-style comparison function), you could use `functools.cmp_to_key`. However, your `comp` function returns a boolean. If you *were* to define `comp` as a proper comparison function:

    ```python
    from functools import cmp_to_key

    def custom_cmp_func(a, b):
        if a.num != b.num:
            return b.num - a.num # b.num > a.num means a should come after b (positive result)
                                 # b.num < a.num means a should come before b (negative result)
        if a.par < b.par:
            return -1
        elif a.par > b.par:
            return 1
        return 0

    # Then call sort like this (without reverse=True, as custom_cmp_func dictates the order):
    V.sort(key=cmp_to_key(custom_cmp_func))
    ```
    But the `lambda` approach (`key=lambda x: (-x.num, x.par)`) is generally preferred in modern Python for its simplicity and directness.

By implementing the `lambda` based sorting key, your program should correctly order the words according to the problem's specifications and pass the test cases.

---