Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**Problem Summary:**
The problem asks to read `n` words and then output the `k` most frequent words. If multiple words have the same frequency, they should be ordered alphabetically. The program needs to handle multiple test cases, each separated by a line of ten hyphens.

**Solution Approach:**
The program implements the following steps:
1.  **Input Reading:** Reads `n` and `k`, then reads `n` words into a list `P`.
2.  **Initial Sorting:** Sorts the list `P` alphabetically. This groups identical words together, facilitating frequency counting.
3.  **Frequency Counting:** Iterates through the sorted list `P` to count the occurrences of each unique word. It stores each unique word along with its frequency in a list `V` of custom `Info` objects (`par` for the word, `num` for its frequency).
4.  **Custom Sorting:** Defines a comparison function `comp` to specify the desired order: descending by frequency, then ascending alphabetically by word. It then attempts to sort the `V` list using this custom comparator.
5.  **Output:** Prints the `k` words from the sorted `V` list and then the `----------` separator.
6.  **Multiple Cases:** The `main` function includes a `while` loop to process multiple test cases until `n` or `k` are `None`.

**Strengths:**
*   **Clear Structure:** The code is well-structured with a dedicated `Info` class and a separate comparison function, enhancing readability.
*   **Efficient Initial Sorting:** Sorting the input words initially (`P.sort()`) is a good strategy to enable efficient frequency counting in a single pass.
*   **Correct Counting Logic:** The `while` loop that populates list `V` correctly identifies unique words and calculates their frequencies after the initial sort.
*   **Handles Multiple Test Cases:** The `while` loop in `main` correctly manages multiple sets of input, as required by the problem statement.
*   **Correct Comparison Logic (Conceptual):** The logic within the `comp` function correctly defines the desired sorting criteria (descending frequency, then ascending alphabetical order).

**Weaknesses:**
*   **Critical Sorting Error (`TypeError` or Incorrect Output):** The most significant weakness, and likely the cause of the "Wrong Answer" verdict, lies in how the custom comparison function `comp` is used with `V.sort(key=comp, reverse=True)`.
    *   In standard Python 3, the `key` argument for `list.sort()` expects a function that takes *one* argument (an element from the list) and returns a value to be used for comparison. Your `comp` function, however, is designed as a *binary comparison predicate* (taking two arguments `a` and `b` and returning a boolean), similar to how custom comparators work in C++'s `std::sort`.
    *   Directly passing `key=comp` will typically result in a `TypeError` because `sort` tries to call `comp(item)` with only one argument. If it somehow runs without a `TypeError` (perhaps due to a specific execution environment or Python version detail), the sorting will not behave as intended, leading to incorrect output. The `reverse=True` part is also redundant if the `key` already encapsulates the descending order.

**Suggestions for Improvement:**

1.  **Correct the Custom Sorting for `V` (Most Important):**
    The `comp` function needs to be adapted for Python's `key` argument. The most Pythonic and effective way to achieve compound sorting (primary key, then secondary key) is to have the `key` function return a tuple:
    ```python
    # Remove the 'comp' function entirely if using this lambda approach
    # in the main function:
    V.sort(key=lambda x: (-x.num, x.par))
    # Note: 'reverse=True' is no longer needed because -x.num handles descending order.
    ```
    *   `-x.num` ensures that items with higher frequencies (`num`) appear first (descending order).
    *   `x.par` (the word itself) ensures that for equal frequencies, words are sorted alphabetically (ascending order).

    Alternatively, if you specifically want to use a comparison function that takes two arguments, you must convert it using `functools.cmp_to_key` (available in `functools` module):
    ```python
    import functools
    # ...
    # Define a comparison function that returns -1, 0, or 1
    def comp_for_key(a, b):
      if a.num > b.num: return -1  # a comes before b (descending frequency)
      if a.num < b.num: return 1   # b comes after a
      # Frequencies are equal, sort alphabetically (ascending)
      if a.par < b.par: return -1  # a comes before b
      if a.par > b.par: return 1   # b comes after a
      return 0 # elements are equal

    # ...
    # in main function:
    V.sort(key=functools.cmp_to_key(comp_for_key))
    # Note: 'reverse=True' is not needed with this approach either.
    ```
    The `lambda` approach is generally preferred for its conciseness.

2.  **Simplify Frequency Counting (Optional):**
    For more concise code, Python's `collections.Counter` can be used to count word frequencies:
    ```python
    from collections import Counter
    # ...
    # In main function, after reading words into P:
    # (P.sort() would not be strictly necessary before Counter, but is a good initial step for tie-breaking considerations if not using a custom object for sorting)
    word_counts = Counter(P)
    V = []
    for word, count in word_counts.items():
        V.append(Info(word, count))
    # Then proceed with V.sort(key=lambda x: (-x.num, x.par))
    ```
    While your current manual counting method is correct and efficient after initial sorting, `Counter` offers a more idiomatic Python solution.

By addressing the sorting logic for the `V` list, the program should produce the correct output according to the problem's specifications.

---