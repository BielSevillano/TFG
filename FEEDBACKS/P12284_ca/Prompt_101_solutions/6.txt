The program aims to solve the problem of finding the `k` most frequent words from a given sequence of `n` words, with ties broken by alphabetical order.

### Solution Approach

The chosen approach is as follows:
1.  Read all `n` words into a list (`P`).
2.  Sort this list alphabetically (`P.sort()`). This groups identical words together.
3.  Iterate through the sorted list to count the frequency of each unique word. These unique words and their counts are stored in `Info` objects (`par` for word, `num` for count).
4.  Store these `Info` objects in a new list (`V`).
5.  Sort the list `V` of `Info` objects. The primary sorting criterion is the frequency (descending), and the secondary criterion (for ties in frequency) is the word itself (alphabetical order, ascending).
6.  Print the `par` (word) attribute of the first `k` `Info` objects from the sorted list `V`.
7.  Handle multiple test cases, printing a separator after each case.

### Analysis of the Code

**Strengths:**

*   **Clear Data Structure:** The `Info` class effectively encapsulates a word and its frequency, making the code readable and organized.
*   **Efficient Frequency Counting:** By sorting the initial list of words (`P`), the program can count frequencies in a single linear pass. This is an efficient approach (overall complexity dominated by the initial sort, typically O(N log N) where N is the total number of words).
*   **Modularity:** Defining a separate `comp` function for sorting criteria promotes modularity, although its usage needs correction.
*   **Correct Input/Output Loop:** The `while n is not None and k is not None:` loop correctly handles multiple test cases as described in the problem statement.
*   **Tie-breaking Logic:** The logic within the `comp` function (`a.num > b.num` for frequency, `a.par < b.par` for alphabetical tie-breaking) correctly reflects the problem's requirements *if applied correctly*.

**Weaknesses:**

*   **Critical Flaw: Incorrect use of `sort` `key` function:** The primary reason for the "Wrong Answer" is the incorrect usage of the `comp` function with `V.sort(key=comp, reverse=True)`. In Python 3, the `key` argument for `list.sort()` expects a function that takes a *single* element from the list and returns a value to be used for comparison. The provided `comp` function is a *comparison function* that takes *two* elements and returns a boolean indicating their relative order (similar to Python 2's `cmp` argument).
    When `list.sort` attempts to call `comp` with a single argument (an `Info` object), it will likely raise a `TypeError` or produce unexpected behavior, as it's not being used as intended. Even if it didn't error, `comp` returning `True`/`False` does not provide a stable sort key for Python's `sort`.
*   **Redundant `reverse=True` (if `comp` was a proper key):** If `comp` were correctly designed to return a tuple `(-num, par)` for a single `Info` object, then `reverse=True` would be unnecessary because `-num` already handles descending order for frequency. For the current `comp` function, `reverse=True` further complicates the interpretation of the comparison logic.

### Suggestions for Improvement

1.  **Correct the Sorting of `V` (Primary Fix):**
    The `comp` function should be rewritten as a `key` function that returns a tuple for comparison, or it should be adapted for `functools.cmp_to_key`. The most straightforward and Pythonic way to implement multi-level sorting with a custom key is to return a tuple:

    ```python
    import yogi
    # from functools import cmp_to_key # Only if sticking to the comp(a,b) style

    # define struct Info
    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

    # Remove the old comp function or convert it to a key generator if needed.
    # The current `comp` function returns a boolean based on two arguments,
    # which is not what `list.sort(key=...)` expects.

    # main function
    def main():
      # initialize variables
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        P = []

        # read input and append to P
        for i in range(n):
          P.append(yogi.read(str))

        # sort P in ascending order
        P.sort()

        # create list V
        V = []

        # loop through P and append Info objects to V
        i = 0
        while i < n:
          j = i + 1
          while j < n and P[j] == P[i]:
            j += 1
          a = Info(P[i], j - i)
          V.append(a)
          i = j

        # Sort V using a lambda function that returns a tuple as the key.
        # (-x.num) sorts frequency in descending order.
        # (x.par) sorts words alphabetically in ascending order for ties.
        V.sort(key=lambda x: (-x.num, x.par)) 
        # No need for reverse=True here because -x.num handles descending sort

        # print the first k elements of V
        for j in range(k):
          print(V[j].par)

        # print separator
        print("----------")

        # update n and k
        n = yogi.read(int)
        k = yogi.read(int)

    # call main function
    if __name__ == "__main__":
      main()
    ```
    This change directly addresses the "Wrong Answer" by providing a valid `key` function for Python's `list.sort()`.

2.  **Consider Using `collections.Counter` (for Python environment):**
    For a more concise and potentially slightly more efficient way to count frequencies in Python, `collections.Counter` can be used. This would eliminate the manual sorting of `P` and the `while` loop for counting.

    ```python
    import yogi
    from collections import Counter # Import Counter

    # (Info class might still be useful for explicit structure, but Counter can replace it)

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        words_list = []
        for _ in range(n):
          words_list.append(yogi.read(str))

        # Use Counter to get frequencies
        word_counts = Counter(words_list)

        # Convert to a list of (word, count) tuples for sorting
        # Or to a list of Info objects if desired
        V = []
        for word, count in word_counts.items():
            V.append(Info(word, count)) # If using the Info class

        # Sort using the lambda key as before
        V.sort(key=lambda x: (-x.num, x.par)) 

        for j in range(k):
          print(V[j].par)

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```