
                Write a feedback text for the following program that solves the problem described below.
                
                Paraules més freqüents

Feu un programa que llegeixi una seqüència de n paraules, i n’escrigui
les k més freqüents (en cas d’empat, les més petites en ordre
alfabètic).

Entrada

L’entrada consisteix en diversos casos. Cada cas comença amb n i k,
seguides de n paraules només amb lletres minúscules. Podeu suposar que k
està entre 1 i el nombre de paraules diferents.

Sortida

Per a cada cas, escriviu les k paraules més freqüents en ordre. Primer
cal escriure les paraules més freqüents, i en cas d’empat les paraules
més petites en ordre lexicogràfic. Escriviu una línia amb 10 guions al
final de cada cas.

Autor

Salvador Roura

© Jutge.org, 2006–2025.
                

                This is the program:

                from yogi import *
from dataclasses import dataclass
from typing import TypeAlias
from functools import cmp_to_key


@dataclass
class Info:
    paraula: str
    freq: int


Frequencies: TypeAlias = list[Info]


def printea(f: Frequencies, k: int) -> None:
    for i in range(k):
        print(f[i].paraula)
    print("-" * 10)


def comparem(a: Info, b: Info) -> int:
    if a.freq != b.freq:
        return b.freq - a.freq
    if a.paraula != b.paraula:
        return -1 if a.paraula < b.paraula else 1
    return 0


def paraula_repetida(lst: list[str], i: int, n: int) -> int:
    j = i + 1
    comptador = 1
    while j < n and lst[i] == lst[j]:
        j += 1
        comptador += 1
    return comptador

def llegir_freq(f: list[str], n: int) -> Frequencies:
    i = 0
    r: Frequencies = []
    f.sort()
    while i < n:
        freq = paraula_repetida(f, i, n)
        r.append(Info(f[i], freq))
        i += freq

    return r

def main() -> None:
    for n in tokens(int):
        k = read(int)
        f: Frequencies = llegir_freq([read(str) for _ in range(n)], n)
        f.sort(key=cmp_to_key(comparem))
        printea(f, k)


main()


                The result of the program is: Accepted

                The feedback should include:
                - A brief summary of the problem and the solution approach.
                - An analysis of the code's strengths and weaknesses.
                - Suggestions for improvement, if any.

                You can rely on the following other possible solutions to the same problem for reference:
                from jutge import read

n = read(int)
k = read(int)

while n is not None:

	freq = {}
	for i in range(n):
		w = read(str)
		if w not in freq:
			freq[w] = 1
		else:
			freq[w] += 1

	out = 0
	while out < k:
		mx = 0
		mxw = []
		for w in freq:
			if freq[w] > mx:
				mx = freq[w]
				mxw = [w]
			elif freq[w] == mx:
				mxw.append(w)
		mxw = sorted(mxw)
		for w in mxw:
			print(w)
			out += 1
			freq[w] = 0
			if out == k:
				break

	print("----------")

	n = read(int)
	k = read(int)

from jutge import read
from operator import itemgetter

def add_word(dic, pal):
    if pal in dic:
        dic[pal] += 1
    else:
	    dic[pal] = 1


def main(n):
	k = read(int)
	dic = {}
	for i in range(n):
		add_word(dic, read(str))
	lista_pal_freq = []
	for pal,freq in dic.items():
		lista_pal_freq.append((pal,freq))
	lista_pal_freq.sort(key = itemgetter(0))
	#print(lista_pal_freq)
	lista_pal_freq.sort(key = itemgetter(1), reverse = True)
	#print(lista_pal_freq)
	for i in range(k):
		print(lista_pal_freq[i][0])
	print(10*'-')
	
		
def main_main():
	n = read(int)
	while n is not None:
		main(n)
		n = read(int)


main_main()		

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct Paraula {
	string s;
	int f;
};


bool ordena (const Paraula& a, const Paraula& b) {
	if (a.f > b.f) return true;
	if (b.f > a.f) return false;
	
	return a.s < b.s;
}


int main() {
	
	int n, k;
	while (cin >> n >> k) {
		
		//Llegim totes les paraules
		vector<string> paraules(n);
		for (int i = 0; i < n; i++) {
			cin >> paraules[i];
		}
		
		//Ordenem el vector de paraules
		sort(paraules.begin(), paraules.end());
		
		//Fem un vector buit de paraules i les seves repeticions
		vector<Paraula> frequencies(0);
		
		Paraula aux = {paraules[0], 1};
		for (int i = 1; i < n; i++) {
			
			if (aux.s == paraules[i]) aux.f++;
			else {
				frequencies.push_back(aux);
				aux = {paraules[i], 1};
			}
		}
		frequencies.push_back(aux);
		
		//Ordenem el vector en funcio de les repeticions
		sort(frequencies.begin(), frequencies.end(), ordena);
		
		//Imprimim les k paraules mes repetides
		for (int i = 0; i < k; i++)
			cout << frequencies[i].s << endl;
		cout << "----------" << endl;
	}
	
}

from yogi import tokens, read
from functools import cmp_to_key

def ordenar(llista1: tuple[str,int], llista2: tuple[str,int]) -> int:
    if llista1[1] > llista2[1]:
        return 1
    elif llista1[1] < llista2[1]:
        return -1
    else:
        if llista1[0] > llista2[0]:
            return -1
        return 1


for n in tokens(int):
    k = read(int)
    llista = []

    for x in range(n):
        paraula = read(str)
        llista.append(paraula)

    llista.sort()

    paraula_anterior = llista[0]
    c = 1
    llista_def = []
    for paraula in llista[1:n-1]:
        if paraula == paraula_anterior:
            c += 1
        else:
            llista_def.append([paraula_anterior,c])
            c = 0
        paraula_anterior = paraula
    llista_def.append([paraula_anterior,c])

    sorted(llista_def,key=cmp_to_key(ordenar))

    for x in range(k):
        print(llista_def[x][0], end=' ')
    print('')
    print('-'*10)
from dataclasses import dataclass
from yogi import scan
from functools import cmp_to_key
 
@dataclass
class paraula:
    contingut: str
    vegades: int
 
def comparacio(p1: paraula, p2: paraula) -> int:
    if p1.vegades == p2.vegades:
        return 1 if p1.contingut > p2.contingut else -1
    return -1 if p1.vegades > p2.vegades else 1
 
def main():
    n = scan(int)
    k = scan(int)
    while n is not None:
        paraules: list[str] = [scan(str) for _ in range(n)]
        paraules.sort()
 
        numero_paraules: list[paraula] = []
        current_count = 1
 
        for i in range(1, n):
            if paraules[i - 1] != paraules[i]:
                numero_paraules.append(paraula(paraules[i - 1], current_count))
                current_count = 1
            else: current_count += 1
 
        numero_paraules.append(paraula(paraules[-1], current_count))
 
        numero_paraules_ordenades = sorted(numero_paraules, key=cmp_to_key(comparacio))
 
        for i in range (k):
            print (numero_paraules_ordenades[i].contingut)
        print ('-' * 10)
 
        n = scan(int)
        k = scan(int)
 
if __name__ == '__main__':
    main()
from yogi import scan

def main():
    n = scan(int)
    k = scan(int)
    while n is not None:
        paraules: list[str] = []
        repeticions: list[int] = [0 for i in range(n)]
        for i in range(n):
            x = scan(str)
            j = 0
            while j < len(paraules) and paraules[j] != x:
                j += 1
            
            repeticions[j] += 1
            paraules.append(x)
        
        

        for i in range(k):
            max: int = 0
            index = -1
            for j in range(len(repeticions)):
                if repeticions[j] > max or (repeticions[j] == max and paraules[j] < paraules[index]):
                    max = repeticions[j]
                    index = j
            print(paraules[index])
            repeticions[index] = 0
            index = -1
            max = 0
        print('----------')
            
        n = scan(int)
        k = scan(int)


if __name__ == "__main__":
    main()
from yogi import scan

def main():
    n = scan(int)
    k = scan(int)
    while n is not None:
        paraules: list[str] = []
        maxims: list[int] = [0 for i in range(k)]
        indexs: list[int] = [-1 for i in range(k)]
        repeticions: list[int] = [0 for i in range(n)]
        for i in range(n):
            x = scan(str)
            j = 0
            while j < len(paraules) and paraules[j] != x:
                j += 1
            
            repeticions[j] += 1
            _ = 0
            while _ < k:
                if repeticions[j] > maxims[_] or (repeticions[j] == maxims[_] and x < indexs[_]):
                    if _ < k-1 and x != indexs[_]:
                        maxims[_+1] = maxims[_]
                        indexs[_+1] = indexs[_]
                    maxims[_] = repeticions[j]
                    indexs[_] = x

                    _ = k
                _ += 1
                
            paraules.append(x)
        
        for i in indexs:
            print(i)
        print('----------')
       
            
        n = scan(int)
        k = scan(int)


if __name__ == "__main__":
    main()
from yogi import read, scan
from dataclasses import dataclass

@dataclass
class Paraules:
    paraula: str
    repeticions: int


def comparacio(p1: Paraules, p2: Paraules) -> int:
    if p1.repeticions == p2.repeticions:
        if p1.paraula > p2.paraula:
            return 1
        else:
            return -1
    
    if p1.repeticions > p2.repeticions:
        return -1
    else:
        return 1


def main() -> None:
    n = scan(int)
    while n is not None:
        k = read(int)
        list_paraules = [read(str) for _ in range(n)]
        list_paraules.sort()

        num_paraules: list[Paraules] = []
        comptador = 1

        for i in range(1, n):
            if list_paraules[i - 1] != list_paraules[i]:
                num_paraules.append(Paraules(list_paraules[i - 1], comptador))
                comptador = 1
            else:
                comptador += 1
            
        num_paraules.append(Paraules(list_paraules[-1], comptador))
        num_paraules_ordenades = sorted(num_paraules, key=comparacio)

        for i in range(k):
            print(num_paraules_ordenades[i].paraula)
        print('-' * 10)

        n = scan(int)


if __name__ == "__main__":
    main()
from yogi import read,tokens
from dataclasses import dataclass

@dataclass
class Paraula: 
    paraula: str
    freq: int

def frequencia(p: Paraula) -> int:
    return p.freq

def main() -> None:

    for n in tokens(int):
        count = 1 # comptador de freqüències
        L: list[str] = list() # llista de les paraules que llegim
        f = read(int)

        for _ in range(n):
            p = read(str)
            L.append(p)
        L.sort()
        L.reverse()

        Paraules: list[Paraula] = list()

        i = 0
        while i < n:
            count = 1
            while i < n-1 and L[i] == L[i+1]:
                count += 1
                i += 1
            Paraules.append(Paraula(L[i],count))
            i += 1

        ordenada = sorted(Paraules, key=frequencia)
        
        for x in range(f): 
           print(ordenada[len(ordenada)-1-x].paraula)
        
        print(10*"-")







if __name__ == '__main__':
    main()


from yogi import read, tokens


def mes_frequent(L: list[str], n: int) -> str:
    """Donada una llista L ordenada de llargada n, retorna l'element més freqüent de la llista."""

    element_mes_frequent = L[0]
    repeticions_maximes = 1
    repeticions = 1

    for i in range(1, n):
        if L[i-1] == L[i]:
            repeticions += 1
        else:
            if repeticions > repeticions_maximes:
                repeticions_maximes = repeticions
                element_mes_frequent = L[i-1]
                repeticions = 1
            elif repeticions == repeticions_maximes:
                if element_mes_frequent > L[i-1]:
                    element_mes_frequent = L[i-1]
                repeticions = 1
            else:
                repeticons = 1

    if repeticions > repeticions_maximes:
        element_mes_frequent = L[n-1]
        repeticions_maximes = repeticions
    elif repeticions_maximes == 1:
        if L[n-2] < element_mes_frequent:
            element_mes_frequent = L[n-2]
        if L[n-1] < element_mes_frequent:
            element_mes_frequent = L[n-1]
    elif repeticions == repeticions_maximes:
            if element_mes_frequent > L[n-1]:
                element_mes_frequent = L[i-1]
    
    return element_mes_frequent


def elimina_paraula(L: list[str], paraula: str, n: int) -> None:
    """Donada una llista L ordenada de llargada n, elimina la paraula de la llista."""

    i = 0
    while i<n and paraula != L[i]:
        i += 1
    while i<n and paraula == L[i]:
        del(L[i])
        n = len(L)



def main() -> None:
    """Programa principal."""

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]

        L = sorted(L) # ordeno la llista per a que em sigui més fàcil trobar l'element/s més freqüent

        for i in range(k):
            if i < k - 1:
                a = mes_frequent(L,n)
                print(a)
                elimina_paraula(L, a, n)
                n = len(L)
            else:
                a = mes_frequent(L,n)
                print(a)
        print('----------')
    



if __name__ == '__main__':
    main()
from yogi import read, tokens

def moda(L:list[str], n: int)->tuple[str , int]:
    """Retorna la paraula mes frequent de L (llista ordenada) i la seva posicio, de longuitud n i que sigui diferent a "-". Si hi ha empat la mes petita."""
    
    i = 0
    mes_frec = "*"
    max_vegades = 0
    posicio_interes = 0
    while i < n:

        veg = comptant_frec(L, i, n) 
        if veg > max_vegades and L[i] != "-":
            max_vegades = veg
            mes_frec = L[i]
            posicio_interes = i
        i += veg

    return (mes_frec, posicio_interes)

def substitur(L:list[str], i: int, n:int)->None:
    """Substitueix tots els elements que siguin igual a L[i] de la llista ordenada L per -. n es la longuitud de la llista."""
    
    vegades_apareix = comptant_frec(L, i, n)
    for i in range(i, i + vegades_apareix , 1):
        L[i] = "-"

def comptant_frec(L:list[str], i:int, n:int)->int:
    """Retorna el num de vegades que apareix l element de la posicio i a la llista ordenada L de longuitud n."""
    suma = 1
    
    while i+1 < n and L[i] == L[i+1]:
        suma += 1
        i += 1

    return suma
            
def paraules_mes_frec(L:list[str], n:int, k:int)->None:
    """Printeja les k paraules mes frequents de L en ordre de frequencia. L te longuitud n."""
    mes_frec = "*"
    for _ in range(k):
        mes_frec = moda(L,n)
        print(mes_frec[0])
        substitur(L, mes_frec[1], n)
    print("----------")


def main():

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]
        L.sort()
        paraules_mes_frec(L, n, k)
    

if __name__ == """__main__""":
    main()
from yogi import read, tokens
from dataclasses import dataclass
from functools import cmp_to_key


@dataclass
class Paraula:
    repeticions: int
    paraula: str


def repeticions(L: list[str]) -> list[Paraula]:
    """Donada una llista de paraules L ordenada, retorna una llista de Paraula on s'indica el número de repeticions que apareix la paraula en L."""

    n = len(L)
    repeticions = 1
    paraules_i_repeticions: list[Paraula] = list()

    for i in range(n-1):
        if L[i] == L[i+1]:
            repeticions += 1
        else:
            p1 = Paraula (
                repeticions,
                L[i],
            )
            paraules_i_repeticions.append(p1)
            repeticions = 1
    
    if L[n-1] == L[n-2]: #en l'anterior bucle no hem pogut comparar el darrer element de la llista L
        p1 = Paraula(
            repeticions,
            L[n-1]
        )
        paraules_i_repeticions.append(p1)
    else:
        p1 = Paraula(
            repeticions,
            L[n-1]
        )
        paraules_i_repeticions.append(p1)

    return paraules_i_repeticions


def comparacio(p1: Paraula, p2: Paraula) -> int:
    """Donades dos paraules p1 i p2, ens retorna 1 si la primera es més petita que la segona, i -1 si la primera és més gran que la segona."""

    if p1.repeticions > p2.repeticions:
        return -1
    elif p1.repeticions == p2.repeticions:
        if p1.paraula < p2.paraula:
            return -1
        else:
            return 1
    else:
        return 1




def main() -> None:
    """Programa principal."""

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]

        L = sorted(L) # ordeno la llista per a que em sigui més fàcil trobar l'element/s més freqüent
        L = sorted(repeticions(L), key=cmp_to_key(comparacio))

        for i in range(k):
            print(L[i].paraula)
        print('----------')
    



if __name__ == '__main__':
    main()
from yogi import read, tokens
from dataclasses import dataclass
from functools import cmp_to_key

@dataclass
class Paraula:
    nom : str
    vegades : int

def comparacio(a:Paraula,b:Paraula)->int:
    return b.vegades-a.vegades


def Paraules_frequents(l:list[str], b:int)->None:
    L_ordenada = sorted(l)

    Paraules:list[Paraula] = []

    repeticions = 1
    referencia = L_ordenada[0]

    for i in range(1,len(L_ordenada)):
        if L_ordenada[i] != referencia:
            Paraules.append(Paraula(referencia, repeticions))

            repeticions = 1
            referencia = L_ordenada[i]
    else:
        repeticions +=1

    Paraules.append(Paraula(referencia, repeticions))

    Paraules_ordenades = sorted(Paraules, key=cmp_to_key(comparacio))


    for i in range(b):
        print(Paraules_ordenades[i].nom)
        
def main()->None:
    for a in tokens(int):
        Llista_Paraules: list[str]=[]
        b = read(int)
        for _ in range(a):
            Llista_Paraules.append(read(str))
        Paraules_frequents(Llista_Paraules, b)

    


if __name__ =="__main__":
    main()
from yogi import read, scan
from functools import cmp_to_key


def comparar_paraules(t1:tuple[str, int], t2:tuple[str, int])->int:
    '''funcio que retorna un nombre negatiu si t1 va abans de t2,
    un nombre positiu si t2 va abans que t1 i 0 si son iguals'''
    if t1[1] != t2[1]: return t2[1] - t1[1]
    
    if t1[0]>t2[0]: return 1
    elif t2[0]>t1[0]: return -1
    return 0

def paraules_mes_frequents(n:int, k:int)->None:

    paraules: dict[str, int] = {}

    for _ in range(n):
        x = read(str).lower()
        if x in paraules: paraules[x] += 1
        else: paraules[x] = 1

    L = [(k, v) for k, v in paraules.items()]
    for paraula, vegades in sorted(L, key = cmp_to_key(comparar_paraules) )[:k]:
        print(paraula)


def main():
    n = read(int)

    while n is not None:
        k = read(int)
        paraules_mes_frequents(n, k)
        print('----------')
        n = scan(int)


if __name__ == "__main__":
    main()
from yogi import read

def main():

    entrada = read(int)
    sortida = read(int)
    recompte: dict[str, int] = dict()
    for _ in range(entrada):
        paraula = read(str)
        if paraula in recompte:
            recompte[paraula] += 1
        else:
            recompte[paraula] = 1
    
    for paraula, repeticions in sorted(recompte.items(), key=lambda item: (item[0],item[1])):
        for _ in range(sortida):
            print(paraula)
    print("----------")
from yogi import read

def main():

    entrada = read(int)
    sortida = read(int)
    recompte: dict[str, int] = dict()
    for _ in range(entrada):
        paraula = read(str)
        if paraula in recompte:
            recompte[paraula] += 1
        else:
            recompte[paraula] = 1
    
    for paraula, repeticions in sorted(recompte.items(), key=lambda item: (item[1],item[0])):
        for _ in range(sortida):
            print(paraula)
    print("----------")

if __name__ == '__main__':
    main()
import sys
from collections import Counter

for line in sys.stdin:
    n, k = map(int, line.split())
    words = input().split()
    count = Counter(words)
    top_k = sorted(count.items(), key=lambda x: (-x[1], x[0]))[:k]
    for word, freq in top_k:
        print(word)
    print('-'*10)
from yogi import tokens, read



def main() -> None:
    diec: dict[str, int] = dict()
    for n in tokens(int):
        k = read(int)

        for _ in range(n):
            paraula = read(str).lower()
            if paraula in diec:
                diec[paraula] += 1
            else:
                diec[paraula] = 1

        l = sorted(diec.items(), key = lambda x: (-x[1], x[0]))

        for i in range(k):
            print(l[i][0])
        print("----------")


if __name__ == "__main__":
    main()
from yogi import * 

def novallista(lst: list[str], a: str) -> list[str]:
    """Retorna la llista original sense el valor més frequent"""
    r: list[str] = []
    for x in lst:
        if x != a: 
            r.append(x)
    return r

def mesfreq(lst: list[str]) -> str:
    """Retorna la paraula més frequent d'una llista de paraules"""
    max = 0
    act = 0
    primer = True
    n = len(lst)
    if n > 1:
        for i in range(n):
            if primer:
                primer = False
                if lst[i] == lst[i + 1]:
                    act += 1
                    if act > max:
                        max = i
            else:
                if lst[i] == lst[i-1]:
                    act += 1
                    if act > max:
                        max = i
                else:
                    act = 0
    return lst[max]


def main() -> None:
    for n in tokens(int):
        k = read(int)
        lst: list[str] = []
        for i in range(n):
            lst.append(read(str))
        lst.sort()
        while k > 0:
            k -= 1
            a = mesfreq(lst)
            print(a)
            lst = novallista(lst, a)
        print("-" * 10)
main()
from dataclasses import dataclass
from yogi import *
from typing import TypeAlias
from functools import cmp_to_key

@dataclass
class Info:
    word: str
    n: int

Frequences: TypeAlias = list[Info]

def print_words(f: Frequences, k:int) -> None:
    for i in range(k):
        print(f[i].word)
    print("-" * 10)

def cmp(a:Info, b:Info) -> int: #Esta funcion se define SIEMPRE de esta manera: Dos parametros de entrada y devuelve un entero
                                #Las dos son de tipo info ya que queremos determinar que quiere decir que una info "a" sea mejor que una
                                #info "b". Si a es mejor que b, retorna un valor negativo. Si b es mejor que a, retorna un valor positivo.
                                #Si ambos valores son "iguales" de buenos/malos, retorna un 0
    """
    Crtierios
    1) mas "n", mayor cantidad
    2) menor lexicografico word
    """
    if a.n != b.n:
        return b.n - a.n
    if a.word != b.word:
        return -1 if a.word < b.word else 1
    return 0

def repetitions(lst: list[str], i: int) -> int:
    """Pre : lst esta ordenado: 0 <= n <= lst
        Post: retorna el numero de repeticiones de  valor lst[i] a partir de i(incluida)
    """
    n = len(lst)
    r = 1 
    j = i + 1
    while j < n and lst[j] == lst[i]:
        r += 1
        j += 1
    return r    

def build_frequences(lst : list[str]) -> Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i = 0
    while i < n:
        r = repetitions(lst, i)
        f.append(Info(lst[i], r))
        i += r
    return f


def main() -> None:
    for n in tokens(int):
        k = read(int) #1 <= k <= n
        f : Frequences = build_frequences([read(str) for _ in range(n)]) 
        f.sort(key = cmp_to_key(cmp)) #Para decir segun que criterio tiene que ordenar utilizamos el cmp_to_key(cmp) 
                                    #donde cmp es la funcion booleana que tenemos que definir y será el criterio a seguir para ordenar.
        print_words(f,k)

main()


from yogi import tokens, read
from dataclasses import dataclass

@dataclass
class Words:
    words: list[str]
    frequency: list[int]

def llegeix(lst: Words) -> None:
    """Llegeix les paraules i, si estan repetides, augmenta el contador de la seva freqüencia."""
    s = len(lst.words)
    paraula = read(str)
    repeated = False
    for i in range(s):
        if lst.words[i] == paraula:
            lst.frequency[i] += 1
            ordena(lst, i)
            repeated = True
    if not repeated:
        lst.words.append(paraula)
        lst.frequency.append(1)

def ordena(lst: Words, i: int) -> None:
    """Ordena les llistes de paraules i freqüència, sabent que estan ordenades de major a menor
    freqüència (i en empats, alfabèticament), i que la única que pot estar a un lloc menor del que li correspon està en la posició i."""
    while i > 0 and lst.frequency[i] > lst.frequency[i-1]:
        lst.frequency[i], lst.frequency[i-1] = lst.frequency[i-1], lst.frequency[i]
        lst.words[i], lst.words[i-1] = lst.words[i-1], lst.words[i]
        i -= 1
    while i > 0 and lst.words[i] < lst.words[i-1]:
        lst.words[i], lst.words[i-1] = lst.words[i-1], lst.words[i]

def escriu_paraules(lst: Words, k: int) -> None:
    """Escriu les k paraules més frequüents. En cas d'empat, escriu la primera en ordre alfabètic."""
    for i in range(k):
        print(lst.words[i])
    print('----------')

def main() -> None:
    for n in tokens(int):
        k = read(int)
        lst = Words (words=[], frequency=[])
        for _ in range(n):
            llegeix(lst)
        escriu_paraules(lst, k)

if __name__ == "__main__":
    main()
                