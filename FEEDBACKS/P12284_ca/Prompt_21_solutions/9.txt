This program efficiently solves the problem of finding the `k` most frequent words from a sequence of `n` words, handling ties by alphabetical order.

### Problem Summary
The task is to read `n` words, count their occurrences, and then output the `k` words that appear most frequently. In case multiple words have the same frequency, they should be ordered lexicographically (alphabetically). Each test case's output must conclude with a line of ten hyphens.

### Solution Approach
The program adopts a straightforward and highly effective approach:
1.  **Frequency Counting:** It uses a Python dictionary (`freq: dict[str, int]`) to store each unique word and its corresponding frequency. It iterates through the `n` input words, updating their counts in the dictionary. This is an efficient way to aggregate counts.
2.  **Sorting and Selection:** Once all words are processed and their frequencies are recorded, the program sorts the dictionary's keys (the words themselves). The sorting is done using Python's `sorted()` function with a custom `lambda` key: `lambda x: (-freq[x], x)`.
    *   `-freq[x]` ensures that words are primarily sorted by their frequency in *descending* order (highest frequency first).
    *   `x` (the word itself) serves as a secondary sorting criterion, ensuring that words with the same frequency are sorted *alphabetically* in ascending order, precisely as required by the problem statement.
3.  **Output:** After sorting, the program iterates through the first `k` elements of the sorted list and prints each word on a new line. Finally, it prints the required "----------" separator.

### Analysis of Strengths and Weaknesses

**Strengths:**

*   **Correctness and Robustness:** The core logic, particularly the `lambda` function used for sorting, perfectly implements the problem's dual sorting criteria (frequency descending, then alphabetical ascending). This ensures the output is always correct according to specifications.
*   **Efficiency:**
    *   **Frequency Counting:** Using a dictionary provides average O(1) time complexity for word insertion and lookup, leading to an overall O(N) average time complexity for counting all `N` words.
    *   **Sorting:** Sorting the unique words (keys of the dictionary) takes O(M log M) time, where M is the number of unique words (M â‰¤ N). This is typically the dominant factor in the overall time complexity.
    *   Overall, the solution is very efficient for the given constraints, making it an excellent choice for competitive programming.
*   **Pythonic Style:** The program leverages Python's built-in data structures (dictionaries, lists) and higher-order functions (`sorted()` with `lambda`) effectively and idiomatically.
*   **Readability:** The code is clear, concise, and easy to understand due to its logical flow and meaningful structure, despite some non-English function names.

**Weaknesses:**

*   **Function Naming (Minor):** The function names `printea` (print) and `avalua` (evaluate/process) are in Catalan/Spanish. While understandable in context, using standard English names like `print_top_k_words` and `process_test_case` would improve the code's universal readability and maintainability for an international audience.

### Suggestions for Improvement

1.  **Rename Functions:** Consider renaming `printea` to `print_top_k_words` and `avalua` to `process_test_case` for better clarity and universal understanding.
2.  **Add Docstrings:** Include docstrings for each function to clearly describe its purpose, arguments, and what it returns or accomplishes. This enhances code documentation.
3.  **Complete Type Hinting:** While `freq: dict[str, int]` is well-hinted, adding type hints for `n` and `k` in the `avalua` function signature (`def avalua(n: int, k: int, freq: dict[str, int]):`) would provide full type coverage for that function.

In conclusion, this program is a very well-crafted and efficient solution to the problem. Its use of Python's built-in capabilities for frequency counting and custom sorting is highly effective and demonstrates a strong understanding of algorithmic principles. The minor suggestions are primarily for stylistic consistency and documentation.