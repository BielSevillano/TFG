### Feedback: Paraules més freqüents (Python)

#### 1. Resum del problema i l'aproximació a la solució

El problema demana trobar les `k` paraules més freqüents d'una seqüència de `n` paraules. En cas d'empat en la freqüència, les paraules s'han d'ordenar lexicogràficament (alfabèticament) de menor a major. El programa ha de gestionar múltiples casos de prova, imprimint una línia de 10 guions (`----------`) al final de cada cas.

La solució Python proporcionada utilitza un diccionari (`dic`) per comptar les freqüències de cada paraula. Després de llegir totes les paraules per a un cas de prova, ordena els ítems del diccionari en dues fases: primer alfabèticament per la paraula, i després per la freqüència de forma descendent. Finalment, itera pels elements ordenats i imprimeix les primeres `k` paraules.

#### 2. Anàlisi dels punts forts i febles del codi

**Punts forts:**

*   **Ús adequat del diccionari per al recompte de freqüències:** L'ús d'un diccionari (`dic`) per emmagatzemar les paraules i les seves freqüències és una bona elecció. Permet un accés i actualització de la freqüència de les paraules en temps promig O(1).
*   **Gestió de l'entrada:** La utilització de `tokens(int)` i `read(int)/read(str)` de la llibreria `yogi` és correcta per processar múltiples casos de prova en un entorn com Jutge.org.
*   **Comptatge de freqüències:** La lògica per incrementar el comptador de cada paraula és correcta.

**Punts febles i causa probable de l'error d'execució:**

*   **Estat global del diccionari (`dic` no es reinicia):** El problema principal i la causa més probable de l'Execution Error és que el diccionari `dic` s'inicialitza *fora* del bucle `for n in tokens(int):`. Això significa que per a cada nou cas de prova, el diccionari ja conté les paraules i freqüències dels casos de prova anteriors. Això pot portar a:
    *   **Resultats incorrectes:** Les freqüències de les paraules estaran inflades per les aparicions en casos anteriors.
    *   **"Execution Error" (Error de temps o memòria):** Si hi ha molts casos de prova o paraules diferents, el diccionari pot créixer indefinidament, consumint una quantitat excessiva de memòria (Memory Limit Exceeded) o fent que les operacions de processament (ordenació) siguin massa lentes (Time Limit Exceeded), que sovint es reporten com "Execution Error" en plataformes de jutges automàtics.
*   **Eficiència de l'ordenació:**
    *   La solució realitza dues ordenacions consecutives, creant un nou diccionari en cada pas. Tot i que Python's `sort()` és estable i això podria preservar l'ordre lexicogràfic per als empats de freqüència, és menys eficient i menys idiomàtic que una única ordenació multi-criteri.
    *   Convertir una llista ordenada a un `dict` i després tornar a ordenar els seus ítems introdueix passos innecessaris si només es necessita una llista d'elements ordenats.

#### 3. Suggeriments de millora

1.  **Reinicialitzar el diccionari per a cada cas de prova:**
    Aquesta és la millora més important per solucionar l'Execution Error. El diccionari `dic` s'ha d'inicialitzar a buit dins del bucle principal `for n in tokens(int):` per assegurar que cada cas de prova es processa de forma independent.

    ```python
    from yogi import *

    def main():
        for n in tokens(int):
            dic = {} # Reinicialitzar el diccionari per a cada cas de prova
            k = read(int)
            for i in range(n):
                word = read(str)
                if word not in dic:
                    dic[word] = 0
                dic[word] += 1
            
            # ... (resta del codi de processament i impressió)
            print("----------")

    if __name__ == "__main__":
        main()
    ```

2.  **Ordenació optimitzada amb una sola passada (multi-criteri):**
    Utilitzeu una funció `key` amb una tupla per ordenar segons múltiples criteris. El primer element de la tupla serà la freqüència (negativa per ordenar descendentment) i el segon serà la paraula (per ordenar ascendentment). Això és més eficient i clar. A més, no cal recrear un `dict` a partir de la llista ordenada si només es necessita iterar els ítems.

    ```python
    from yogi import *

    def main():
        for n in tokens(int):
            dic = {} 
            k = read(int)
            for i in range(n):
                word = read(str)
                dic[word] = dic.get(word, 0) + 1 # Manera més concisa de comptar freqüències
            
            # Ordenar amb un sol criteri: freqüència descendent, després paraula ascendent
            sorted_items = sorted(dic.items(), key=lambda item: (-item[1], item[0]))
            
            # Imprimir les k paraules més freqüents
            for i in range(min(k, len(sorted_items))): # Usar min(k, len(...)) per evitar errors si k > paraules_uniques
                print(sorted_items[i][0]) # Imprimir només la paraula
            
            print("----------")

    if __name__ == "__main__":
        main()
    ```

Amb aquestes modificacions, el codi hauria de solucionar l'Execution Error i ser més eficient i robust.