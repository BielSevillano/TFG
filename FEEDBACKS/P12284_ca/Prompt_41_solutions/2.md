This program aims to find the *k* most frequent words in a given sequence of *n* words. If there's a tie in frequency, the words are ordered lexicographically (alphabetically). The program needs to handle multiple test cases.

The solution approaches this by:
1.  Reading the input *n* and *k*.
2.  Reading *n* words.
3.  Counting the frequency of each unique word.
4.  Sorting the words based on frequency (descending) and then lexicographically (ascending) for ties.
5.  Printing the top *k* words.
6.  Printing a separator line "----------".

**Code Analysis:**

**Strengths:**

*   **Correctness of Logic:** The core logic for counting frequencies, sorting, and selecting the top *k* words appears sound. It correctly addresses the tie-breaking condition (lexicographical order for smaller words).
*   **Data Structure Choice:** Using a list of `Info` objects (or similar structures in other valid solutions) to store words and their counts is appropriate for this problem.
*   **Sorting Implementation:** The use of a custom comparison function (`comp`) for sorting the list of `Info` objects based on frequency and then word is crucial and correctly implemented.
*   **Input Handling:** The `while n is not None and k is not None:` loop correctly handles multiple test cases.

**Weaknesses:**

*   **Efficiency of Frequency Counting (Minor Concern):**
    *   The code first sorts the entire list of *n* words (`P.sort()`).
    *   Then, it iterates through this sorted list to count frequencies. This is a common approach.
    *   However, a more direct approach for frequency counting would be to use a dictionary (hash map) where words are keys and their counts are values. This would typically have an average time complexity of O(n) for counting, whereas sorting is O(n log n). While for the given constraints, the current approach might be acceptable, a dictionary-based solution is often preferred for frequency counting problems.
*   **No Early Exit for `yogi.read(int)`:** The `yogi.read(int)` function is called at the beginning of the loop and again at the end. If the first `yogi.read(int)` returns `None` (indicating end of input), the loop terminates. If `n` is read successfully but `k` is `None`, the loop also terminates. This is standard for `yogi` input processing.

**Suggestions for Improvement:**

1.  **Use a Dictionary for Frequency Counting:** Instead of sorting the entire list first and then iterating to count, consider using a dictionary (like Python's `dict` or `collections.Counter`). This would typically be more efficient for counting frequencies.

    *   **Example (Conceptual Python):**
        ```python
        from collections import Counter
        # ... inside the loop ...
        words = [yogi.read(str) for _ in range(n)]
        word_counts = Counter(words) # This counts frequencies efficiently

        # Convert to a list of objects for sorting
        V = []
        for word, count in word_counts.items():
            V.append(Info(word, count))

        # Then proceed with sorting V
        # ...
        ```

2.  **Clarity of `yogi` Functions:** While `yogi.read(int)` and `yogi.read(str)` are typical for this platform, ensuring that the logic correctly handles the potential `None` return values for graceful termination is important. The current structure seems to manage this correctly.

**Overall:**

The provided solution is functional and correctly implements the problem's requirements. The main area for potential improvement lies in the efficiency of the frequency counting step, which could be optimized by using a dictionary-based approach. The current solution's "Wrong Answer" might stem from subtle issues in input reading, output formatting, or edge cases not immediately apparent from the code snippet alone, rather than a fundamental flaw in the sorting and selection logic itself.

**Key takeaways from other solutions:**

Many other provided solutions use a dictionary (`dict` in Python) to store word frequencies directly, which is indeed a more idiomatic and often more efficient approach for this type of problem. They then convert this dictionary into a list of tuples or objects for sorting. The sorting logic (descending frequency, then ascending lexicographical order) is consistently implemented across successful solutions.