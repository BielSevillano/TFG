This program solves the "Most Frequent Words" problem, where the goal is to read a sequence of words and output the `k` most frequent ones. In case of ties in frequency, the words should be sorted alphabetically. The input consists of multiple test cases, each starting with `n` (the number of words) and `k` (the number of most frequent words to output), followed by `n` words.

The solution uses a dictionary (`d`) to store the frequency of each word. It iterates through the input words, updating their counts in the dictionary. After counting, it converts the dictionary items into a list of (word, frequency) tuples. This list is then sorted using a custom key: first by frequency in descending order (to get the most frequent first) and then by word alphabetically in ascending order (to handle ties). Finally, it prints the first `k` words from the sorted list.

**Strengths:**

*   **Correctness:** The program correctly implements the logic to count word frequencies and sort them according to the problem's criteria (frequency descending, then word ascending).
*   **Readability:** The code is generally easy to understand. Variable names are reasonably descriptive.
*   **Efficiency:** Using a dictionary for counting frequencies is efficient (average O(n) for counting). The sorting step dominates the complexity, which is O(N log N) where N is the number of unique words. This is a good approach for this problem.
*   **Use of `yogi` library:** It effectively uses `yogi` for input reading.
*   **Clear Output Formatting:** The program correctly prints the `k` most frequent words and the separator line "----------" after each test case.

**Weaknesses:**

*   **No Error Handling for `yogi.tokens`:** While the problem statement implies that `n` will be an integer, the `for n in tokens(int):` loop might behave unexpectedly if `tokens` encounters non-integer input where an integer is expected. However, for competitive programming contexts where input format is usually guaranteed, this is often acceptable.
*   **Redundant `p=d[word]` and `d[word]=p+1`:** The lines `p=d[word]` and `d[word]=p+1` are slightly more verbose than necessary. A more concise way to update the count would be `d[word] = d.get(word, 0) + 1`.
*   **Potential for Large Memory Usage (unlikely for typical constraints):** If the number of unique words were extremely large, storing all of them in the dictionary and then sorting could consume significant memory. However, given typical competitive programming constraints, this is unlikely to be an issue.

**Suggestions for Improvement:**

1.  **More Concise Frequency Update:** Replace the current frequency update logic with the more Pythonic `d[word] = d.get(word, 0) + 1`. This simplifies the code and makes it more readable.

    ```python
    # Original:
    # if word in d:
    #     p=d[word]
    #     d[word]=p+1
    # else:
    #     d[word]=1

    # Improved:
    d[word] = d.get(word, 0) + 1
    ```

2.  **Lambda Function for Sorting:** The current sorting using `key=lambda x: (-x[1], x[0])` is already very good and idiomatic Python. No significant improvement is needed here.

The provided solution is clean, efficient, and correctly addresses the problem. The suggested improvement is minor and primarily for stylistic conciseness. The program is well-written and would likely pass all test cases.