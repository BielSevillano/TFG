## Feedback for the "Paraules més freqüents" Program

This program successfully solves the problem of finding the `k` most frequent words in a sequence of `n` words, handling ties by alphabetical order. The overall approach of counting word frequencies and then sorting based on frequency and alphabetical order is sound and common for this type of problem.

### Problem Summary

The problem requires reading an input consisting of multiple test cases. Each test case begins with two integers, `n` and `k`, followed by `n` words (all in lowercase). The program needs to identify the `k` most frequent words from the `n` words provided. In case of ties in frequency, the words that come earlier in lexicographical (alphabetical) order should be prioritized. For each test case, the `k` most frequent words should be printed, one per line, followed by a line of 10 hyphens.

### Solution Approach

The provided solution uses a dictionary (`dict[str: int]`) to store the frequency of each word. It iterates through the input words, incrementing the count for each word in the dictionary. After counting all words, it converts the dictionary items into a list of (word, frequency) tuples. This list is then sorted twice: first by word lexicographically, and then by frequency in descending order. Finally, it iterates through the first `k` elements of the sorted list and prints the words.

### Code Analysis

**Strengths:**

*   **Correctness:** The program correctly implements the logic to find the most frequent words and handle ties as per the problem description.
*   **Readability:** The code is generally well-structured and uses meaningful variable names, making it relatively easy to understand.
*   **Efficiency of Frequency Counting:** Using a dictionary for counting word frequencies is an efficient approach (average O(n) for `n` words).
*   **Handling Multiple Test Cases:** The `for n in yg.tokens(int):` loop correctly processes multiple test cases until the input is exhausted.
*   **Correct Sorting Logic:** The double sorting (`D_ = sorted(D.items(), key = lambda x: x[0])` followed by `D_.sort(key = lambda x: -x[1])`) is a valid way to achieve the desired sorting order (lexicographical first, then frequency descending). The use of a `lambda` function for sorting is appropriate.
*   **Output Formatting:** The program correctly prints the `k` words and the separator line of 10 hyphens.

**Weaknesses:**

*   **Redundant Sorting:** The current sorting strategy involves two separate sorting operations. While it achieves the correct result, it might be slightly less efficient than a single sort with a compound key. The first sort by `x[0]` (lexicographical order) is done, and then a second sort by `-x[1]` (descending frequency) is applied. This second sort overwrites the order established by the first sort for elements with different frequencies. However, for elements with the *same* frequency, the order established by the first sort (lexicographical) is preserved because Python's sort is stable. Thus, it works, but it's not the most direct way.

### Suggestions for Improvement

1.  **Single Compound Sort:** The sorting can be made more direct and potentially slightly more efficient by using a single `sorted()` call with a `lambda` function that specifies both sorting criteria. The problem states: "en cas d’empat, les més petites en ordre alfabètic". This means we want to sort primarily by frequency in descending order, and secondarily by the word itself in ascending lexicographical order.

    The current code sorts by `x[0]` (word, ascending) and then by `-x[1]` (frequency, descending). Because Python's `sort` is stable, if two items have the same frequency, their relative order from the first sort (lexicographical) is maintained. However, a more explicit way to achieve this is:

    ```python
    # Original sorting logic
    D_ = sorted(D.items(), key = lambda x: x[0])
    D_.sort(key = lambda x: -x[1])

    # Improved sorting logic
    D_sorted = sorted(D.items(), key=lambda item: (-item[1], item[0]))
    ```

    In the improved version:
    *   `-item[1]` ensures sorting by frequency in descending order.
    *   `item[0]` ensures that if frequencies are equal, words are sorted in ascending lexicographical order.

2.  **Type Hinting for Dictionary:** While `dict[str:int]` is a valid type hint, it's good practice to use the standard `Dict` from `typing` for clarity, especially in larger projects, though `dict[str, int]` is now the preferred modern syntax.

    ```python
    from typing import Dict
    # ...
    D: Dict[str, int] = dict()
    ```
    Or even more modern:
    ```python
    D: dict[str, int] = dict() # This is already used and is good.
    ```

3.  **Variable Naming (Minor):** The variable `D_` is a bit terse. `word_frequencies` or `sorted_frequencies` might be more descriptive. However, given the context of a short competitive programming problem, `D` and `D_` are acceptable.

### Final Review

The provided solution is correct and performs well. The core logic is sound. The suggestion for a single compound sort is a minor optimization for conciseness and potentially a slight performance gain. The use of `yogi` library is appropriate for competitive programming environments.

The code is a good example of a straightforward and effective solution to the given problem.