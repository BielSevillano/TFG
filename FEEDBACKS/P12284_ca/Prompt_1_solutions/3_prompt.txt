
                Write a feedback text for the following program that solves the problem described below.
                
                Paraules més freqüents

Feu un programa que llegeixi una seqüència de n paraules, i n’escrigui
les k més freqüents (en cas d’empat, les més petites en ordre
alfabètic).

Entrada

L’entrada consisteix en diversos casos. Cada cas comença amb n i k,
seguides de n paraules només amb lletres minúscules. Podeu suposar que k
està entre 1 i el nombre de paraules diferents.

Sortida

Per a cada cas, escriviu les k paraules més freqüents en ordre. Primer
cal escriure les paraules més freqüents, i en cas d’empat les paraules
més petites en ordre lexicogràfic. Escriviu una línia amb 10 guions al
final de cada cas.

Autor

Salvador Roura

© Jutge.org, 2006–2025.
                

                This is the program:

                from yogi import read,scan
from dataclasses import dataclass
from functools import cmp_to_key

@dataclass
class Paraula:
    nom:str
    repeticions:int


def classifica(L:list[str],n:int) -> list[Paraula]:
    R:list[Paraula]=list()
    L.sort(reverse = True)
    k = 0 
    p0 =  Paraula(L[0],1)
    R.append(p0)
    for i in range(1,n):
        if L[i-1] == L[i]:
            R[k].repeticions += 1
        else:
            pi = Paraula(L[i],1)
            k+=1
            R.append(pi)
 
    return R
def nombre_repeticions(p : Paraula) -> int:
    return p.repeticions    
        
def escriu(R:list[Paraula], k) -> None:
    R.sort(key = nombre_repeticions)
    for i in range(k):
        print(R[-i-1].nom)
    print(10*'-')

def main() -> None:
    n:int = read(int)
    while n is not None:
        k:int = read(int)
        L:list[str] = [read(str) for _ in range(n)]
        R : list[Paraula] = classifica(L,n)
        escriu(R,k)
        n = scan(int)



if __name__ == '__main__':
    main()

                The result of the program is: Accepted

                The feedback should include:
                - A brief summary of the problem and the solution approach.
                - An analysis of the code's strengths and weaknesses.
                - Suggestions for improvement, if any.

                You can rely on the following other possible solutions to the same problem for reference:
                #include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct Paraula {
	string s;
	int f;
};


bool ordena (const Paraula& a, const Paraula& b) {
	if (a.f > b.f) return true;
	if (b.f > a.f) return false;
	
	return a.s < b.s;
}


int main() {
	
	int n, k;
	while (cin >> n >> k) {
		
		//Llegim totes les paraules
		vector<string> paraules(n);
		for (int i = 0; i < n; i++) {
			cin >> paraules[i];
		}
		
		//Ordenem el vector de paraules
		sort(paraules.begin(), paraules.end());
		
		//Fem un vector buit de paraules i les seves repeticions
		vector<Paraula> frequencies(0);
		
		Paraula aux = {paraules[0], 1};
		for (int i = 1; i < n; i++) {
			
			if (aux.s == paraules[i]) aux.f++;
			else {
				frequencies.push_back(aux);
				aux = {paraules[i], 1};
			}
		}
		frequencies.push_back(aux);
		
		//Ordenem el vector en funcio de les repeticions
		sort(frequencies.begin(), frequencies.end(), ordena);
		
		//Imprimim les k paraules mes repetides
		for (int i = 0; i < k; i++)
			cout << frequencies[i].s << endl;
		cout << "----------" << endl;
	}
	
}

                