## Feedback for the "Paraules més freqüents" Program

**Problem Summary:**

The problem requires a program to read a sequence of words and then output the `k` most frequent words. In case of ties in frequency, the words should be ordered lexicographically (alphabetically). The program needs to handle multiple test cases, with each case starting with the number of words `n` and the number of frequent words to output `k`.

**Solution Approach:**

The provided Python solution uses a dictionary (`ocurrencies`) to store the frequency of each word. It iterates through the input words, converts them to lowercase, and updates their counts in the dictionary. After counting all words, it sorts the dictionary items. The sorting key is a tuple: `-x[1]` (negative frequency, so higher frequencies come first) and `x[0]` (the word itself, for lexicographical sorting in case of ties). Finally, it prints the first `k` words from the sorted list.

**Code Analysis:**

**Strengths:**

*   **Correctness:** The program correctly implements the logic to count word frequencies and sort them according to the problem's criteria. It successfully handles ties with lexicographical ordering.
*   **Readability:** The code is generally well-written and easy to understand. Variable names like `ocurrencies`, `paraula`, and `dic_ordenat` are descriptive.
*   **Efficiency (for Python):** Using a dictionary for frequency counting is efficient, with an average time complexity of O(n) for counting. The sorting step takes O(m log m), where m is the number of unique words.
*   **Input Handling:** The use of `yogi.scan` and `yogi.read` is appropriate for competitive programming environments where these functions are provided for efficient input reading.
*   **Case Insensitivity:** The `.lower()` call ensures that word casing is ignored, as required by the problem.
*   **Output Format:** The program correctly prints the required `k` words and the separator line of 10 hyphens.

**Weaknesses:**

*   **No Explicit Error Handling (Minor):** While the problem statement implies valid inputs, in a more robust application, one might consider what happens if `n` or `k` are not valid integers, or if `k` is greater than the number of unique words (though the problem statement guarantees `k` is within bounds).
*   **Potential for Memory Usage (for very large inputs):** For extremely large inputs with a vast number of unique words, the `ocurrencies` dictionary could consume significant memory. However, for typical competitive programming constraints, this is usually not an issue.

**Suggestions for Improvement:**

1.  **More Explicit Sorting Key Explanation (Docstring/Comment):** While the `lambda` function is concise, adding a comment explaining *why* `-x[1]` and `x[0]` are used for sorting would enhance clarity for someone less familiar with Python's sorting mechanisms:
    ```python
    # Sort by frequency (descending) then by word (ascending)
    dic_ordenat = sorted(ocurrencies.items(), key=lambda x: (-x[1], x[0]))
    ```

2.  **Consider `collections.Counter` (For enhanced Pythonicity):** For frequency counting in Python, `collections.Counter` is often a more idiomatic and potentially slightly more optimized solution. It simplifies the counting loop:
    ```python
    from collections import Counter
    # ...
    paraules_input = [read(str) for _ in range(n)] # Read all words first if needed
    ocurrencies = Counter(paraula.lower() for paraula in paraules_input)
    # ... rest of the sorting and printing
    ```
    However, the current approach is perfectly valid and understandable.

3.  **Input Reading within the Loop:** The current approach reads `n` and `k` at the beginning of the `while` loop and then again at the end. This is standard for this type of problem, but it's worth noting that `yogi.scan` for `n` and `k` will return `None` when the input stream ends, which correctly terminates the loop.

**Overall:**

This is a well-implemented and correct solution to the "Paraules més freqüents" problem. It adheres to the problem's requirements and produces the expected output. The use of a dictionary and Python's `sorted` function with a custom key is an effective approach. The code is clean, readable, and demonstrates a good understanding of the problem and Python's data structures. The "Accepted" verdict from the judge is a testament to its correctness.