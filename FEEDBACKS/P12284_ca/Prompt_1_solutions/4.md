This program addresses the "Paraules més freqüents" (Most Frequent Words) problem. The goal is to read a sequence of `n` words and output the `k` most frequent ones. In case of ties in frequency, the words are to be ordered lexicographically (alphabetically).

The solution employs a dictionary (hash map) to store the frequency of each word encountered. It then sorts the words based on their frequencies (descending) and their alphabetical order (ascending for ties) and prints the top `k` words.

### Code Analysis:

**Strengths:**

*   **Clear and Concise:** The code is well-structured with distinct functions for evaluation (`avalua`) and printing (`printea`). This improves readability and maintainability.
*   **Efficient Frequency Counting:** Using a dictionary (`freq: dict[str, int]`) is an efficient way to count word frequencies, offering an average time complexity of O(1) for insertions and lookups.
*   **Correct Sorting Logic:** The `lambda` function used in `sorted()` correctly implements the sorting criteria: first by frequency in descending order (`-freq[x]`) and then by the word itself in ascending lexicographical order (`x`).
*   **Handles Multiple Test Cases:** The `main` function correctly iterates through multiple test cases as indicated by the problem statement.
*   **Proper Output Formatting:** The program correctly prints the `k` most frequent words and appends the required 10 hyphens after each case.
*   **Uses `yogilib` effectively:** The use of `yogilib` for reading input (`read`, `tokens`) is appropriate for competitive programming contexts where it simplifies input handling.

**Weaknesses:**

*   **Potential for Redundant Iteration (Minor):** The `printea` function iterates through all keys of the `freq` dictionary. While the `if k > 0` and `break` ensure it stops after printing `k` words, the sorting of all keys might be slightly less efficient if `n` is very large and `k` is very small. However, given the typical constraints of such problems, this is unlikely to be a significant performance bottleneck.
*   **No Explicit Error Handling:** While the problem statement implies valid input, in a real-world scenario, you might consider handling potential issues like `k` being larger than the number of unique words, although the problem statement guarantees `k` is between 1 and the number of different words.

### Suggestions for Improvement:

1.  **Optimized Printing for Large `n` and Small `k`:**
    For very large `n` and small `k`, you could consider using a min-heap of size `k` instead of sorting all the frequencies. This would involve iterating through the word frequencies, and if the heap is not full, add the word. If the heap is full, compare the current word's frequency (and alphabetical order for ties) with the smallest element in the heap. If the current word is "better" (higher frequency or lexicographically smaller in a tie), remove the smallest element and insert the current word. This would reduce the time complexity for the printing phase from O(N log N) (where N is the number of unique words) to O(N log k).

    Here's a conceptual outline of how that might look (using Python's `heapq`):

    ```python
    import heapq

    def printea_optimized(freq: dict[str, int], k: int):
        # Heap stores tuples: (-frequency, word) for max-heap behavior on frequency
        # and min-heap behavior on word for lexicographical tie-breaking.
        heap = []
        for word, count in freq.items():
            if len(heap) < k:
                heapq.heappush(heap, (-count, word))
            else:
                # Compare with the smallest element in the heap (which is the largest negative frequency)
                # The 'heapq' module implements a min-heap, so we store negative frequencies.
                # The tuple comparison handles lexicographical order for ties automatically.
                if (-count, word) > heap[0]: # Compare if current word is "better"
                    heapq.heapreplace(heap, (-count, word))

        # Extract elements from heap and sort them (as heap isn't fully sorted)
        # Since we want them printed, we can extract and then sort
        sorted_results = sorted([(-count, word) for count, word in heap], key=lambda x: (-x[0], x[1]))
        for count, word in sorted_results:
            print(word)

    # In avalua function, call printea_optimized(freq, k) instead of printea(freq, k)
    ```
    *Note: The provided `printea_optimized` is a bit more complex to get exactly right with Python's `heapq` for the specific tie-breaking and output order. The original `printea` is simpler and likely sufficient for typical competitive programming constraints.*

2.  **Type Hinting Consistency:**
    The type hint `freq: dict[str, int]` is good. Ensure consistency if you were to expand the project with more functions.

Overall, the provided solution is **excellent** and directly addresses the problem requirements efficiently and correctly. The use of a dictionary and a custom sort key is a standard and effective approach for this type of problem. The "weaknesses" identified are minor and more about exploring theoretical optimizations for extreme scenarios rather than actual flaws in the current implementation.