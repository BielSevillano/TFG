This program aims to find the `k` most frequent words from a sequence of `n` words. If two words have the same frequency, the lexicographically smaller word should be prioritized. The solution approach involves:

1.  Reading the input `n` and `k`.
2.  Reading `n` words.
3.  Counting the frequency of each unique word.
4.  Sorting the unique words based on their frequency (descending) and then alphabetically (ascending) for tie-breaking.
5.  Printing the top `k` words.

**Code Strengths:**

*   **Clear Structure:** The code is well-organized into a `main` function and a helper `Info` class and `comp` function.
*   **Correct Data Structures:** The use of a list `P` to store words and then converting it into a list of `Info` objects (`V`) to store word-frequency pairs is a logical approach.
*   **Sorting Logic:** The `comp` function correctly implements the required sorting criteria: higher frequency first, and then lexicographically smaller words for ties.
*   **Input Handling:** The `while n is not None and k is not None:` loop correctly handles multiple test cases.

**Code Weaknesses and Suggestions for Improvement:**

The primary reason for the "Wrong Answer" is likely a subtle issue in how the `V` list is populated and sorted, or a potential misunderstanding of the problem constraints or the `yogi` library's behavior.

1.  **Sorting `P` and then iterating:**
    *   The code first sorts `P` alphabetically: `P.sort()`. This is a good step to group identical words together.
    *   Then, it iterates through the sorted `P` to count frequencies. The inner `while j < n and P[j] == P[i]: j += 1` loop correctly identifies the end of a block of identical words.
    *   **Potential Issue:** While this approach works for counting, the subsequent sorting of `V` uses `V.sort(key=comp, reverse=True)`. The `comp` function is designed to sort by frequency (descending) then by word (ascending). However, the `reverse=True` flag is applied to the entire sorting process. This means it will try to sort by frequency descending (which is correct) but then by word *descending* as well, which is the opposite of what's needed for tie-breaking.

    *   **Suggestion:** Remove `reverse=True` from `V.sort(key=comp)`. The `comp` function already returns `True` for higher frequency and `False` for lower frequency. When `reverse=True` is used, Python's `sort` will interpret `True` as "less than" and `False` as "greater than", effectively reversing the intended order. The `comp` function should be structured to return `True` when `a` should come *before* `b` in the sorted list.

    Let's re-examine `comp(a, b)`:
    ```python
    def comp(a, b):
      if a.num != b.num:
        return a.num > b.num  # If frequencies differ, return True if a's freq is greater
      return a.par < b.par    # If frequencies are equal, return True if a's word is smaller
    ```
    When `V.sort(key=comp, reverse=True)` is called:
    *   If `a.num > b.num`, `comp` returns `True`. With `reverse=True`, this `True` value is treated as "less than", so `b` would come before `a`. This is *incorrect* for frequency.
    *   If `a.num == b.num` and `a.par < b.par`, `comp` returns `True`. With `reverse=True`, this `True` value is treated as "less than", so `b` would come before `a`. This is *incorrect* for alphabetical tie-breaking.

    **Corrected Sorting:**
    The goal is to sort primarily by frequency in *descending* order, and secondarily by word in *ascending* order.

    The `comp` function, as written, defines the desired ordering if used with `sort()` without `reverse=True`.
    ```python
    # Sort V in descending order of frequency, and ascending alphabetical order for ties
    V.sort(key=lambda info: (-info.num, info.par))
    ```
    This `lambda` function creates a tuple `(-info.num, info.par)`. Sorting tuples in Python compares elements lexicographically.
    *   `-info.num`: By negating the number, a higher original number becomes a smaller negative number. Thus, sorting these in ascending order effectively sorts the original frequencies in descending order.
    *   `info.par`: If the frequencies are equal (meaning `-info.num` values are equal), it then compares `info.par` lexicographically in ascending order.

2.  **Efficiency of `yogi.read()`:**
    The problem statement doesn't specify performance requirements, but repeated calls to `yogi.read()` in a loop for `n` words can be inefficient if `yogi.read()` itself has overhead. However, given the typical context of competitive programming, this is usually acceptable.

3.  **Class Definition:**
    The `Info` class is straightforward and serves its purpose well.

**Example of the Sorting Issue:**

Let's say `V` contains `[Info("apple", 2), Info("banana", 3), Info("cherry", 2)]`.

*   **Desired Order:** `[Info("banana", 3), Info("apple", 2), Info("cherry", 2)]` (banana first, then apple before cherry due to alphabetical order).

*   **With `V.sort(key=comp, reverse=True)`:**
    *   `comp(Info("apple", 2), Info("banana", 3))` -> `a.num` (2) != `b.num` (3). `a.num > b.num` (2 > 3) is `False`. `comp` returns `False`. `reverse=True` makes this `False` equivalent to "greater than", so "banana" comes before "apple". (Correct so far).
    *   `comp(Info("apple", 2), Info("cherry", 2))` -> `a.num` (2) == `b.num` (2). `a.par < b.par` ("apple" < "cherry") is `True`. `comp` returns `True`. `reverse=True` makes this `True` equivalent to "less than", so "apple" comes before "cherry". (Correct so far).
    *   `comp(Info("banana", 3), Info("cherry", 2))` -> `a.num` (3) != `b.num` (2). `a.num > b.num` (3 > 2) is `True`. `comp` returns `True`. `reverse=True` makes this `True` equivalent to "less than", so "cherry" comes before "banana". (This is where it goes wrong for frequency).

The issue is that `reverse=True` reverses the *outcome* of the comparison function. If the comparison function is designed to return `True` when the first element should come *before* the second in the desired sorted order, then `reverse=True` will flip that.

**Revised Code Snippet for Sorting:**

```python
    # ... (previous code)

    # sort V in descending order of frequency, and ascending alphabetical order for ties
    # The lambda function creates a tuple (-frequency, word) which Python sorts lexicographically.
    # This achieves descending frequency sort and ascending alphabetical sort for ties.
    V.sort(key=lambda info: (-info.num, info.par))

    # print the first k elements of V
    for j in range(k):
      print(V[j].par)

    # print separator
    print("----------")

    # update n and k
    n = yogi.read(int)
    k = yogi.read(int)
```

**Final Check:**

The input format states "L’entrada consisteix en diversos casos. Cada cas comença amb n i k, seguides de n paraules". The current input reading loop correctly handles this: it reads `n` and `k`, processes them, and then immediately tries to read `n` and `k` again for the next case. If `yogi.read(int)` returns `None` when there's no more input, the `while n is not None and k is not None:` condition will terminate the loop as intended.