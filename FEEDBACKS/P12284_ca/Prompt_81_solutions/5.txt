This program aims to solve the problem of finding the `k` most frequent words from a given sequence of `n` words. In cases of equal frequency, words should be sorted alphabetically.

### Summary of Problem and Solution Approach

The problem requires processing multiple test cases, each consisting of `n` and `k`, followed by `n` words. The output for each case should be the `k` words meeting the frequency and alphabetical tie-breaking criteria, followed by a "----------" separator.

The solution approach implemented is:
1.  Read all `n` words into a list `P`.
2.  Sort `P` alphabetically. This groups identical words together.
3.  Iterate through the sorted list `P` to count the frequency of each unique word. Store each unique word and its count in a custom `Info` object (`par` for word, `num` for count). These `Info` objects are collected into a list `V`.
4.  Sort the list `V` of `Info` objects based on frequency (descending) and then alphabetically (ascending) for ties.
5.  Print the `par` attribute of the first `k` `Info` objects from the sorted list `V`.

### Analysis of Code's Strengths and Weaknesses

**Strengths:**

*   **Clear Data Structure:** The `Info` class is well-defined to hold the word (`par`) and its frequency (`num`), making the data representation intuitive.
*   **Efficient Word Counting:** Sorting the initial list of words (`P.sort()`) and then using a single pass to count frequencies for unique words is an efficient and standard approach (O(N log N) for sort + O(N) for count).
*   **Modular Design:** The use of `main()` and a custom `Info` class promotes some level of modularity.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly processes multiple input cases.

**Weaknesses and Cause of "Wrong Answer":**

*   **Incorrect Comparator Usage for Sorting:** The primary issue leading to "Wrong Answer" lies in the line `V.sort(key=comp, reverse=True)`.
    *   The `key` argument in Python's `list.sort()` (or `sorted()`) expects a function that takes *one argument* (an element from the list) and returns a value to use for comparison.
    *   Your `comp` function, however, is designed as a *comparison function* (taking `a` and `b` as arguments and returning a boolean indicating relative order) rather than a key-extraction function.
    *   When `key=comp` is used, `list.sort()` will try to call `comp(an_Info_object)`, which is incorrect as `comp` expects two arguments. This will likely cause an error or unexpected behavior, leading to an incorrect sort order, thus a "Wrong Answer".
    *   Furthermore, `comp` returns a boolean (`True` or `False`). While Python's `sort` can technically sort a list of booleans, it's not a stable way to represent the complex sorting criteria (descending frequency, then ascending word).

### Suggestions for Improvement

The core issue can be fixed by correctly implementing the custom sorting logic. Here are a few ways:

1.  **Using a `lambda` function as the `key` (Most Pythonic and Recommended):**
    This is the most straightforward way to implement custom sorting criteria without defining a separate comparison function. You want to sort by frequency in descending order, and then by word alphabetically in ascending order. To achieve descending order with a default ascending sort, you can negate the numerical value.

    ```python
    # main function
    def main():
      # ... (previous code) ...

      # Sort V using a lambda key for (-frequency, word)
      V.sort(key=lambda x: (-x.num, x.par)) # Negate num for descending frequency, par for ascending alphabetical
                                            # No need for reverse=True anymore

      # ... (rest of the code) ...
    ```
    With this change, your `comp` function is no longer needed and can be removed.

2.  **Defining comparison methods in the `Info` class (`__lt__`):**
    If you want `Info` objects to have a natural sorting order, you can define the special `__lt__` (less than) method in the class. Python's `sort()` will then use this method by default.

    ```python
    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

      # Define __lt__ for custom sorting:
      # Return True if self should come before other in the desired order
      def __lt__(self, other):
        if self.num != other.num:
          # Sort by frequency in descending order:
          # A word with higher frequency is "less" (comes first)
          return self.num > other.num
        # If frequencies are equal, sort by word alphabetically (ascending):
        return self.par < other.par

    # main function
    def main():
      # ... (previous code) ...

      # Now V.sort() will use the __lt__ method defined in Info
      V.sort() # No custom key or reverse needed

      # ... (rest of the code) ...
    ```
    This approach also removes the need for your separate `comp` function.

3.  **Using `functools.cmp_to_key` (if a traditional `cmp` function is preferred):**
    If your `comp` function was intentionally designed as an "old-style" comparison function (returning -1, 0, or 1), you could adapt it and use `functools.cmp_to_key`. However, your `comp` returns `True`/`False`, which is not the standard. If `comp` *were* changed to return -1, 0, or 1, you would use it like this:

    ```python
    # from functools import cmp_to_key # add this import at the top

    # Modified comp function (returns -1, 0, or 1)
    def comp_old_style(a, b):
      if a.num != b.num:
        # Sort by frequency descending (higher num means a is "less" for sorting)
        return 1 if a.num < b.num else -1 # if a.num is less than b.num, a comes AFTER b (1)
      # Frequencies are equal, sort alphabetically ascending
      if a.par < b.par:
        return -1 # a comes BEFORE b
      elif a.par > b.par:
        return 1  # a comes AFTER b
      return 0    # equal

    # main function
    def main():
      # ... (previous code) ...

      V.sort(key=cmp_to_key(comp_old_style)) # Use the wrapper

      # ... (rest of the code) ...
    ```
    This is generally less idiomatic Python 3 than using `lambda` keys or `__lt__` methods.

**Additional Minor Improvement (Conceptual):**

*   **Using `collections.Counter` (Python standard library):** For frequency counting, Python's `collections.Counter` provides a very concise way to get word counts. This would simplify the word counting loop significantly, though your current manual loop is perfectly fine for an algorithmic exercise.

By implementing one of the suggested fixes for sorting, particularly the `lambda` key approach, your program should correctly handle the sorting criteria and pass the test cases.