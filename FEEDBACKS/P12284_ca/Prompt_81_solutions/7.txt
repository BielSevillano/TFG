Here's a feedback text for the provided Python program:

---

### Feedback: Paraules mÃ©s freqÃ¼ents

**Problem Summary:**
The problem asks for a program that reads a sequence of `n` words and identifies the `k` most frequent words. In case of a tie in frequency, words should be ordered lexicographically (alphabetically ascending). The output for each test case should be the `k` words, each on a new line, followed by a separator line of 10 hyphens.

**Solution Approach:**
The program attempts to solve this problem by:
1.  Reading all `n` words into a list (`P`).
2.  Sorting this list alphabetically to group identical words together.
3.  Iterating through the sorted list to count the frequency of each unique word. These unique words and their counts are stored in a list of custom `Info` objects (`V`).
4.  Defining a custom comparison function (`comp`) to specify the desired sorting order: highest frequency first, then lexicographically smallest word in case of a tie.
5.  Sorting the `V` list using this custom comparison logic.
6.  Printing the `par` attribute (the word) of the first `k` elements from the sorted `V` list.
7.  Handling multiple test cases.

**Code Analysis:**

**Strengths:**
*   **Clear Data Structure:** The `Info` class (`par` for word, `num` for frequency) is well-defined and clearly represents the necessary data for each unique word.
*   **Logical Frequency Counting:** The nested `while` loops (`i` and `j`) efficiently count the occurrences of each word after the initial alphabetical sort (`P.sort()`). This is a standard and effective algorithm for this task.
*   **Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly handles multiple test cases as specified in the problem.
*   **Output Format:** The program adheres to the required output format for words and separators.

**Weaknesses:**
*   **Incorrect Comparator Usage for Sorting:** The primary issue leading to the "Wrong Answer" is how the `V.sort()` method is used with the custom `comp` function. Python's `list.sort(key=...)` expects `key` to be a function that takes *one argument* (an element from the list) and returns a value to sort by. Your `comp` function takes *two arguments* (`a` and `b`) and performs a comparison. When `V.sort(key=comp, reverse=True)` is called, it tries to pass a single `Info` object to `comp`, leading to a `TypeError` or unexpected behavior depending on the Python version and environment, which ultimately results in incorrect sorting.
    *   In Python 3, `list.sort()` does not accept a `cmp` argument directly. To use a traditional `cmp` style function (like your `comp`), `functools.cmp_to_key` must be used.

**Suggestions for Improvement:**

1.  **Correct the Sorting Logic (Most Critical Fix):**
    The most Pythonic and correct way to sort by multiple criteria (descending frequency, then ascending alphabetical order) using `list.sort()` is to provide a `key` function that returns a tuple. Python sorts tuples element-by-element. To achieve descending order for numbers, you can negate them.

    Modify the `V.sort()` line as follows, and you can remove your `comp` function entirely:

    ```python
    # Remove the comp function definition
    # def comp(a, b): ...

    # In the main function, replace:
    # V.sort(key=comp, reverse=True)
    # with:
    V.sort(key=lambda x: (-x.num, x.par))
    # Explanation:
    # -x.num: Sorts by frequency in descending order (e.g., -5 comes before -3).
    # x.par: Sorts by word (string) in ascending alphabetical order for ties.
    ```

    If you *insist* on using a `cmp`-style function, you would need `functools.cmp_to_key`:

    ```python
    import yogi
    from functools import cmp_to_key # Add this import

    class Info:
      def __init__(self, par, num):
        self.par = par
        self.num = num

    # define comparator function
    # This comp function returns True if 'a' should come BEFORE 'b'
    def comp(a, b):
      if a.num != b.num:
        return a.num > b.num # a.num > b.num means a has higher freq, so a comes first
      return a.par < b.par # a.par < b.par means a is lexicographically smaller, so a comes first

    # In the main function, replace:
    # V.sort(key=comp, reverse=True)
    # with:
    V.sort(key=cmp_to_key(comp)) # No reverse=True needed, as comp already defines the desired order
    ```

2.  **More Pythonic Frequency Counting (Optional for conciseness):**
    While your current frequency counting logic is correct, Python's `collections.Counter` can make this part more concise and often more efficient:

    ```python
    import yogi
    from collections import Counter # Add this import

    # ... (Info class definition - you might not even need it if using tuples)

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        words_list = []
        for _ in range(n):
          words_list.append(yogi.read(str))

        # Use Counter to get frequencies
        word_counts = Counter(words_list)

        # Convert to a list of (word, count) tuples or Info objects
        # For tuples:
        V = list(word_counts.items()) # V will be a list of (word, count) tuples

        # Sort V directly
        V.sort(key=lambda x: (-x[1], x[0])) # x[1] is count, x[0] is word

        for j in range(k):
          print(V[j][0]) # Print the word (first element of the tuple)

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```

Applying the first suggestion (correcting the sort key with a lambda) will resolve the "Wrong Answer" issue.