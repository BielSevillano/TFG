Here's a feedback text for your Python program:

---

### Feedback: Paraules mÃ©s freqÃ¼ents (Most Frequent Words)

**1. Problem Summary and Solution Approach:**

The problem asks us to read a sequence of `n` words and output the `k` most frequent ones. In case of a tie in frequency, words should be ordered alphabetically (lexicographically ascending). The program needs to handle multiple test cases.

Your program implements a common and effective approach to solve this problem:
1.  **Read and Store:** All `n` input words are read into a list `P`.
2.  **Initial Sort:** The list `P` is sorted alphabetically. This is a crucial step that groups identical words together.
3.  **Frequency Counting:** The sorted list `P` is then iterated through to count the occurrences of each unique word. These unique words and their counts are stored in `Info` objects (a custom class `Info` with `par` for the word and `num` for its frequency). These `Info` objects are collected in list `V`.
4.  **Final Sort:** The list `V` (containing unique words and their frequencies) is sorted based on two criteria:
    *   Primary: Frequency (`num`) in descending order.
    *   Secondary (tie-breaker): Word (`par`) in ascending alphabetical order.
5.  **Output:** The `k` words from the top of the sorted list `V` are printed.

**2. Analysis of Code's Strengths and Weaknesses:**

**Strengths:**

*   **Clear Data Structure:** The `Info` class correctly encapsulates the word and its frequency, making the code's intent clear.
*   **Efficient Frequency Counting:** Sorting the initial list `P` and then iterating through it once to count frequencies is an efficient and standard technique (O(N log N) for sort + O(N) for count).
*   **Logical Flow:** The overall structure of reading input, processing, sorting, and printing for multiple test cases is well-organized.
*   **Appropriate Tie-breaking Logic (in `comp` function):** The `comp` function correctly defines the desired sorting order: higher frequency first, and for equal frequencies, alphabetically smaller word first.

**Weaknesses:**

*   **Incorrect Usage of `key` in `sort()`:** The primary reason for the "Wrong Answer" is likely in the line `V.sort(key=comp, reverse=True)`.
    *   In Python's `list.sort()` (or `sorted()`), the `key` parameter expects a function that takes *one argument* (an element from the list `V`) and returns a value to be used for comparison. Your `comp` function, however, is defined to take *two arguments* (`a` and `b`).
    *   Passing a two-argument function to `key` will typically result in a `TypeError` (e.g., `TypeError: comp() missing 1 required positional argument: 'b'`). If the program received "Wrong Answer" instead of "Runtime Error", it suggests the testing environment might handle this `TypeError` in a way that leads to an unsorted or incorrectly sorted list being processed, thus yielding incorrect output.
    *   Even if it somehow didn't error, the `reverse=True` combined with a `key` that returns a boolean based on a custom comparison logic is not how Python's `sort` is intended to be used for complex tie-breaking.

**3. Suggestions for Improvement:**

1.  **Correct the Sorting of `V` (Most Important Fix):**
    The most Pythonic and correct way to sort `V` based on your desired criteria (frequency descending, then word ascending) is to use a `lambda` function with a tuple as the `key`. Python's `sort` compares tuples element by element. To sort `num` in descending order, you can simply negate `x.num`.

    Replace:
    ```python
    # define comparator function
    def comp(a, b):
      if a.num != b.num:
        return a.num > b.num
      return a.par < b.par
    # ...
    V.sort(key=comp, reverse=True)
    ```
    With:
    ```python
    # The 'comp' function is no longer needed with this approach.
    # ...
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    This `lambda` creates a key for each `Info` object `x`: a tuple `(-x.num, x.par)`. When Python sorts these keys:
    *   It first compares the negated frequencies. A larger `x.num` becomes a smaller `-x.num`, so `sort` (which is ascending by default) effectively sorts frequencies in descending order.
    *   If `-x.num` values are equal (meaning `x.num` values were equal), it then compares `x.par` values, sorting them alphabetically (ascending), which is exactly the tie-breaking rule.

2.  **Consider `collections.Counter` for Concise Frequency Counting (Optional):**
    For more concise frequency counting, especially if the initial sort isn't strictly necessary for other parts of the algorithm, Python's `collections.Counter` can be very handy.

    Example using `collections.Counter`:
    ```python
    import yogi
    from collections import Counter

    # ... (no need for Info class if you just use dict/Counter) ...

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        all_words = []
        for _ in range(n):
          all_words.append(yogi.read(str))

        word_counts = Counter(all_words) # Counts frequencies automatically

        # Convert to a list of (word, count) tuples for sorting
        # Or you could directly make Info objects if you still want the class
        items = []
        for word, count in word_counts.items():
            items.append(Info(word, count)) # If using Info class
            # items.append((word, count)) # If just using tuples

        # Sort the items using the tuple-key lambda
        items.sort(key=lambda x: (-x.num, x.par)) # If using Info objects
        # items.sort(key=lambda x: (-x[1], x[0])) # If using (word, count) tuples

        for j in range(k):
          print(items[j].par) # If using Info objects
          # print(items[j][0]) # If using (word, count) tuples

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```
    While your current approach of sorting `P` then scanning is also efficient, `Counter` can sometimes lead to more readable code for this specific task. However, your current two-pass sort-then-count method is perfectly valid and often has good performance characteristics. The main issue is just the final sort.