### Feedback for "Paraules més freqüents" Program

**Problem Summary:**
The problem asks to read a sequence of `n` words and identify the `k` most frequent ones. The output should list these `k` words, ordered primarily by their frequency in descending order, and secondarily by their lexicographical order in ascending order in case of a tie in frequency. Each test case's output is separated by a line of ten dashes.

**Solution Approach:**
The provided Python program implements the following strategy:
1.  It reads all `n` words into a list `P`.
2.  It sorts `P` alphabetically. This groups identical words together, making frequency counting easier.
3.  It then iterates through the sorted list `P` to count the occurrences of each unique word. These unique words and their counts are stored in a list `V` of `Info` objects (where `Info` is a custom class holding the word and its count).
4.  A custom comparison function `comp` is defined, which intends to sort primarily by frequency (descending) and secondarily by word (ascending).
5.  Finally, it sorts the list `V` using this `comp` function and prints the first `k` words.

**Code Strengths:**

*   **Clarity and Readability:** The code is well-structured with a clear `Info` class and distinct functions, making it easy to understand the intended logic. Variable names like `par` (for `paraula`/word) and `num` (for `nombre`/count) are descriptive.
*   **Efficient Frequency Counting:** The use of two nested `while` loops (`while i < n: j = i + 1; while j < n and P[j] == P[i]: j += 1`) after initial sorting is an efficient way to count consecutive occurrences of words.
*   **Adherence to Problem Structure:** The program correctly handles multiple test cases by wrapping the logic in a `while n is not None and k is not None:` loop and prints the required separator line.

**Weaknesses and Cause of "Wrong Answer":**

The primary weakness and likely cause of the "Wrong Answer" is an **incorrect usage of the `key` argument in `list.sort()`** in Python 3.

*   In Python 3, the `key` argument for `list.sort()` expects a function that takes *one* argument (an element from the list) and returns a value (the "key") to be used for comparison.
*   The `comp` function in your code (`def comp(a, b): ...`) is defined to take *two* arguments, `a` and `b`, and returns a boolean (`True` or `False`).
*   When `V.sort(key=comp, reverse=True)` is called, Python will attempt to call `comp` with a single `Info` object as its argument, leading to a `TypeError` (e.g., `comp() missing 1 required positional argument`).
*   If, for some reason (e.g., a specific runtime environment or an older Python version with non-standard behavior for `key` or `cmp`), this `TypeError` did not occur, the boolean return values (`True` or `False`) from `comp` are not appropriate for standard comparison functions (which usually return -1, 0, or 1) nor for key extraction. This would result in an incorrect sorting order, leading to the "Wrong Answer" verdict. The comparison logic itself (frequency descending, then word ascending) is correctly conceived, but its implementation within Python's `sort` mechanism is flawed.

**Suggestions for Improvement:**

1.  **Correct the Sorting Logic (Essential Fix):**
    The most straightforward way to implement multi-criteria sorting in Python 3 is to use a `lambda` function with the `key` argument that returns a tuple. Python's default tuple comparison will handle the criteria in order.

    Replace your `comp` function and the line `V.sort(key=comp, reverse=True)` with:

    ```python
    # Remove the custom 'comp' function definition entirely.

    # In your main function, replace the problematic sort line:
    # V.sort(key=comp, reverse=True)
    # with:
    V.sort(key=lambda x: (-x.num, x.par))
    ```
    Explanation of `lambda x: (-x.num, x.par)`:
    *   `x.num` is negated (`-x.num`) to achieve descending order for frequency.
    *   `x.par` is used directly, which will sort alphabetically in ascending order (default string comparison).
    *   Python compares tuples element by element: first by `-x.num`, and if those are equal, then by `x.par`. This perfectly matches the problem's sorting requirements.

2.  **Use `collections.Counter` for more Pythonic Frequency Counting (Optional, but Recommended):**
    For counting object hashable object occurrences, Python's `collections.Counter` is highly optimized and much more concise. This eliminates the need for manual iteration and the `Info` class.

    ```python
    import yogi
    from collections import Counter
    # No need for Info class or custom comp function with this approach

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        words_list = []
        for _ in range(n):
          words_list.append(yogi.read(str))

        word_counts = Counter(words_list) # Counts frequencies of all words

        # Prepare items for sorting as (negative_count, word) tuples
        sortable_items = []
        for word, count in word_counts.items():
            sortable_items.append((-count, word))
        
        sortable_items.sort() # Sorts by (-count) then by word

        # Print the k most frequent words
        for i in range(k):
          print(sortable_items[i][1]) # Access the word part of the tuple

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```