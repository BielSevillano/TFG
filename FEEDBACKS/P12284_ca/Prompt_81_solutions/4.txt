Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**1. Problem Summary and Solution Approach**

The problem asks to read a sequence of `n` words and identify the `k` most frequent ones. In case of a tie in frequency, words should be ordered alphabetically (smallest first). The output should display these `k` words, followed by a separator line of ten hyphens.

The program implements a common and generally efficient approach:
1.  It reads all `n` words into a list `P`.
2.  It sorts `P` alphabetically. This step is crucial as it groups identical words together.
3.  It then iterates through the sorted list `P` to count the consecutive occurrences of each unique word. These word-frequency pairs are stored as `Info` objects (containing `par` for the word and `num` for its frequency) in a list `V`.
4.  Finally, it attempts to sort the list `V` based on the problem's criteria: primarily by frequency in descending order, and secondarily by word alphabetically in ascending order.
5.  The first `k` words from the sorted `V` are then printed.
6.  The entire process is repeated for multiple test cases.

**2. Code Strengths and Weaknesses**

**Strengths:**

*   **Clear Data Structure:** The `Info` class effectively encapsulates the word and its frequency, making the code readable and organized.
*   **Efficient Frequency Counting:** The strategy of sorting all input words first (`P.sort()`) and then iterating once to count frequencies is efficient. This reduces the overall time complexity for counting from potentially O(N^2) (multiple linear scans) to O(N log N) (for the initial sort) + O(N) (for counting unique words).
*   **Correct Comparison Logic:** The `comp` function accurately defines the desired sorting order: higher frequency first, and then alphabetically smaller word first for ties.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly processes multiple input sets.

**Weaknesses (Cause of "Wrong Answer"):**

*   **Incorrect `list.sort` Usage:** The primary issue lies in how the `V` list is sorted: `V.sort(key=comp, reverse=True)`.
    *   Python's `list.sort()` with the `key` argument expects a function that takes *one* argument (an element from the list) and returns a value to be used for comparison.
    *   However, your `comp` function is a traditional comparison function that takes *two* arguments (`a` and `b`) and returns `True` or `False` to indicate their relative order.
    *   Passing `comp` directly to `key` will result in a `TypeError` because `list.sort` will try to call `comp(item)` with only one argument. This will prevent the list from being sorted correctly, leading to a "Wrong Answer." The `reverse=True` further complicates things, as `comp` is already structured to produce the desired order if used as a direct comparison.

**3. Suggestions for Improvement**

The core fix needed is to correctly apply the custom sorting logic. Here are the recommended ways to address the sorting issue:

**Option 1 (Recommended Pythonic Approach): Implement Comparison Magic Methods in `Info` Class**

The most Pythonic way to enable custom sorting is to define the "less than" (`__lt__`) magic method within your `Info` class. This allows Python's built-in `sort()` to correctly compare `Info` objects.

```python
import yogi

# define struct Info
class Info:
  def __init__(self, par, num):
    self.par = par
    self.num = num

  # Define the "less than" comparison for Info objects
  def __lt__(self, other):
    # Sort primarily by frequency in descending order:
    # If self has a higher frequency, it should come *before* other,
    # so it is considered "less than" other in the sorting context.
    if self.num != other.num:
      return self.num > other.num
    # If frequencies are equal, sort secondarily by word alphabetically ascending:
    # If self's word is alphabetically smaller, it should come *before* other.
    return self.par < other.par

# main function
def main():
  n = yogi.read(int)
  k = yogi.read(int)
  while n is not None and k is not None:
    P = []

    for i in range(n):
      P.append(yogi.read(str))

    P.sort() # Sort alphabetically

    V = []
    i = 0
    while i < n:
      j = i + 1
      while j < n and P[j] == P[i]:
        j += 1
      a = Info(P[i], j - i)
      V.append(a)
      i = j

    # Sort V using the __lt__ method defined in Info
    V.sort() # No 'key' or 'reverse' needed here!

    for j in range(k):
      print(V[j].par)

    print("----------")

    n = yogi.read(int)
    k = yogi.read(int)

if __name__ == "__main__":
  main()
```

**Option 2 (Using `functools.cmp_to_key` for Python 3 or `cmp` argument for Python 2)**

If you are strictly using Python 3 and wish to keep your `comp` function structure, you would use `functools.cmp_to_key`. If your `yogi` environment is Python 2, you could use the `cmp` argument directly.

*   **For Python 3 (requires `import functools`):**
    ```python
    import functools
    # ... (Info class remains the same) ...

    # Your original comp function, but it needs to return -1, 0, or 1 for cmp_to_key
    # to be truly robust. Let's adapt it:
    def comp_for_key(a, b):
        if a.num != b.num:
            return -1 if a.num > b.num else 1 # Higher frequency comes first (-1)
        if a.par != b.par:
            return -1 if a.par < b.par else 1 # Smaller alphabetical comes first (-1)
        return 0 # Equal

    # ... (inside main function) ...
    # V.sort(key=functools.cmp_to_key(comp_for_key))
    # Note: No 'reverse=True' is needed, as comp_for_key already defines the desired order.
    ```
*   **For Python 2 (if `yogi` environment uses it):**
    ```python
    # ... (comp function as originally defined, returning True/False) ...
    # V.sort(cmp=comp)
    # Note: No 'reverse=True' is needed, as 'comp' returns True if a should come before b.
    ```
    However, using `__lt__` in the class is generally preferred as it integrates better with Python's object model and is more idiomatic.

By implementing Option 1, your code will correctly sort the words according to the problem statement, resolving the "Wrong Answer" issue.