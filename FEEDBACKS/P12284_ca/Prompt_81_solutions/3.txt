This Python program aims to solve the "Most Frequent Words" problem by counting word frequencies and then sorting them according to the specified criteria.

### Problem and Solution Approach Summary

The problem requires reading `n` words and identifying the `k` most frequent ones. In case of a tie in frequency, words should be ordered alphabetically (lexicographically ascending). The program first reads all `n` words, sorts them alphabetically to group identical words together, and then iterates through the sorted list to count the frequency of each unique word. These unique words and their counts are stored in a list of `Info` objects. Finally, this list is sorted based on frequency (descending) and then alphabetically (ascending) for tie-breaking, and the first `k` words are printed.

### Code Analysis

**Strengths:**

1.  **Clear Data Structure:** The `Info` class (`par` for word, `num` for count) is well-defined and clearly encapsulates the necessary information for each unique word.
2.  **Correct Frequency Counting Logic:** After the initial alphabetical sort of all input words (`P.sort()`), the `while i < n` loop correctly iterates through `P` to identify unique words and accurately calculate their frequencies. This is an efficient way to count occurrences in a sorted list.
3.  **Handles Multiple Test Cases:** The `while n is not None and k is not None` loop correctly processes multiple input cases as required by the problem statement.

**Weaknesses and Bug:**

1.  **Critical Bug in Comparator Usage for `list.sort()`:** The primary reason for the "Wrong Answer" lies in how the `comp` function is used with `list.sort()`.
    *   In Python, the `key` argument for `list.sort()` (or `sorted()`) expects a function that takes *one* argument (an element from the list) and returns a value to be used for comparison.
    *   Your `comp(a, b)` function, however, is a traditional two-argument comparison function (like those used in C++ `std::sort` or Python 2's `cmp` argument).
    *   When you call `V.sort(key=comp, reverse=True)`, Python tries to call `comp` with a single `Info` object as its argument, which will result in a `TypeError` (missing required argument `b`) or lead to unexpected behavior depending on the Python version and specific environment (though a `TypeError` is most likely for a function expecting two arguments and receiving one).
    *   Even if `comp` were adapted using `functools.cmp_to_key` (which is the way to adapt a two-argument comparator to Python 3's `key`), the `reverse=True` argument might then incorrectly reverse parts of your intended tie-breaking logic. The requirement is: **higher frequency first** (descending), then **smaller alphabetically** (ascending).

### Suggestions for Improvement

1.  **Fix the Sorting Key (Most Important):** The most Pythonic and correct way to implement your desired sorting criteria is to use a `lambda` function that returns a tuple as the `key` for `list.sort()`. Python sorts tuples element by element.
    *   To achieve **descending frequency**, use `-x.num`.
    *   To achieve **ascending alphabetical order**, use `x.par`.
    *   Modify the sorting line from:
        ```python
        V.sort(key=comp, reverse=True)
        ```
        to:
        ```python
        V.sort(key=lambda x: (-x.num, x.par))
        ```
    This single change directly implements the problem's sorting rules: it will sort primarily by `num` in descending order (due to the negative sign), and for elements with equal `num`, it will sort secondarily by `par` in ascending order. No `reverse=True` is needed with this approach.

2.  **Use `collections.Counter` for Frequency Counting (For Conciseness and Efficiency):**
    Python's `collections.Counter` can greatly simplify the frequency counting part of your code.
    ```python
    import yogi
    from collections import Counter # Add this import

    # ... (Info class and comp function can be removed if using lambda key)

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        words_list = []
        for _ in range(n):
          words_list.append(yogi.read(str))

        # Use Counter to get frequencies
        word_counts = Counter(words_list)

        # Convert to list of Info objects (or just list of tuples) for sorting
        V = [Info(word, count) for word, count in word_counts.items()]

        # Sort using the corrected key
        V.sort(key=lambda x: (-x.num, x.par))

        for j in range(k):
          print(V[j].par)

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```
    This version simplifies the frequency counting section, making the code more readable and robust. You might even omit the `Info` class and work with tuples `(word, count)` directly if preferred, sorting `list_of_tuples.sort(key=lambda x: (-x[1], x[0]))`.