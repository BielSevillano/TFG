Here's a feedback text for the provided program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**Problem Summary:**
The problem asks for a program that reads a sequence of `n` words and an integer `k`. It then needs to output the `k` most frequent words. In case of a tie in frequency, words should be sorted in ascending alphabetical order. The output should handle multiple test cases, with a "----------" separator after each case.

**Solution Approach:**
The program implements a common and generally efficient strategy:
1.  Reads all `n` words into a list (`P`).
2.  Sorts this list alphabetically. This groups identical words together.
3.  Iterates through the sorted list to count the frequency of each unique word. These unique words and their counts are stored in a list of `Info` objects (`V`), where `Info` is a custom class holding the word (`par`) and its count (`num`).
4.  Sorts the list `V` of `Info` objects according to the problem's criteria:
    *   Primary sort key: frequency (descending order).
    *   Secondary sort key (tie-breaker): word (ascending alphabetical order).
5.  Prints the `par` attribute of the first `k` `Info` objects from the sorted list.

**Code Analysis:**

**Strengths:**
*   **Clear Data Structure:** The `Info` class effectively encapsulates the word and its frequency, making the code readable and organized.
*   **Efficient Frequency Counting:** The approach of sorting the initial list of words (`P.sort()`) and then iterating through it to count consecutive identical words is an efficient method (often `O(N log N)` due to initial sort, then `O(N)` for counting).
*   **Modular Design:** The logic is well-segmented into reading input, counting frequencies, sorting, and printing results.
*   **Handles Multiple Test Cases:** The `while n is not None and k is not None:` loop correctly processes multiple sets of inputs as required.

**Weaknesses:**
*   **Incorrect Comparator for `list.sort(key=...)`:** The main reason for the "Wrong Answer" is likely the `comp` function's implementation and its usage with `V.sort(key=comp, reverse=True)`.
    *   In Python's `list.sort()`, the `key` argument expects a function that takes *one element* from the list and returns a value (or tuple of values) that `sort()` will then use for comparison. It does *not* expect a traditional comparison function that takes two arguments and returns `True`/`False` or `1`/`-1`/`0`.
    *   When `comp(a, b)` (which returns `True` or `False`) is passed as `key=comp`, Python will try to apply `comp` to each *single element* in `V` (e.g., `comp(Info("word", 5))`), which will raise an error or behave unexpectedly because `comp` expects two arguments.
    *   Even if `comp` were adapted to return a comparable value, `reverse=True` on a key that needs mixed ascending/descending logic for different criteria (frequency descending, word ascending) can be tricky to get right.

**Suggestions for Improvement:**

1.  **Correct the Sorting Key Function:** This is the most critical fix. Instead of a `comp(a, b)` function, define a `key` function that returns a tuple, leveraging Python's natural tuple sorting (lexicographical comparison).

    ```python
    # Define a function to generate the sort key for an Info object
    def get_sort_key(info_obj):
      # Sort primarily by frequency in descending order (use negative frequency)
      # Then, for ties in frequency, sort by word in ascending alphabetical order
      return (-info_obj.num, info_obj.par)

    # In the main function, replace:
    # V.sort(key=comp, reverse=True)
    # with:
    V.sort(key=get_sort_key) # No need for 'reverse=True' because we use -frequency
    ```
    This change ensures that `V` is sorted correctly according to the problem's rules.

2.  **Consider `collections.Counter` for conciseness (Optional):** For a more Pythonic and concise way to count word frequencies, `collections.Counter` can be used. This would replace the initial sort of `P` and the manual `while` loop for frequency counting.

    ```python
    import yogi
    from collections import Counter # Add this import

    # (Info class definition remains the same)

    # (get_sort_key function definition remains the same)

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        all_words = []
        for _ in range(n): # Use _ if the loop variable i is not used
          all_words.append(yogi.read(str))

        # Use Counter to get word frequencies
        word_counts = Counter(all_words)

        # Convert Counter items to a list of Info objects
        V = [Info(word, count) for word, count in word_counts.items()]

        # Sort V using the corrected key function
        V.sort(key=get_sort_key)

        for j in range(k):
          print(V[j].par)

        print("----------")

        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```

Implementing the corrected `get_sort_key` function should resolve the "Wrong Answer" issue.