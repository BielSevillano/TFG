Here's a feedback text for the provided Python program:

---

### Feedback: Paraules més freqüents (Most Frequent Words)

**Problem Summary:**
The problem requires reading `n` words and identifying the `k` most frequent ones. The output should list these `k` words in order of decreasing frequency. In the case of a tie in frequency, words should be sorted in ascending lexicographical (alphabetical) order.

**Solution Approach:**
The program follows a common and generally efficient approach:
1.  It reads all `n` words into a list `P`.
2.  It then sorts this list `P` alphabetically, which groups identical words together.
3.  It iterates through the sorted list `P` to count the occurrences of each unique word, storing these pairs (word, count) in a list `V` of custom `Info` objects.
4.  Finally, it attempts to sort `V` based on the problem's criteria (frequency descending, then word ascending) and prints the top `k` words.

**Code Analysis:**

**Strengths:**
*   **Clear Data Structure:** The `Info` class elegantly combines a word (`par`) and its frequency (`num`), making the data easy to manage.
*   **Effective Frequency Counting:** Sorting the initial list `P` and then iterating through it to count frequencies is a standard and efficient way to process repetitions (O(N log N) for initial sort, then O(N) for counting).
*   **Handles Multiple Test Cases:** The `while` loop correctly processes multiple sets of `n` and `k` inputs, which is important for competitive programming problems.

**Weaknesses and Reason for "Wrong Answer":**

The core issue leading to the "Wrong Answer" verdict lies in the **incorrect implementation of the sorting logic** for the `V` list:

1.  **Misuse of `key` argument in `list.sort()`:** In Python 3, the `list.sort()` method's `key` argument expects a function that takes *one* element from the list and returns a value (or a tuple of values) to be used for comparison. The provided `comp(a, b)` function, however, takes *two* arguments and returns a boolean. This signature is for a traditional comparison function (`cmp`) which is not directly supported by `list.sort()` in Python 3 (it existed in Python 2 or can be adapted using `functools.cmp_to_key` for `cmp`-style functions that return -1, 0, or 1). Passing `comp` directly to `key` will result in a `TypeError` because `sort` will try to call `comp(item)` with a single argument.
    *   *Correction Note:* Even if the `yogi` environment somehow bypasses the `TypeError` or implicitly converts `comp` (e.g., if it were a valid `cmp`-style function), the boolean return values (`True`/`False`) would not correctly implement the desired multi-criteria sort. Python's default sorting behavior for booleans is `False < True`.

**Suggestions for Improvement:**

1.  **Correct the Sorting Key (Critical Fix):**
    The most crucial change is to define a proper `key` function for `V.sort()` that returns a tuple representing the sorting priorities.

    *   **Remove the `comp` function entirely.** It's not needed for Python 3's `sort` with a `key`.
    *   **Modify the `V.sort()` call:**
        ```python
        # Instead of: V.sort(key=comp, reverse=True)
        # Use a lambda function to create the sort key:
        V.sort(key=lambda item: (-item.num, item.par))
        ```
        *   `lambda item: (-item.num, item.par)` creates a key for each `Info` object `item`:
            *   `-item.num`: Sorting by the *negative* of the frequency will naturally place higher frequencies first (descending order).
            *   `item.par`: If the frequencies are tied (meaning `-item.num` values are equal), it will then compare the `par` (word string) alphabetically, which sorts them in ascending lexicographical order as required.

2.  **Simplify Frequency Counting with a Dictionary (Optional, for improved readability/efficiency):**
    While your current counting method is correct, Python's `dict` or `collections.Counter` can provide a more idiomatic and often more efficient way to count frequencies.

    ```python
    import yogi
    # import collections # uncomment if you prefer collections.Counter

    class Info: # Keep Info class if you like, or use tuples (word, count) directly
      def __init__(self, par, num):
        self.par = par
        self.num = num

    def main():
      n = yogi.read(int)
      k = yogi.read(int)
      while n is not None and k is not None:
        # Using a dictionary for word counts
        word_counts = {}
        for _ in range(n): # Use _ if loop variable i is not needed
          word = yogi.read(str)
          word_counts[word] = word_counts.get(word, 0) + 1

        # Convert dictionary items to a list of Info objects for sorting
        V = [Info(word, count) for word, count in word_counts.items()]

        # Apply the corrected sorting key
        V.sort(key=lambda item: (-item.num, item.par))

        for j in range(k):
          print(V[j].par)

        print("----------")
        n = yogi.read(int)
        k = yogi.read(int)

    if __name__ == "__main__":
      main()
    ```

By implementing the sorting key correction, your program should correctly handle the problem requirements.