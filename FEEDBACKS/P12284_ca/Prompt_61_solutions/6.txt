**Program Analysis: "Paraules més freqüents"**

This program is designed to solve the problem of identifying and printing the `k` most frequent words from a given sequence of `n` words. The sorting criteria specify that words should be ordered primarily by their frequency (most frequent first), and in case of a tie in frequency, by alphabetical order (smallest word first).

**Solution Approach Summary:**

The program implements a well-structured and generally efficient approach:
1.  **Input Reading:** It reads the integers `n` and `k`, followed by `n` words, storing them in a list `P`. This process is repeated for multiple test cases.
2.  **Initial Sorting:** The list `P` is sorted alphabetically (`P.sort()`). This crucial step brings identical words together, simplifying the subsequent frequency counting.
3.  **Frequency Calculation:** The program then iterates through the sorted list `P` to count consecutive occurrences of each unique word. Each unique word and its corresponding count are encapsulated in an `Info` object (with `par` for the word and `num` for its frequency). These `Info` objects are collected into a new list `V`.
4.  **Final Sorting and Output:** The list `V` (containing `Info` objects) is then intended to be sorted according to the problem's criteria (descending frequency, then ascending alphabetical order for ties). Finally, the words from the first `k` elements of this sorted list `V` are printed, followed by a separator line.

**Analysis of Code's Strengths and Weaknesses:**

**Strengths:**
*   **Clear Data Structure:** The `Info` class is a good choice for associating each unique `par` (word) with its `num` (frequency), making the code readable and easy to understand.
*   **Efficient Frequency Counting:** By first sorting the input words lexicographically, the program uses an efficient two-pointer technique (`i` and `j` loops) to count frequencies. This approach is optimal, as it processes each word in the sorted list exactly once.
*   **Modular Design:** The separation of concerns (reading, counting, sorting, printing) contributes to a clean and maintainable code structure.
*   **Handles Multiple Test Cases:** The outer `while` loop correctly processes multiple input cases as required by the problem statement.

**Weaknesses (Critical Issue):**
*   **Incorrect Usage of `list.sort()` with `key`:** This is the primary reason for the "Wrong Answer" verdict.
    The `comp` function is defined as a *comparison function* (taking two arguments, `a` and `b`, and returning a boolean value based on their comparison). However, it is passed to the `key` parameter of `V.sort()`: `V.sort(key=comp, reverse=True)`.
    In standard Python 3, the `key` parameter expects a *key-extraction function*—a function that takes *one* argument (an element from the list `V`, e.g., an `Info` object) and returns a value (or a tuple of values) that Python's default comparison logic can use for sorting.
    Passing a two-argument function like `comp` to `key` will typically result in a `TypeError`. Since the program received "Wrong Answer" instead of a `TypeError`, it suggests that the execution environment (`yogi`) might handle this situation in a non-standard way, but critically, it's not achieving the intended sort order. The `reverse=True` argument further complicates the interpretation of the sorting behavior when `key` is misused.

**Suggestions for Improvement:**

The most crucial improvement is to correctly specify the custom sorting logic for `list.sort()` in a Pythonic way.

1.  **Correct the Sorting of List `V`:**
    You should replace the problematic `V.sort(key=comp, reverse=True)` line with a correct key-extraction function, often implemented concisely using a `lambda` function. This function will return a tuple that defines the sorting priority:

    *   **Primary criterion:** Frequency, in *descending* order. To achieve this with Python's default ascending sort, negate the frequency (`-info_obj.num`).
    *   **Secondary criterion:** Word, in *ascending* alphabetical order.

    Here's how to apply this correction:

    ```python
    # Remove the 'comp' function definition as it will no longer be needed.
    # ...

    # In your 'main' function, replace this line:
    # V.sort(key=comp, reverse=True)

    # With this corrected line:
    V.sort(key=lambda info_obj: (-info_obj.num, info_obj.par))

    # Explanation:
    # - `lambda info_obj:` defines a small anonymous function that takes an `Info` object.
    # - `(-info_obj.num, info_obj.par)` returns a tuple. Python sorts tuples
    #   lexicographically: it first compares the first elements, then the second if the
    #   firsts are equal, and so on.
    # - By negating `info_obj.num` (`-info_obj.num`), higher frequencies become smaller
    #   negative numbers, ensuring they come first in an ascending sort (achieving
    #   descending frequency).
    # - `info_obj.par` (the word string) is then used for the tie-breaking, ensuring
    #   words are sorted alphabetically in ascending order.
    # - The `reverse=True` argument is no longer necessary because the key itself
    #   encodes the desired descending/ascending order.
    ```

By implementing this change, your program will correctly sort the `Info` objects according to the problem's specifications, which should resolve the "Wrong Answer" verdict.