## Feedback for the "Paraules més freqüents" Program

This program aims to solve the problem of finding the `k` most frequent words from a sequence of `n` words. In case of ties in frequency, words are sorted alphabetically.

### Solution Approach:

The provided Python code implements the following approach:

1.  **Read Input:** It reads `n` and `k` and then `n` words.
2.  **Store and Count:** It stores all the input words in a list `P`.
3.  **Sort Initial List:** It sorts the list `P` alphabetically. This is a crucial step for later grouping identical words.
4.  **Count Frequencies:** It iterates through the sorted list `P` to identify consecutive identical words, thereby counting their frequencies. It stores these words and their counts in a list of `Info` objects (containing `par` for word and `num` for count).
5.  **Custom Sorting:** It sorts the list of `Info` objects using a custom comparison function `comp`. This function prioritizes higher frequency (`a.num > b.num`) and then uses alphabetical order (`a.par < b.par`) for tie-breaking.
6.  **Output:** It prints the `par` (word) of the first `k` `Info` objects from the sorted list.
7.  **Separator:** It prints "----------" after processing each test case.
8.  **Looping:** It continues processing test cases until `n` is `None`.

### Code Strengths:

*   **Correct Logic for Frequency Counting:** The approach of sorting the input list first and then iterating to count consecutive identical words is a sound method for determining word frequencies.
*   **Custom Sorting Implementation:** The `Info` class and the `comp` function correctly implement the specified sorting criteria (frequency descending, then alphabetically ascending).
*   **Handling Multiple Test Cases:** The `while n is not None and k is not None:` loop effectively handles multiple test cases as required by the problem.
*   **Use of `yogi` library:** The use of `yogi.read` is appropriate for competitive programming environments where this library is likely available for input reading.

### Code Weaknesses and Areas for Improvement:

The primary issue causing the "Wrong Answer" is likely related to how the input is read and how the loop termination is handled.

1.  **Input Reading and Loop Termination:**
    *   The current loop `while n is not None and k is not None:` relies on `yogi.read(int)` returning `None` when input is exhausted. While this might work, it's common in competitive programming to have a clear indicator for the end of input or to rely on an empty line or a specific sentinel value if the problem statement implies it.
    *   The problem statement states: "L’entrada consisteix en diversos casos. Cada cas comença amb n i k...". This implies that `n` and `k` will always be read before the words for that case. The current structure correctly reads `n` and `k` at the beginning of the loop.
    *   **Potential Issue:** If `yogi.read(int)` returns `None` during the reading of `n` or `k` *after* some words have already been read in a previous iteration, the loop might terminate prematurely or in an unexpected state.

2.  **Efficiency for Very Large Inputs (Minor Concern):**
    *   For extremely large `n`, sorting the entire list `P` first might be slightly less efficient than using a dictionary (hash map) to count frequencies directly. However, given the constraints of typical competitive programming problems, the current approach is often acceptable.

3.  **Clarity of `comp` Function:**
    *   The `comp` function returns a boolean. In Python's `sort` method (especially with `reverse=True`), this means `True` is considered "greater" than `False`. The logic `a.num > b.num` correctly makes higher frequencies "greater" for descending order. The `a.par < b.par` for tie-breaking makes lexicographically smaller words "greater" for ascending order when `reverse=True` is applied to the whole sort. This is a bit subtle. A more explicit approach for clarity could involve returning integers (-1, 0, 1) or using `functools.cmp_to_key` with a comparison function that returns -1, 0, or 1.

### Specific Suggestions for Improvement:

1.  **Robust Input Reading and Loop Termination:**
    *   Consider a more standard way to handle end-of-input if `yogi.read` has specific behavior. Often, `try-except` blocks for `EOFError` or checking if the read value is valid are used.
    *   **Example using `try-except`:**
        ```python
        try:
            n = yogi.read(int)
            k = yogi.read(int)
        except EOFError:
            break # Exit the loop if EOF is reached

        while n is not None and k is not None:
            # ... rest of your logic ...

            try:
                n = yogi.read(int)
                k = yogi.read(int)
            except EOFError:
                break
        ```
    *   **Alternative:** If the problem guarantees that `n` and `k` are always valid integers until the end, and `yogi.read` will return `None` gracefully, the current loop condition might be correct. However, "Wrong Answer" suggests an issue here.

2.  **Alternative Frequency Counting (for very large inputs):**
    *   You could use `collections.Counter` from Python's standard library for a more concise and often more efficient frequency counting mechanism.

    ```python
    from collections import Counter
    # ...

    # Inside the while loop:
    words = [yogi.read(str) for _ in range(n)]
    word_counts = Counter(words)

    # Convert to a list of tuples for sorting
    # Each tuple will be (word, frequency)
    sorted_items = sorted(word_counts.items(), key=lambda item: (-item[1], item[0]))

    # Print the top k words
    for i in range(k):
        print(sorted_items[i][0])
    print("----------")
    ```
    This approach bypasses the manual sorting of the input list and custom `Info` class, simplifying the code and potentially improving performance.

3.  **Clarify Sorting Logic (Optional but good practice):**
    *   If you stick with the `Info` class and `comp` function, consider making `comp` return integers for clearer comparison:

    ```python
    def comp(a, b):
        if a.num != b.num:
            return b.num - a.num  # Higher frequency comes first (descending)
        else:
            if a.par < b.par:
                return -1 # Lexicographically smaller comes first (ascending)
            elif a.par > b.par:
                return 1
            else:
                return 0

    # And then use:
    V.sort(key=cmp_to_key(comp))
    ```
    Note that when using `cmp_to_key`, you should remove `reverse=True` from the `.sort()` call, as the `comp` function explicitly defines the desired order.

### Conclusion:

The program's logic for counting frequencies and applying the sorting criteria is fundamentally correct. The "Wrong Answer" likely stems from how the program handles the end of input or if `yogi.read` behaves unexpectedly in certain scenarios. Implementing a more robust input reading mechanism or switching to `collections.Counter` would be good steps to address potential issues and improve code clarity.