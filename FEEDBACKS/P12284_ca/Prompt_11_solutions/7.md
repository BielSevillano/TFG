This feedback is for a Python program designed to find the `k` most frequent words in a given sequence of `n` words.

## Problem Summary

The problem asks to read several test cases. Each test case consists of an integer `n` and an integer `k`, followed by `n` lowercase words. The program should output the `k` most frequent words from the input sequence. In case of a tie in frequency, the words should be ordered lexicographically (alphabetically). After processing each test case, a line of 10 hyphens should be printed.

## Solution Approach

The provided Python program uses a dictionary (`ocurrencies`) to store the frequency of each word. It iterates through the input words, converting them to lowercase and updating their counts in the dictionary. Once all words are processed, it sorts the dictionary items. The sorting key is a tuple `(-x[1], x[0])`. This means it first sorts by frequency in descending order (due to the negative sign) and then by the word itself in ascending lexicographical order for ties. Finally, it prints the first `k` words from the sorted list.

## Code Analysis

### Strengths:

*   **Correctness:** The program correctly implements the logic to count word frequencies and sort them according to the problem's requirements. It handles multiple test cases as specified.
*   **Readability:** The code is generally well-structured and uses meaningful variable names, making it relatively easy to understand.
*   **Efficiency (for this problem):** For typical competitive programming constraints, using a dictionary to count frequencies and then sorting is an efficient approach. The time complexity is dominated by the sorting step, which is O(N log N) where N is the number of *unique* words, or O(M log M) where M is the total number of words if considering the initial reading and insertion into the dictionary.
*   **Use of `yogi` library:** The program effectively utilizes `yogi.scan` and `yogi.read` for input, which is common in competitive programming environments.
*   **Lambda function for sorting:** The use of `lambda` for the sorting key is concise and idiomatic Python for this type of custom sorting.

### Weaknesses:

*   **Redundant Lowercasing:** The line `paraula = paraula.lower()` is called inside the loop for every word. While this doesn't affect correctness, it's slightly inefficient if many words are already lowercase. However, given the problem statement guarantees lowercase input, this line is technically unnecessary.
*   **No explicit end-of-input handling:** The loop `while n is not None and k is not None:` relies on `scan` returning `None` to terminate. This is a standard way to handle multiple test cases in `yogi`, but it's worth noting that the input format is implicitly handled by the input library.
*   **Potential for improvement in edge cases (though not required by problem):** The problem statement guarantees `k` is between 1 and the number of distinct words. If this wasn't the case, error handling or adjustments might be needed if `k` is larger than the number of unique words.

## Suggestions for Improvement

1.  **Remove Redundant `.lower()`:** Since the problem statement guarantees that input words are only in lowercase, the `paraula = paraula.lower()` line inside the loop is redundant. Removing it would slightly improve performance without affecting correctness.

    ```python
    # Before
    paraula = read(str)
    paraula = paraula.lower()
    if paraula not in ocurrencies:
        ocurrencies[paraula] = 1
    else:
        ocurrencies[paraula] += 1

    # After (removing redundant lowercasing)
    paraula = read(str) # Already lowercase as per problem statement
    if paraula not in ocurrencies:
        ocurrencies[paraula] = 1
    else:
        ocurrencies[paraula] += 1
    ```

2.  **More Explicit Type Hinting (Optional but good practice):** While the existing type hint `dict[str, int]` is good, for more complex scenarios, `collections.Counter` could be considered as it's specifically designed for frequency counting and can sometimes offer minor performance benefits or more concise syntax for certain operations. However, for this specific problem, the current dictionary approach is perfectly fine.

    If using `collections.Counter`:
    ```python
    from collections import Counter
    # ...
    ocurrencies = Counter()
    for _ in range(n):
        paraula = read(str)
        ocurrencies[paraula] += 1
    # ...
    dic_ordenat = sorted(ocurrencies.items(), key=lambda x: (-x[1], x[0]))
    ```
    This is a stylistic preference and not a strict requirement for correctness.

## Conclusion

The program is a solid and correct solution to the problem. It efficiently counts word frequencies and sorts them as required. The suggested improvement is minor and relates to removing a redundant operation based on the problem's input constraints. The use of `yogi` and the sorting key are well-implemented.