
                Write a feedback text for the following program that solves the problem described below.
                
                Paraules més freqüents

Feu un programa que llegeixi una seqüència de n paraules, i n’escrigui
les k més freqüents (en cas d’empat, les més petites en ordre
alfabètic).

Entrada

L’entrada consisteix en diversos casos. Cada cas comença amb n i k,
seguides de n paraules només amb lletres minúscules. Podeu suposar que k
està entre 1 i el nombre de paraules diferents.

Sortida

Per a cada cas, escriviu les k paraules més freqüents en ordre. Primer
cal escriure les paraules més freqüents, i en cas d’empat les paraules
més petites en ordre lexicogràfic. Escriviu una línia amb 10 guions al
final de cada cas.

Autor

Salvador Roura

© Jutge.org, 2006–2025.
                

                This is the program:

                from yogi import read, scan

def main() -> None:
    n = scan(int)
    k = scan(int)
    while n is not None and k is not None:
        ocurrencies: dict[str, int] ={}
        for _ in range(n):
            paraula = read(str)
            paraula = paraula.lower()
            if paraula not in ocurrencies:
                ocurrencies[paraula] = 1
            else:
                ocurrencies[paraula] += 1

        dic_ordenat = sorted(ocurrencies.items(), key=lambda x: (-x[1], x[0]))  

        for i in range(k):
            print(dic_ordenat[i][0])
        
        print(10*'-')
        
        n = scan(int)
        k = scan(int)


if __name__ == '__main__':
    main()

                The result of the program is: Accepted

                The feedback should include:
                - A brief summary of the problem and the solution approach.
                - An analysis of the code's strengths and weaknesses.
                - Suggestions for improvement, if any.

                You can rely on the following other possible solutions to the same problem for reference:
                from jutge import read

n = read(int)
k = read(int)

while n is not None:

	freq = {}
	for i in range(n):
		w = read(str)
		if w not in freq:
			freq[w] = 1
		else:
			freq[w] += 1

	out = 0
	while out < k:
		mx = 0
		mxw = []
		for w in freq:
			if freq[w] > mx:
				mx = freq[w]
				mxw = [w]
			elif freq[w] == mx:
				mxw.append(w)
		mxw = sorted(mxw)
		for w in mxw:
			print(w)
			out += 1
			freq[w] = 0
			if out == k:
				break

	print("----------")

	n = read(int)
	k = read(int)

from jutge import read
from operator import itemgetter

def add_word(dic, pal):
    if pal in dic:
        dic[pal] += 1
    else:
	    dic[pal] = 1


def main(n):
	k = read(int)
	dic = {}
	for i in range(n):
		add_word(dic, read(str))
	lista_pal_freq = []
	for pal,freq in dic.items():
		lista_pal_freq.append((pal,freq))
	lista_pal_freq.sort(key = itemgetter(0))
	#print(lista_pal_freq)
	lista_pal_freq.sort(key = itemgetter(1), reverse = True)
	#print(lista_pal_freq)
	for i in range(k):
		print(lista_pal_freq[i][0])
	print(10*'-')
	
		
def main_main():
	n = read(int)
	while n is not None:
		main(n)
		n = read(int)


main_main()		

from yogi import tokens, read
from dataclasses import dataclass

@dataclass
class Words:
    words: list[str]
    frequency: list[int]

def llegeix(lst: Words) -> None:
    """Llegeix les paraules i, si estan repetides, augmenta el contador de la seva freqüencia."""
    s = len(lst.words)
    paraula = read(str)
    repeated = False
    for i in range(s):
        if lst.words[i] == paraula:
            lst.frequency[i] += 1
            ordena(lst, i)
            repeated = True
    if not repeated:
        lst.words.append(paraula)
        lst.frequency.append(1)

def ordena(lst: Words, i: int) -> None:
    """Ordena les llistes de paraules i freqüència, sabent que estan ordenades de major a menor
    freqüència (i en empats, alfabèticament), i que la única que pot estar a un lloc menor del que li correspon està en la posició i."""
    while i > 0 and lst.frequency[i] > lst.frequency[i-1]:
        lst.frequency[i], lst.frequency[i-1] = lst.frequency[i-1], lst.frequency[i]
        lst.words[i], lst.words[i-1] = lst.words[i-1], lst.words[i]
        i -= 1
    while i > 0 and lst.words[i] < lst.words[i-1]:
        lst.words[i], lst.words[i-1] = lst.words[i-1], lst.words[i]

def escriu_paraules(lst: Words, k: int) -> None:
    """Escriu les k paraules més frequüents. En cas d'empat, escriu la primera en ordre alfabètic."""
    for i in range(k):
        print(lst.words[i])
    print('----------')

def main() -> None:
    for n in tokens(int):
        k = read(int)
        lst = Words (words=[], frequency=[])
        for _ in range(n):
            llegeix(lst)
        escriu_paraules(lst, k)

if __name__ == "__main__":
    main()
from yogi import *
from dataclasses import dataclass
from functools import cmp_to_key


@dataclass
class Paraula:
    word: str
    freq: int

P: list[Paraula]

def comparacio(p1: Paraula, p2: Paraula) -> int:
    if p1.freq < p2.freq:
        return p1.freq - p2.freq
    elif p1.freq > p2.freq:
        return p1.freq - p2.freq
    else:
        if p1.word < p2.word:
            return -1
        elif p1.word > p2.word:
            return 1
        else:
            return 0    

def counting(L: list[str]) -> list[Paraula]:
    P: list[Paraula] = []
    m = len(L)
    last = L[0]
    c = 1
    for i in range(1, m):
        if L[i] == last:
            c += 1
        else:
            P.append(Paraula(last, c))
            c = 1
            last = L[i]
    P.append(Paraula(last, c))
    return P

def comparacio(p1: Paraula, p2: Paraula) -> int:
    if p1.freq < p2.freq:
        return 1
    elif p1.freq > p2.freq:
        return -1
    else:
        if p1.word < p2.word:
            return -1
        elif p1.word > p2.word:
            return 1
        else:
            return 0

def escriure(P: list[Paraula], m: int) -> None:
    for i in range(m):
        print(f"{P[i].word}")

def main() -> None:
    for n in tokens(int):
        m = read(int)
        L: list[str] = [read(str) for _ in range(n)]
        L.sort()
        escriure(sorted(counting(L), key=cmp_to_key(comparacio)), m)
        print('----------')

main()

from yogi import read, tokens


def mes_frequent(L: list[str], n: int) -> str:
    """Donada una llista L ordenada de llargada n, retorna l'element més freqüent de la llista."""

    element_mes_frequent = L[0]
    repeticions_maximes = 1
    repeticions = 1

    for i in range(1, n):
        if L[i-1] == L[i]:
            repeticions += 1
        else:
            if repeticions > repeticions_maximes:
                repeticions_maximes = repeticions
                element_mes_frequent = L[i-1]
                repeticions = 1
            elif repeticions == repeticions_maximes:
                if element_mes_frequent > L[i-1]:
                    element_mes_frequent = L[i-1]
                repeticions = 1
            else:
                repeticons = 1

    if repeticions > repeticions_maximes:
        element_mes_frequent = L[n-1]
        repeticions_maximes = repeticions
    elif repeticions_maximes == 1:
        if L[n-2] < element_mes_frequent:
            element_mes_frequent = L[n-2]
        if L[n-1] < element_mes_frequent:
            element_mes_frequent = L[n-1]
    elif repeticions == repeticions_maximes:
            if element_mes_frequent > L[n-1]:
                element_mes_frequent = L[i-1]
    
    return element_mes_frequent


def elimina_paraula(L: list[str], paraula: str, n: int) -> None:
    """Donada una llista L ordenada de llargada n, elimina la paraula de la llista."""

    i = 0
    while i<n and paraula != L[i]:
        i += 1
    while i<n and paraula == L[i]:
        del(L[i])
        n = len(L)



def main() -> None:
    """Programa principal."""

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]

        L = sorted(L) # ordeno la llista per a que em sigui més fàcil trobar l'element/s més freqüent

        for i in range(k):
            if i < k - 1:
                a = mes_frequent(L,n)
                print(a)
                elimina_paraula(L, a, n)
                n = len(L)
            else:
                a = mes_frequent(L,n)
                print(a)
        print('----------')
    



if __name__ == '__main__':
    main()
from yogi import read, tokens
from dataclasses import dataclass
from functools import cmp_to_key


@dataclass
class Paraula:
    repeticions: int
    paraula: str


def repeticions(L: list[str]) -> list[Paraula]:
    """Donada una llista de paraules L ordenada, retorna una llista de Paraula on s'indica el número de repeticions que apareix la paraula en L."""

    n = len(L)
    repeticions = 1
    paraules_i_repeticions: list[Paraula] = list()

    for i in range(n-1):
        if L[i] == L[i+1]:
            repeticions += 1
        else:
            p1 = Paraula (
                repeticions,
                L[i],
            )
            paraules_i_repeticions.append(p1)
            repeticions = 1
    
    if L[n-1] == L[n-2]: #en l'anterior bucle no hem pogut comparar el darrer element de la llista L
        p1 = Paraula(
            repeticions,
            L[n-1]
        )
        paraules_i_repeticions.append(p1)
    else:
        p1 = Paraula(
            repeticions,
            L[n-1]
        )
        paraules_i_repeticions.append(p1)

    return paraules_i_repeticions


def comparacio(p1: Paraula, p2: Paraula) -> int:
    """Donades dos paraules p1 i p2, ens retorna 1 si la primera es més petita que la segona, i -1 si la primera és més gran que la segona."""

    if p1.repeticions > p2.repeticions:
        return -1
    elif p1.repeticions == p2.repeticions:
        if p1.paraula < p2.paraula:
            return -1
        else:
            return 1
    else:
        return 1




def main() -> None:
    """Programa principal."""

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]

        L = sorted(L) # ordeno la llista per a que em sigui més fàcil trobar l'element/s més freqüent
        L = sorted(repeticions(L), key=cmp_to_key(comparacio))

        for i in range(k):
            print(L[i].paraula)
        print('----------')
    



if __name__ == '__main__':
    main()
from yogi import read, tokens

def moda(L:list[str], n: int)->tuple[str , int]:
    """Retorna la paraula mes frequent de L (llista ordenada) i la seva posicio, de longuitud n i que sigui diferent a "-". Si hi ha empat la mes petita."""
    
    i = 0
    mes_frec = "*"
    max_vegades = 0
    posicio_interes = 0
    while i < n:

        veg = comptant_frec(L, i, n) 
        if veg > max_vegades and L[i] != "-":
            max_vegades = veg
            mes_frec = L[i]
            posicio_interes = i
        i += veg

    return (mes_frec, posicio_interes)

def substitur(L:list[str], i: int, n:int)->None:
    """Substitueix tots els elements que siguin igual a L[i] de la llista ordenada L per -. n es la longuitud de la llista."""
    
    vegades_apareix = comptant_frec(L, i, n)
    for i in range(i, i + vegades_apareix , 1):
        L[i] = "-"

def comptant_frec(L:list[str], i:int, n:int)->int:
    """Retorna el num de vegades que apareix l element de la posicio i a la llista ordenada L de longuitud n."""
    suma = 1
    
    while i+1 < n and L[i] == L[i+1]:
        suma += 1
        i += 1

    return suma
            
def paraules_mes_frec(L:list[str], n:int, k:int)->None:
    """Printeja les k paraules mes frequents de L en ordre de frequencia. L te longuitud n."""
    mes_frec = "*"
    for _ in range(k):
        mes_frec = moda(L,n)
        print(mes_frec[0])
        substitur(L, mes_frec[1], n)
    print("----------")


def main():

    for n in tokens(int):
        k = read(int)
        L = [read(str) for _ in range(n)]
        L.sort()
        paraules_mes_frec(L, n, k)
    

if __name__ == """__main__""":
    main()
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct Paraula {
	string s;
	int f;
};


bool ordena (const Paraula& a, const Paraula& b) {
	if (a.f > b.f) return true;
	if (b.f > a.f) return false;
	
	return a.s < b.s;
}


int main() {
	
	int n, k;
	while (cin >> n >> k) {
		
		//Llegim totes les paraules
		vector<string> paraules(n);
		for (int i = 0; i < n; i++) {
			cin >> paraules[i];
		}
		
		//Ordenem el vector de paraules
		sort(paraules.begin(), paraules.end());
		
		//Fem un vector buit de paraules i les seves repeticions
		vector<Paraula> frequencies(0);
		
		Paraula aux = {paraules[0], 1};
		for (int i = 1; i < n; i++) {
			
			if (aux.s == paraules[i]) aux.f++;
			else {
				frequencies.push_back(aux);
				aux = {paraules[i], 1};
			}
		}
		frequencies.push_back(aux);
		
		//Ordenem el vector en funcio de les repeticions
		sort(frequencies.begin(), frequencies.end(), ordena);
		
		//Imprimim les k paraules mes repetides
		for (int i = 0; i < k; i++)
			cout << frequencies[i].s << endl;
		cout << "----------" << endl;
	}
	
}

from dataclasses import dataclass
from yogi import *
from typing import TypeAlias
from functools import cmp_to_key

@dataclass
class Info:
    word: str
    n: int

Frequences: TypeAlias = list[Info]

def print_words(f: Frequences, k:int) -> None:
    for i in range(k):
        print(f[i].word)
    print("-" * 10)

def cmp(a:Info, b:Info) -> int: #Esta funcion se define SIEMPRE de esta manera: Dos parametros de entrada y devuelve un entero
                                #Las dos son de tipo info ya que queremos determinar que quiere decir que una info "a" sea mejor que una
                                #info "b". Si a es mejor que b, retorna un valor negativo. Si b es mejor que a, retorna un valor positivo.
                                #Si ambos valores son "iguales" de buenos/malos, retorna un 0
    """
    Crtierios
    1) mas "n", mayor cantidad
    2) menor lexicografico word
    """
    if a.n != b.n:
        return b.n - a.n
    if a.word != b.word:
        return -1 if a.word < b.word else 1
    return 0

def repetitions(lst: list[str], i: int) -> int:
    """Pre : lst esta ordenado: 0 <= n <= lst
        Post: retorna el numero de repeticiones de  valor lst[i] a partir de i(incluida)
    """
    n = len(lst)
    r = 1 
    j = i + 1
    while j < n and lst[j] == lst[i]:
        r += 1
        j += 1
    return r    

def build_frequences(lst : list[str]) -> Frequences:
    n = len(lst)
    lst.sort()
    f: Frequences = []
    i = 0
    while i < n:
        r = repetitions(lst, i)
        f.append(Info(lst[i], r))
        i += r
    return f


def main() -> None:
    for n in tokens(int):
        k = read(int) #1 <= k <= n
        f : Frequences = build_frequences([read(str) for _ in range(n)]) 
        f.sort(key = cmp_to_key(cmp)) #Para decir segun que criterio tiene que ordenar utilizamos el cmp_to_key(cmp) 
                                    #donde cmp es la funcion booleana que tenemos que definir y será el criterio a seguir para ordenar.
        print_words(f,k)

main()


from yogi import read

def main():

    entrada = read(int)
    sortida = read(int)
    recompte: dict[str, int] = dict()
    for _ in range(entrada):
        paraula = read(str)
        if paraula in recompte:
            recompte[paraula] += 1
        else:
            recompte[paraula] = 1
    
    for paraula, repeticions in sorted(recompte.items(), key=lambda item: (item[1],item[0])):
        for _ in range(sortida):
            print(paraula)
    print("----------")

if __name__ == '__main__':
    main()
import sys
from collections import Counter

for line in sys.stdin:
    n, k = map(int, line.split())
    words = input().split()
    count = Counter(words)
    top_k = sorted(count.items(), key=lambda x: (-x[1], x[0]))[:k]
    for word, freq in top_k:
        print(word)
    print('-'*10)
                