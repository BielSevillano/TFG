
                Write a feedback text for the following program that solves the problem described below.
                
                                Fusió de taules

Feu una funció que fusioni els vectors ordenats @v1@ i @v2@ i en retorni
el resultat, sense eliminar els elements repetits. Per exemple, el
resultat de fusionar una taula amb 2, 3 i 5 amb una taula amb 3, 5, 5 i
7 és una taula amb 2, 3, 3, 5, 5, 5 i 7.

Interfície

+-------:+:------------------------------------------------------------------------------+
| C++    |     vector<double> fusio(const vector<double>& v1, const vector<double>& v2); |
+--------+-------------------------------------------------------------------------------+
| Java   |     public static double[] fusio(double[] v1, double[] v2);                   |
+--------+-------------------------------------------------------------------------------+
| Python |     fusio(v1, v2)  # returns list                                             |
+--------+-------------------------------------------------------------------------------+
| MyPy   |     fusio(v1: list[float], v2: list[float]) -> list[float]                    |
+--------+-------------------------------------------------------------------------------+

Precondició

@v1@ i @v2@ estan ordenats de petit a gran.

Observació

Només cal enviar el procediment demanat; el programa principal serà
ignorat.

Autor

Salvador Roura

© Jutge.org, 2006–2025.


                

                This is the program:

                from yogi import *

def fusio(l1:list[float],l2:list[float]) -> None:

    result: list[float] = []

    i=0
    j=0

    while i!=len(l1) and j!=len(l2):
        if l1[i] <= l2[j]:
            result.append(l1[i])
            i += 1

        else:
            result.append(l2[j])
            j += 1

    result.extend(l1[i:])
    result.extend(l2[j:])

    return result

def main() -> None:

    l1: list[float] = []
    l2: list[float] = []

    n=read(int)

    for i in range(n):
        l1.append(read(float))

    n2= read(int)

    for i in range(n2):
        l2.append(read(float))

    print(fusio(l1,l2))

main()

                The result of the program is: Wrong Answer

                The feedback should include:
                - A brief summary of the problem and the solution approach.
                - An analysis of the code's strengths and weaknesses.
                - Suggestions for improvement, if any.

                You can rely on the following other possible solutions to the same problem for reference:
                def fusio(v1: list[float], v2: list[float]) -> list[float]:
    v1.extend(v2)
    v1.sort()
    return v1


def fusio(v1:list[float], v2:list[float]) -> list[float]:
    fusio:list[float] = v1 + v2
    n = len(fusio)
    i = n
    while i != 0:
        p = 0
        for j in range(1, i):
            if fusio[j] > fusio[p]:
                p = j
        fusio[i - 1], fusio[p] = fusio[p], fusio[i - 1]
        i -= 1
    return fusio

from easyinput import read

def fusio(v1, v2):
    v = v1 + v2
    v.sort()
    return v

#include <iostream>
#include <vector>
using namespace std;

// Retorna la fusió ordenada de dos vectors ordenats.
// precondició: v1 i v2 estàn ordenats.
vector<double> fusio(const vector<double>& v1, const vector<double>& v2)
{
    vector<int> v;
    int i = 0;
    int j = 0;

    while (i < v1.size() and j < v2.size()) {
        if (v1[i] <= v2[j]) {
            v.push_back(v1[i]);
            ++i;
        } else {
            v.push_back(v2[j]);
            ++j;
        }
    }
    while (j < v2.size()) {
        v.push_back(v2[j]);
        ++j;
    }
    while (i < v1.size()) {
        v.push_back(v1[i]);
        ++i;
    }
    return v;
}

def fusio(v1, v2):
	i = 0;
	j = 0;
	n1 = len(v1)
	n2 = len(v2)
	v = []
	while i < n1 and j < n2:
		if v1[i] <= v2[j]:
			v.append(v1[i])
			i = i + 1
		else:
			v.append(v2[j])
			j = j + 1
	while j < n2:
			v.append(v2[j])
			j = j + 1
	while i < n1:
		v.append(v1[i]);
		i = i + 1		
	return v

def main():
	v1 = [2,  3, 5]
	v2 = [3, 5, 5, 7]
	print(fusio(v1, v2))
	
main()

#include <iostream>
#include <vector>
using namespace std;

vector<double> fusio(const vector<double>& v1, const vector<double>& v2) {
	int it1 = 0, it2 = 0;
	vector<double> r;
	while(it1 < v1.size() and it2 < v2.size()) {
		if(v1[it1] < v2[it2]) {
			r.push_back(v1[it1]);
			r.push_back(v2[it2]);
		}
		else {
			r.push_back(v2[it2]);
			r.push_back(v1[it1]);
		}
		it1++; it2++;
	}
	while(it1 < v1.size()) {
		r.push_back(v1[it1]);
		it1++;
	}
	while(it2 < v2.size()) {
		r.push_back(v2[it2]);
		it2++;
	}
	return r;
}

int main() {}
import doctest


def interseccio(v1, v2):
    '''
    Retorna una llista ordenada amb la interseccio
    dels vectors ordenats v1 i v2, sense repetits.
    >>> interseccio([1, 2, 2, 5, 5, 7], [2, 3, 3, 7])
    [2, 7]
    >>> interseccio([2, 3, 3, 7], [1, 2, 2, 5, 5, 7])
    [2, 7]
    >>> interseccio([], [1, 2, 2])
    []
    >>> interseccio([1, 1, 1], [1, 1, 1, 2, 2])
    [1]
    >>> interseccio([1, 1, 1, 2, 2], [1, 1, 1])
    [1]
    >>> interseccio([1, 3, 5], [1, 3, 5])
    [1, 3, 5]
    '''
    l = []

    i=0
    j=0
    while i<len(v1) and j<len(v2):
        if v1[i]<v2[j]:
            i=i+1
        elif v2[j]<v1[i]:
            j=j+1
        else:
            if len(l)==0 or l[-1] !=v1[i]:
                l.append(v1[i])
            i=i+1
            j=j+1
            
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

def merge(v1,v2):
    '''
    >>> merge([2,3,5],[3,3,5,7])
    [2, 3, 3, 3, 5, 5, 7]
    '''
    res=[]
    for i in range(len(v1)):
        res.append(v1[i])
    for j in range(len(v2)):
        res.append(v2[j])
    return sorted(res)

if __name__=='__main__':
    import doctest
    doctest.testmod(verbose=True)

def fusio(v1, v2):
	fusionada = []
	for i in range(max(len(v1),len(v2))):
		try:
			fusionada.append(v1[i])
		except:
			pass
		try:
			fusionada.append(v2[i])
		except:
			pass
	return fusionada
			

def fusio(v1,v2):
    res=[]
    i, j = 0, 0
    while i<len(v1) and j<len(v2):
        if v1[i]<=v2[j]:
            res.append(v1[i])
            i+=1
        else:
            res.append(v2[j])
            j+=1
    while i<len(v1):
        res.append(v1[i])
        i+=1
    while j<len(v2):
        res.append(v2[j])
        j+=1
    return res

def fusio(a, b):
      i, j = 0, 0
      c = []
      while i + j < len(a) + len(b):
            if a[i] < b[j]: 
                  c.append(a[i])
                  i += 1
                  if i == len(a):
                        c.extend(b[j:])
                        break
            else:
                  c.append(b[j])
                  j += 1
                  if j == len(b):
                        c.extend(a[i:])
                        break
      return c

                