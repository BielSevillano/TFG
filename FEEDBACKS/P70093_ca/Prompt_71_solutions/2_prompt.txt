
                Write a feedback text for the following program that solves the problem described below.
                
                                Fusió de taules

Feu una funció que fusioni els vectors ordenats @v1@ i @v2@ i en retorni
el resultat, sense eliminar els elements repetits. Per exemple, el
resultat de fusionar una taula amb 2, 3 i 5 amb una taula amb 3, 5, 5 i
7 és una taula amb 2, 3, 3, 5, 5, 5 i 7.

Interfície

+-------:+:------------------------------------------------------------------------------+
| C++    |     vector<double> fusio(const vector<double>& v1, const vector<double>& v2); |
+--------+-------------------------------------------------------------------------------+
| Java   |     public static double[] fusio(double[] v1, double[] v2);                   |
+--------+-------------------------------------------------------------------------------+
| Python |     fusio(v1, v2)  # returns list                                             |
+--------+-------------------------------------------------------------------------------+
| MyPy   |     fusio(v1: list[float], v2: list[float]) -> list[float]                    |
+--------+-------------------------------------------------------------------------------+

Precondició

@v1@ i @v2@ estan ordenats de petit a gran.

Observació

Només cal enviar el procediment demanat; el programa principal serà
ignorat.

Autor

Salvador Roura

© Jutge.org, 2006–2025.


                

                This is the program:

                def fusio(v1: list[float], v2: list[float]) -> list[float]:
    n1,n2 = len(v1), len(v2)
    i1, i2 = 0, 0
    R:list[float] = list()
    while i1 < n1 and i2 < n2:
        if v1[i1] <= v2[i2]:
            R.append(v1[i1])
            i1 += 1
        else:
            R.append(v2[i2])
            i2 += 1
    R.extend(v1[i1:])
    R.extend(v2[i2:])
    return R

                The result of the program is: Accepted

                The feedback should include:
                - A brief summary of the problem and the solution approach.
                - An analysis of the code's strengths and weaknesses.
                - Suggestions for improvement, if any.

                You can rely on the following other possible solutions to the same problem for reference:
                import doctest


def fusio(v1, v2):
    '''
    Retorna una llista ordenada amb la fusio (sense
    eliminar els elements repetits) dels vectors ordenats
    v1 i v2, representats com a llistes.

    >>> fusio([2, 3, 5], [3, 5, 5, 7])
    [2, 3, 3, 5, 5, 5, 7]
    
    '''
    l = []
    i = 0
    j = 0
    while i < len(v1) and j < len(v2):
        if v1[i] < v2[j]:
            l.append(v1[i])
            i += 1
        elif v1[i] > v2[j]:
            l.append(v2[j])
            j += 1
        else:
            l.append(v1[i])
            l.append(v2[j])
            i += 1
            j += 1
    while i < len(v1):
        l.append(v1[i])
        i += 1
    while j < len(v2):
        l.append(v2[j])
        j += 1   
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

import doctest


def fusio(v1, v2):
    '''
    Retorna una llista ordenada amb la fusio (sense
    eliminar els elements repetits) dels vectors ordenats
    v1 i v2, representats com a llistes.

    >>> fusio([2, 3, 5], [3, 5, 5, 7])
    [2, 3, 3, 5, 5, 5, 7]

    '''
    l = []
    i = 0
    j = 0
    while i != len (v1) and j != len (v2):
        if v1[i] < v2 [j]:
            l.append(v1[i])
            i = i+1
        elif v2[j] < v1[i]:
            l.append(v2[j])
            j = j+1
        else:
            l.append(v1[i])
            l.append(v2[j])
            i = i+1
            j = j+1
    while i < len (v1):
        l.append(v1[i])
        i = i+1
    while j < len (v2):
        l.append(v2[j])
        j = j+1
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

import doctest


def fusio(v1, v2):
    '''
    Retorna una llista ordenada amb la fusio (sense
    eliminar els elements repetits) dels vectors ordenats
    v1 i v2, representats com a llistes.

    >>> fusio([2, 3, 5], [3, 5, 5, 7])
    [2, 3, 3, 5, 5, 5, 7]

    '''
    l = []
    
    i = 0
    j = 0
    while i < len(v1) and j < len(v2):
        if v1[i] < v2[j]:
            l.append(v1[i])
            i = i + 1
        elif v2[j] < v1[i]:
            l.append(v2[j])
            j = j + 1
        else:
            l.append(v1[i])
            l.append(v2[j])
            i = i + 1
            j = j + 1

    while i < len(v1):
        l.append(v1[i])
        i = i + 1
    while j < len(v2):
        l.append(v2[j])
        j =  j + 1
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

import doctest


def fusio(v1, v2):
    '''
    Retorna una llista ordenada amb la fusio (sense
    eliminar els elements repetits) dels vectors ordenats
    v1 i v2, representats com a llistes.

    >>> fusio([2, 3, 5], [3, 5, 5, 7])
    [2, 3, 3, 5, 5, 5, 7]

    '''
    l = []
    i= 0
    j=0 
    while i<len(v1) and j<len(v2):
        if v1[i]< v2[j]:
            l.append(v1[i])
            i = i+1
        elif v2[j]<v1[i]:
            l.append(v2[j])
            j=j+1
        else:
            l.append(v1[i])
            l.append(v2[j])
            i = i+1
            j=j+1
    while i<len(v1):
        l.append(v1[i])
        i=i+1
    while j<len(v2):
        l.append(v2[j])
        j=j+1
    return l
    

if __name__ == "__main__":
    doctest.testmod(verbose=True)

import doctest


def interseccio(v1, v2):
    '''
    Retorna una llista ordenada amb la interseccio
    dels vectors ordenats v1 i v2, sense repetits.
    >>> interseccio([1, 2, 2, 5, 5, 7], [2, 3, 3, 7])
    [2, 7]
    >>> interseccio([2, 3, 3, 7], [1, 2, 2, 5, 5, 7])
    [2, 7]
    >>> interseccio([], [1, 2, 2])
    []
    >>> interseccio([1, 1, 1], [1, 1, 1, 2, 2])
    [1]
    >>> interseccio([1, 1, 1, 2, 2], [1, 1, 1])
    [1]
    >>> interseccio([1, 3, 5], [1, 3, 5])
    [1, 3, 5]
    '''
    l = []

    i=0
    j=0
    while i<len(v1) and j<len(v2):
        if v1[i]<v2[j]:
            i=i+1
        elif v2[j]<v1[i]:
            j=j+1
        else:
            if len(l)==0 or l[-1] !=v1[i]:
                l.append(v1[i])
            i=i+1
            j=j+1
            
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

def merge(a,b):
    res=[]
    i,j=0,0

    while i<len(a) and j < len(b):
        if a[i]<b[i]:
            res.append(a[i])
            i+=1
        elif a[i]>b[i]:
            res.append(b[j])
            j+=1
    while i<len(a):
        res.append(a[i])
        i+=1
    while j<len(b):
        res.append(b[j])
        j+=1
    return res
    

def merge(v1, v2):
    res=[]
    i, j=0
    while i<len(v1) and j<len(v2):
        if v1[i]<=v2[j]:
            res.append(v1[i])
            i+=1
        else:
            res.append(v2[i])
            j+=1
    while i<len(v1):
        res.append(v1[i])
        i+=1
    while j<len(v2):
        res.append(v2[j])
        j+=1
    return res
        
       

def merge(v1,v2):
    res = []
    i = 0
    j = 0
    while i < len(v1) and j < len(v2):
        if v1[i] <= v2[j]:
            res.append(v1[i])
            i += 1
        else:
            res.append(v2[j])
            j += 1
    while i < len(v1):
        res.append(v1[i])
        i += 1
    while j < len(v2):
        res.append(v2[j])
        j += 1
    return res

def merge(v1,v2):
    '''
    >>> merge([2,3,5],[3,3,5,7])
    [2, 3, 3, 3, 5, 5, 7]
    '''
    res=[]
    for i in range(len(v1)):
        res.append(v1[i])
    for j in range(len(v2)):
        res.append(v2[j])
    return sorted(res)

if __name__=='__main__':
    import doctest
    doctest.testmod(verbose=True)

def ordenar(v1,v2):
    res=[]
    i,j=0,0
    while i < len(v1) and j <len(v2):
        if v1[i] <= v2[j]:
            res.append(v1[i])
            i += 1
        else:
            res.append(v2[j])
            j+=1
            
    while i<len(v1):
        res.append(v1[i])
        i +=1
        
    while j<len(v2):
        res.append(v2[j])
        j+=1
    return res
            
                
             
        
    
        

def max_overlap(u,v):
    '''
    >>> max_overlap('bugs','bunny')
    'bu'
    '''
    i=0
#    while i<len(u) and i<len(v):
#        if u[i]==v[i]:
#            i+=1
#        else:
#            return u[:i]
    while i<len(u) and i<len(v) and u[i]==v[i]:
        i+=1
    return u[:i]

def merge(v1,v2):
    '''
    >>> merge([2,3,5],[3,3,5,7])
    [2, 3, 3, 3, 5, 5, 7]
    '''
    res=[]
    i,j=0,0
    while i<len(v1) and j<len(v2):
        if v1[i] < v2[j]:
            res.append(v1[i])
            i+=1
            
        else:
            res.append(v2[j])
            j+=1
    while i < len(v1):
        res.append(v1[i])
        i+=1
    while j < len(v2):
        res.append(v2[j])
        j+=1
    return res

if __name__=='__main__':
    import doctest
    doctest.testmod(verbose=True)
            

def fusio(v1,v2):
    res=[]
    i, j = 0, 0
    while i<len(v1) and j<len(v2):
        if v1[i]<=v2[j]:
            res.append(v1[i])
            i+=1
        else:
            res.append(v2[j])
            j+=1
    while i<len(v1):
        res.append(v1[i])
        i+=1
    while j<len(v2):
        res.append(v2[j])
        j+=1
    return res

import doctest


def fusio(v1, v2):
    '''
    Retorna una llista ordenada amb la fusio (sense
    eliminar els elements repetits) dels vectors ordenats
    v1 i v2, representats com a llistes.

    >>> fusio([2, 3, 5], [3, 5, 5, 7])
    [2, 3, 3, 5, 5, 5, 7]

    '''
    l = []
    
    i = 0
    j = 0
    while i < len(v1) and j < len(v2):
        if v1[i] < v2 [j]:
            l.append (v1[i])
            i = i + 1
        elif v2[j] < v1[i]:
            l.append (v2[j])
            j = j + 1
        else:
            l.append (v1[i])
            i = i + 1
            l.append (v2[j])
            j = j + 1

    while i < len (v1):
        l.append (v1[i])
        i+=1
    while j < len (v2):
        l.append (v2[j])
        j+=1     
    
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

import doctest


def fusio(v1, v2):
    '''
    Retorna una llista ordenada amb la fusio (sense
    eliminar els elements repetits) dels vectors ordenats
    v1 i v2, representats com a llistes.

    >>> fusio([2, 3, 5], [3, 5, 5, 7])
    [2, 3, 3, 5, 5, 5, 7]

    '''
    l = []
    i=0
    j=0
    while i<len(v1) and j<len(v2):
        if v1[i]<v2[j]:
            l.append(v1[i])
            i=i+1
        elif v2[j]<v1[i]:
            l.append(v2[j])
            j=j+1
        else:
            l.append(v1[i])
            i=i+1
            l.append(v2[j])
            j+=1
    while i<len(v1):
        l.append(v1[i])
        i+=1
    while j<len(v2):
        l.append(v2[j])
        j+=1
          
    return l

if __name__ == "__main__":
    doctest.testmod(verbose=True)

def fusio(a, b):
      i, j = 0, 0
      c = []
      while i + j < len(a) + len(b):
            if a[i] < b[j]: 
                  c.append(a[i])
                  i += 1
                  if i == len(a):
                        c.extend(b[j:])
                        break
            else:
                  c.append(b[j])
                  j += 1
                  if j == len(b):
                        c.extend(a[i:])
                        break
      return c

from jutge import read


def merge(v1, v2):
    aux = []
    i = j = 0
    n = len(v1)
    m = len(v2)
    while i < n and j < m:
        if v1[i] < v2[j]:
            aux.append(v1[i])
            i = i + 1
        else:
            aux.append(v2[j])
            j = j + 1
    if i < n:
        while i < n:
            aux.append(v1[i])
            i = i + 1
    else:
        while j < m:
            aux.append(v2[i])
            j = j + 1
    return aux


def main():
    v1 = [2, 3, 5]
    v2 = [2, 3, 3, 5, 5, 5, 7]
    F = merge(v1, v2)
    for i in range(len(F)):
        print(F[i], '', end="")
main()

from jutge import read


def merge(v1, v2):
    aux = []
    i = j = 0
    n = len(v1)
    m = len(v2)
    while i < n and j < m:
        if v1[i] < v2[j]:
            aux.append(v1[i])
            i = i + 1
        else:
            aux.append(v2[j])
            j = j + 1
    while i < n:
            aux.append(v1[i])
            i = i + 1
    while j < m:
            aux.append(v2[j])
            j = j + 1
    return aux


def main():
    v1 = [2, 3, 5]
    v2 = [2, 3, 3, 5, 5, 5, 7]
    F = merge(v1, v2)
    for i in range(len(F)):
        print(F[i], '', end="")
main()



def fusio(v1, v2):
    R = []
    n = len(v1)
    m = len(v2)
    i = 0
    j = 0
    while i < n and j < m:
        if v1[i] <= v2[j]:
            R.append(v1[i])
            i += 1
        else:
            R.append(v2[j])
            j += 1
    while i < n:
        R.append(v1[i])
        i += 1
    while j < m:
        R.append(v2[j])
        j += 1
    return R

from easyinput import read


def fusio(v1, v2):
    n = len(v1)
    m = len(v2)
    v = []
    i = 0
    j = 0
    while i < n and j < m:
        if v1[i] < v2[j]:
            v.append(v1[i])
            i += 1
        else:
            v.append(v2[j])
            j += 1
    while i < n:
        v.append(v1[i])
        i += 1
    while j < m:
        v.append(v2[j])
        j += 1
    return v

from easyinput import read

def fusio(v1, v2):
    v = v1 + v2
    v.sort()
    return v

from easyinput import read


def fusio(v1, v2):
    """retorna la fusio de dos vectors ordenats creixentment"""
    n1 = len(v1)
    n2 = len(v2)
    v = []
    i = 0
    j = 0
    while i < n1 and j < n2:
        if v1[i] <= v2[j]:
            v.append(v1[i])
            i += 1
        else:
            v.append(v2[j])
            j += 1
    v.extend(v1[i:])
    v.extend(v2[j:])
    return v


"""def main():
    n1 = read(int)
    v1 = []
    for i in range(0, n1):
        v1[i] = read(float)
    n2 = read(int)
    v2 = []
    for i in range(0, n2):
        v2[i] = read(float)
    print(fusio(v1, v2))


main()
"""

from easyinput import read

def fusio(v1, v2):
    i = 0
    j = 0
    fusio = []
    while i < len(v1) and j < len(v2):
        if v1 [i] >= v2 [j]:
             fusio.append (v2 [j])
             j += 1
        else:
            fusio.append (v1 [i])
            i += 1
    while i < len (v1):
        fusio.append (v1 [i])
        i += 1
    while j < len (v2):
        fusio.append (v2 [j])
        j += 1
    return fusio

from easyinput import read


def fusio(v1: list, v2: list):
    i = 0
    j = 0
    S = []
    while i < len(v1) and j < len(v2):
        if v1[i] < v2[j]:
            S.append(v1[i])
            i += 1
        else:
            S.append(v2[j])
            j += 1
    while i < len(v1):
        S.append(v1[i])
        i += 1
    while j < len(v2):
        S.append(v2[j])
        j += 1
    return S


def main():
    v1 = []
    size1 = read(int)
    for i in range(size1):
        v1.append(read(float))
    v2 = []
    size2 = read(int)
    for i in range(size2):
        v2.append(read(float))
    print(fusio(v1, v2))

#include <iostream>
#include <vector>
using namespace std;

// Retorna la fusió ordenada de dos vectors ordenats.
// precondició: v1 i v2 estàn ordenats.
vector<double> fusio(const vector<double>& v1, const vector<double>& v2)
{
    vector<int> v;
    int i = 0;
    int j = 0;

    while (i < v1.size() and j < v2.size()) {
        if (v1[i] <= v2[j]) {
            v.push_back(v1[i]);
            ++i;
        } else {
            v.push_back(v2[j]);
            ++j;
        }
    }
    while (j < v2.size()) {
        v.push_back(v2[j]);
        ++j;
    }
    while (i < v1.size()) {
        v.push_back(v1[i]);
        ++i;
    }
    return v;
}

def fusio(v1, v2):
	i = 0;
	j = 0;
	n1 = len(v1)
	n2 = len(v2)
	v = []
	while i < n1 and j < n2:
		if v1[i] <= v2[j]:
			v.append(v1[i])
			i = i + 1
		else:
			v.append(v2[j])
			j = j + 1
	while j < n2:
			v.append(v2[j])
			j = j + 1
	while i < n1:
		v.append(v1[i]);
		i = i + 1		
	return v

def main():
	v1 = [2,  3, 5]
	v2 = [3, 5, 5, 7]
	print(fusio(v1, v2))
	
main()

#include <iostream>
#include <vector>
using namespace std;

vector<double> fusio(const vector<double>& v1, const vector<double>& v2) {
	int it1 = 0, it2 = 0;
	vector<double> r;
	while(it1 < v1.size() and it2 < v2.size()) {
		if(v1[it1] < v2[it2]) {
			r.push_back(v1[it1]);
			r.push_back(v2[it2]);
		}
		else {
			r.push_back(v2[it2]);
			r.push_back(v1[it1]);
		}
		it1++; it2++;
	}
	while(it1 < v1.size()) {
		r.push_back(v1[it1]);
		it1++;
	}
	while(it2 < v2.size()) {
		r.push_back(v2[it2]);
		it2++;
	}
	return r;
}

int main() {}
#include <iostream>
#include <vector>
using namespace std;

vector<double> fusio(const vector<double>& V1, const vector<double>& V2)
{
    vector<double> v;
    int n1 = V1.size();
    int n2 = V2.size();
    int i = 0, j = 0;
    while ((i < n1) and (j < n2)) {
        if (V1[i] < V2[j]) {
            v.push_back(V1[i]);
            ++i;
        } else {
            v.push_back(V2[j]);
            ++j;
        }
    }
    while (i < n1) {
        v.push_back(V1[i]);
        ++i;
    }
    while (j < n2) {
        v.push_back(V2[j]);
        ++j;
    }
    return v;
}

int main()
{
    cout.setf(ios::fixed, ios::floatfield);
    cout.precision(1);

    int n1;
    while (cin >> n1) {
        vector<double> V1(n1);
        for (int i = 0; i < n1; ++i)
            cin >> V1[i];
        int n2;
        cin >> n2;
        vector<double> V2(n2);
        for (int i = 0; i < n2; ++i)
            cin >> V2[i];

        vector<double> res = fusio(V1, V2);
        int n3 = res.size();
        cout << n3 << endl;
        for (int i = 0; i < n3; ++i)
            cout << " " << res[i];
        cout << endl
             << endl;

        for (int r = 0; r < 200; ++r) {
            vector<double> res2 = fusio(V1, V2);
            if (res2 != res)
                cout << "Resultats diferents amb la mateixa entrada!" << endl;
        }
    }
}


# SELECTION
"""
def position_maximum(v, m):
    p = 0
    i = 1
    while i <= m:
        if v[i] > v[p]:
            p = i
        i=i+1
    return p

def selection_sort(v, m):
    if m >= 0:
        p = position_maximum(v,m)
        v[p], v[m] = v[m], v[p]
        selection_sort(v,m-1)

v = [2,4,5,76,1,98765]
selection_sort(v,len(v) - 1)
print(v)
"""


# INSERTION
"""
def insert_1_element(u):
    j = len(v) - 1
    while j >= 0 and v[j-1] > v[j]:
        v[j-1],v[j] = v[j],v[j-1]
        j = j - 1

v = [2, 4, 7, 7, 8, 9, 5]
insert_1_element(v)
print(v)
"""


"""
def insertion_sort(v):
    n = len(v)
    for i in range(1,n):
        j = i
        while j > 0 and v[j-1] > v[j]:
            v[j-1],v[j] = v[j],v[j-1]
            j = j - 1

v = [7,6,1,8,2,6,3,8,2,8]
insertion_sort(v)
print(v)
"""


# FUSION

def merge(v1, v2):
    n1 = len(v1)
    n2 = len(v2)
    i1 = i2 = k = 0
    v = [0 for i in range(n1 + n2)]
    while i1 < n1 and i2 < n2:
        if(v1[i1] <= v2[i2]):
            v[k] = v1[i1]
            i1 = i1 + 1
        elif(v1[i1] >= v2[i2]):
            v[k] = v1[i1]
            i1 = i1 + 1
        k = k + 1
    while i1 < n1:
        v[k] = v1[i1]
        i1 = i1 + 1
        k = k + 1
    while i2 < n2:
        v[k] = v2[i2]
        i2 = i2 + 1
        k = k + 1
    return v


v1 = [2,3,3,5,5,7]
v2 = [3,5,5,7]
v = merge(v1,v2)
print(v)





#

from easyinput import read


def fusio(v1, v2)  # returns list

n = len(v1)
m = len(v2)
s = m+n

lst = []*s

i = 0
j = 0
k = 0

while (i < n and j < m):
        if v1[i] == v2[j]:
            lst[k] = v1[i]:
            i = i + 1
            j = j + 1
        elif v1[i] > v2[j]:
            lst[k] = v2[j]:
            j = j + 1
        else
            lst[k] = v1[i]:
            i = i + 1
        }
        k = j + 1
    while (i < n):
        lst[k] = v1[i];
        k = k + 1
        i = i + 1
    }
    while (j < m):
        lst[k] = v2[j];
        k = k + 1
        j = j + 1
    }
    return lst;
}

from easyinput import*

def fusio(v1, v2):
    n = len(v1)
    m = len(v2)
    i = 0
    j = 0
    g = []
    while(i < n and j < m):
        if v1[i] <= v2[j]:
            g.append(v1[i])
            i = i + 1
        else:
            g.append(v2[j])
            j = j + 1
    for k in range (i, n):
        g.append(v1[k])
    for k in range (j, m):
        g.append(v2[k])
        
    return g

def main():
    v1 = [2, 3, 5]
    v2 = [3, 5, 5, 7]
    g = fusio(v1, v2)
    print(g)

main()

from easyinput import*

def fusio(v1, v2):
    n = len(v1)
    m = len(v2)
    i = 0
    j = 0
    g = []
    while(i < n and j < m):
        if v1[i] <= v2[j]:
            g.append(v1[i])
            i = i + 1
        else:
            g.append(v2[j])
            j = j + 1
    for k in range (i, n):
        g.append(v1[k])
    for k in range (j, m):
        g.append(v2[k])

    return g

from yogi import tokens

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    v3: list[float] = list()
    i = 0
    n1 = len(v1) - 1
    j = 0
    n2 = len(v2) - 1
    while i <= n1 and j <= n2:
        if v1[i] < v2[j]:
            v3.append(v1[i])
            i += 1
        elif v2 [j] < v1[i]:
            v3.append(v2[j])
            j += 1
        else:
            v3.append(v2[j])
            v3.append(v1[i])
            i += 1
            j += 1
    return v3

def main() -> None:
    v1 = list(tokens(float))
    v2 = list(tokens(float))
    v3 = fusio(v1, v2)
    print(v3)

if __name__ == '__main__':
    main()
from yogi import read

def llegir_dades(n: int) -> list[float]:
    v: list[float] = list()
    for i in range(n):
        v.append(read(float))
    return v
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    v3: list[float] = list()
    i = 0
    n1 = len(v1) - 1
    j = 0
    n2 = len(v2) - 1
    while i <= n1 and j <= n2:
        if v1[i] < v2[j]:
            v3.append(v1[i])
            i += 1
        elif v2 [j] < v1[i]:
            v3.append(v2[j])
            j += 1
        else:
            v3.append(v2[j])
            v3.append(v1[i])
            i += 1
            j += 1
    if i > n1:
        v3.append(v2[j])
    elif j > n2:
        v3.append(v1[i])
    return v3

def main() -> None:
    n1 = read(int)
    v1 = llegir_dades(n1)
    n2 = read(int)
    v2 = llegir_dades(n2)
    v3 = fusio(v1, v2)
    print(n1 + n2)
    print(v3)

if __name__ == '__main__':
    main()
def fusio(v1, v2):
    v3: list(int) = []
    i = 0
    j = 0
    while i < len(v1) and j < len(v2):
        if v1[i] <= v2[j]:
            v3.append(v1[i])
            i += 1
        else:
            v3.append(v2[j])
            j +=1

            
    if i == len(v1):
        for p in range(j, len(v2)):
            v3.append(v2[p])
    if j == len(v2):
        for p in range(i, len(v1)):
            v3.append(v1[p])

    return v3

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    F:list[float] = []
    if len(v1) == 0 and len(v2) == 0:
        return F 
    elif len(v1) == 0:
        return F + v2
    elif len(v2) == 0:
        return F + v1
    
    elif v1[0] > v2[0]:
        F.append(v2[0])
        del v2[0]
    else:
        F.append(v1[0])
        del v1[0]
    
    return F + fusio(v1, v2)

def main():
    v1 = [1.0,2.0,2.0,3.0,5.0,5.0,6.0]
    v2 = [2.0,3.0,7.0,8.0]
    print(fusio(v1, v2))

if __name__ == "__main__":
    main()

from typing import TypeVar
T = TypeVar('T')


def fusio(v1: list[T], v2: list[T]) -> list[T]:

    "retorna una llista resultat de la fusio de dues llistes previament ordenades"

    n1, n2 = len(v1), len(v2)
    i1, i2 = 0, 0       #indexos que permetran operar amb les llistes
    R: list[T] = []

    while i1 < n1 and i2 < n2: #mentre no haguem arribat al final de cap de les dues llistes

        if v1[i1] <= v2[i2]:
            R.append(v1[i1])
        else:
            R.append(v2[i2])
        
    R.extend(v1[i1:])
    R.extend(v2[i2:])


    return R


    


from yogi import tokens, read

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    F:list[float] = []
    if len(v1) == 0 and len(v2) == 0:
        return F 
    elif len(v1) == 0:
        return F + v2
    elif len(v2) == 0:
        return F + v1
    
    elif v1[0] > v2[0]:
        F.append(v2[0])
        del v2[0]
    else:
        F.append(v1[0])
        del v1[0]
    
    return F + fusio(v1, v2)
def llegir_dades(i)->list[float]:
    L:list[float] = []
    for x in range(i):
        x= read(float)
        L.append(x)
    return L
def main():
    i = read(int)
    v1:list[float] = llegir_dades(i)
    j = read(int)
    
    v2:list[float] = llegir_dades(j)
    print(fusio(v1, v2))

if __name__ == "__main__":
    main()
from yogi import read

def llegir_dades(n: int) -> list[float]:
    v: list[float] = list()
    for i in range(n):
        v.append(read(float))
    return v

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    v3: list[float] = list()
    i = 0
    n1 = len(v1) - 1
    j = 0
    n2 = len(v2) - 1
    while i <= n1 and j <= n2:
        if v1[i] <= v2[j]:
            v3.append(v1[i])
            i += 1
        else:
            v3.append(v2[j])
            j += 1
    v3.extend(v1[i:])
    v3.extend(v2[j:])
    return v3

def main() -> None:
    n1 = read(int)
    v1 = llegir_dades(n1)
    n2 = read(int)
    v2 = llegir_dades(n2)
    v3 = fusio(v1, v2)
    print(n1 + n2)
    print(v3)

if __name__ == '__main__':
    main()
from yogi import tokens, read

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    S:list[float] = []
    i = 0
    j = 0
    l1 = len(v1)
    l2 = len(v2)
    while i < l1 and j < l2:
        if v1[i] < v2[j]:
            S.append(v1[i])
            i += 1
        elif v1[i] > v2[j]:
            S.append(v2[j])
            j += 1
        else:
            S.append(v1[i])
            S.append(v1[i])
            j += 1
            i += 1

    S.extend(v1[i:])
    S.extend(v2[j:])

    return S
def llegir_dades(i)->list[float]:
    L:list[float] = []
    for x in range(i):
        x= read(float)
        L.append(x)
    return L
def main():
    i = read(int)
    v1:list[float] = llegir_dades(i)
    j = read(int)
    
    v2:list[float] = llegir_dades(j)
    print(fusio(v1, v2))

if __name__ == "__main__":
    main()
from yogi import read

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    n1,n2=len(v1), len(v2)
    i1,i2=0,0
    R=[]
    while i1<n1 and i2<n2:
        if v1[i1]<=v2[i2]:
            R.append(v1[i1])
            i1+=1
        else:
            R.append(v2[i2])
            i2+=1
    R.extend(v1[i1:])
    R.extend(v2[i2:])
    return R

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    i,j = 0,0
    L:list[float]=list()
    l1 = len(v1)
    l2 = len(v2)
    while i < l1 and j < l2:
        if v1[i] >= v2[j]:
            L.append(v1[i])
            i+=1
        else:
            L.append(v2[j])
            j+=1
    L.extend(v1[i:])
    L.extend(v2[j:])

from yogi import read


def fusio(v1: list[float], v2: list[float]) -> list[float]:
    i,j = 0,0
    L:list[float]=list()
    l1 = len(v1)
    l2 = len(v2)
    while i < l1 and j < l2:
        if v1[i] <= v2[j]:
            L.append(v1[i])
            i+=1
        else:
            L.append(v2[j])
            j+=1
    L.extend(v1[i:])
    L.extend(v2[j:])
    return L

def main() -> None:
    n1 = read(int)
    v1:list[float]=list()
    v2:list[float]=list()


    for _ in range(n1):
        v1.append(read(float))
    
    n2 = read(int)

    for _ in range(n2):
        v2.append(read(float))
    
    v3 = fusio(v1,v2)
    print(v3)


if __name__=='__main__': 
    main()

def ordena_per_fusio(v: list[float]) -> None:
    ordena_rec(v, 0, len(v) - 1)


def ordena_rec(v: list[float], esq: int, dre: int) -> None:
    if esq < dre:
        mig=(esq+dre)//2
        ordena_rec(v, esq, mig)
        ordena_rec(v, mig + 1, dre)
        fusio(v, esq, mig, dre)


def fusio(v: list[float], esq: int, mig: int, dre: int) -> None:
   
   v1=v[0:0]
   i,j = esq,mig+1
   while i <= mig and j <= dre:
    if v[i] <= v[j]:
        v1.append(v[i])
        i += 1
    else:
        v1.append(v[j])
        j += 1
   v1.extend(v[i:mig + 1])
   v1.extend(v[j:dre + 1])

   v[esq:dre + 1] = v1
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    """Calcula la fusió ordenada de dues llistes ordenades."""

    v:list[float] = []
    i1, i2 = 0, 0
    while i1 < len(v1) and i2 < len(v2):
        if v1[i1] <= v2[i1]:
            v.append(v1[i1])
            i1 += 1
        else:
            v.append(v2[i2])
            i2 += 1
    v.extend(v1[i1:])
    v.extend(v2[i2:])
    return v
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    """Calcula la fusió ordenada de dues llistes ordenades."""
    n1,n2 = len(v1), len(v2)
    R:list[float] = list()
    i1, i2 = 0, 0
    while i1 < n1 and i2 < n2:
        if v1[i1] <= v2[i1]:
            R.append(v1[i1])
            i1 += 1
        else:
            R.append(v2[i2])
            i2 += 1
    R.extend(v1[i1:])
    R.extend(v2[i2:])
    return R
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    n1,n2 = len(v1), len(v2)
    R:list[float] = list()
    i1, i2 = 0, 0
    while i1 < n1 and i2 < n2:
        if v1[i1] <= v2[i1]:
            R.append(v1[i1])
            i1 += 1
        else:
            R.append(v2[i2])
            i2 += 1
    R.extend(v1[i1:])
    R.extend(v2[i2:])
    return R
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    n1,n2 = len(v1), len(v2)
    i1, i2 = 0, 0
    R:list[float] = list()
    while i1 < n1 and i2 < n2:
        if v1[i1] <= v2[i2]:
            R.append(v1[i1])
            i1 += 1
        else:
            R.append(v2[i2])
            i2 += 1
    R.extend(v1[i1:])
    R.extend(v2[i2:])
    return R
from yogi import *
from typing import *

T = TypeVar('T')
#variable que representa un tipus qualsevol, pero totes les t = del mateix tipus, no pots fuisonar una llista de enters amb una llista de reals
#o de str

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    "posem t = que tot sigui el mateix tipu de variable"
    n1,n2 = len(v1),len(v2)
    i1,i2 = 0,0
    R: list[T] = [] #llista de la fusió
    while i1 < n1 and i2 < n2:
        if v1[i1] <= v2[i2]:
            R.append(v1[i1])
            i1 += 1
        else:
            R.append(v2[i2])
            i2 += 1
    R.extend(v1[i1:])
    R.extend(v2[i2:])
    return R




def  fusio(v1: list[float], v2: list[float]) -> list[float]:
    fusionada = []
    i = 0
    j = 0
    while i <= len(v1)-1 and j <= len(v2)-1:
        if v1[i]<= v2[j]:
            fusionada.append(v1[i])
            i +=1
        else:
            fusionada.append(v2[j])
            j +=1
    if i == len(v1):
        for _ in range(len(v2)-j):
            fusionada.append(v2[j])
            j +=1
    else:
        for _ in range(len(v1)-i):
            fusionada.append(v1[i])
  


def  fusio(v1: list[float], v2: list[float]) -> list[float]:
    fusionada = []
    i = 0
    j = 0
    while i <= len(v1)-1 and j <= len(v2)-1:
        if v1[i]<= v2[j]:
            fusionada.append(v1[i])
            i +=1
        else:
            fusionada.append(v2[j])
            j +=1
    if i == len(v1):
        for _ in range(len(v2)-j):
            fusionada.append(v2[j])
            j +=1
    else:
        for _ in range(len(v1)-i):
            fusionada.append(v1[i])
    return fusionada


  


def  fusio(v1: list[float], v2: list[float]) -> list[float]:
    fusionada = []
    i = 0
    j = 0
    if len(v1) == 0:
        return v2
    elif len(v2) == 0:
        return v1
    while i <= len(v1)-1 and j <= len(v2)-1:
        if v1[i]<= v2[j]:
            fusionada.append(v1[i])
            i +=1
        else:
            fusionada.append(v2[j])
            j +=1
    if i == len(v1):
        for _ in range(len(v2)-j):
            fusionada.append(v2[j])
            j +=1
    else:
        for _ in range(len(v1)-i):
            fusionada.append(v1[i])
    return fusionada




def  fusio(v1: list[float], v2: list[float]) -> list[float]:
    fusionada = []
    i = 0
    j = 0
    if len(v1) == 0 and len(v2) == 0:
        return []
    if len(v1) == 0:
        return v2
    elif len(v2) == 0:
        return v1
    while i <= len(v1)-1 and j <= len(v2)-1:
        if v1[i]<= v2[j]:
            fusionada.append(v1[i])
            i +=1
        else:
            fusionada.append(v2[j])
            j +=1
    if i == len(v1):
        for _ in range(len(v2)-j):
            fusionada.append(v2[j])
            j +=1
    else:
        for _ in range(len(v1)-i):
            fusionada.append(v1[i])
    return fusionada







def fusio(v1: list[float], v2: list[float]) -> list[float]:
    """Retorna una un vector fusionat fusionant v1 i v2"""
    idx_v1 = 0
    idx_v2 = 0
    vf: list[int] = list() #vf és el vector fusió
    while idx_v1 <= len(v1) - 1 and idx_v2 <= len(v2) - 1:
        if v1[idx_v1] <= v2[idx_v2]:
            vf.append(v1[idx_v1])
            idx_v1 += 1
        else:
            vf.append(v2[idx_v2])
            idx_v2 += 1

    if idx_v1 > len(v1) -1:
        vf.extend(v2[idx_v2:]) #Indica que ho esten desde l'índex fins al final  
          
    elif idx_v2 > len(v2) - 1:
        vf.extend(v1[idx_v1:]) 




def fusio(v1: list[float], v2: list[float]) -> list[float]:
    """Retorna una un vector fusionat fusionant v1 i v2"""
    idx_v1 = 0
    idx_v2 = 0
    vf: list[int] = list() #vf és el vector fusió
    while idx_v1 <= len(v1) - 1 and idx_v2 <= len(v2) - 1:
        if v1[idx_v1] <= v2[idx_v2]:
            vf.append(v1[idx_v1])
            idx_v1 += 1
        else:
            vf.append(v2[idx_v2])
            idx_v2 += 1

    if idx_v1 > len(v1) -1:
        vf.extend(v2[idx_v2:]) #Indica que ho esten desde l'índex fins al final  

    elif idx_v2 > len(v2) - 1:
        vf.extend(v1[idx_v1:]) 
    
    return vf



def fusio(v1: list[float], v2: list[float]) -> list[float]:
    """Donada dos llistes v1 i v2, retorna una llista ordenada que conté tots els elements d'ambdues llistes."""
    L: list[float] = []

    while v1 != [] and v2 != []:
        if v1[0] < v2[0]:
            L.append(v1[0])
            del v1[0]
        else:
            L.append(v2[0])
            del v2[0]
    
    return L + v1 + v2



def fusio(v1: list[float], v2: list[float]) -> list[float]:
    """Donades dues llistes ordenades, retorna una llista ordenada amb tots els seus elements"""

    n1, n2 = len(v1), len(v2)
    i1, i2 = 0, 0
    R: list[float] = []

    while i1 < n1 and i2 < n2:
        if v1[i1] <= v2[i2]:
            R.append(v1[i1])
            i1 += 1
        else:
            R.append(v2[i2])
            i2 += 1
    R.extend(v1[i1:])
    R.extend(v2[i2:])

    return R
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    i1 = 0
    i2 = 0
    llista_definitiva=[]
    while i1 < len(v1) and i2 < len(v2):
        if v1[i1] < v2[i2]:
            llista_definitiva.append(v1[i1])
            i1 += 1
        else:
            llista_definitiva.append(v2[i2])
            i2 += 1
    llista_definitiva.extend(v1[i1:])
    llista_definitiva.extend(v2[i2:])
    return llista_definitiva
def main():
    v1 = [1,2,2,5,5,7]
    v2 = [2,3,3,7]
    print(fusio(v1,v2))
main()

    
        


from yogi import read
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    i1 = 0
    i2 = 0
    llista_definitiva=[]
    while i1 < len(v1) and i2 < len(v2):
        if v1[i1] < v2[i2]:
            llista_definitiva.append(v1[i1])
            i1 += 1
        else:
            llista_definitiva.append(v2[i2])
            i2 += 1
    llista_definitiva.extend(v1[i1:])
    llista_definitiva.extend(v2[i2:])
    return llista_definitiva
def llegir_dades(n:int)->list[int]:
    """Llegeix tots els nombres i els afegeix a la llista"""
    L = []
    for i in range(n):
        x = read(float)
        L.append(x)
    return L
def main():
    n1 = read(int)
    v1 = llegir_dades(n1)
    n2 = read(int)
    v2 = llegir_dades(n2)
    print(fusio(v1,v2))
main() 
from yogi import read
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    i1 = 0
    i2 = 0
    llista_definitiva=[]
    while i1 < len(v1) and i2 < len(v2):
        if v1[i1] < v2[i2]:
            llista_definitiva.append(v1[i1])
            i1 += 1
        else:
            llista_definitiva.append(v2[i2])
            i2 += 1
    llista_definitiva.extend(v1[i1:])
    llista_definitiva.extend(v2[i2:])
    return llista_definitiva
def llegir_dades(n:int)->list[int]:
    """Llegeix tots els nombres i els afegeix a la llista"""
    L = []
    for i in range(n):
        x = read(float)
        L.append(x)
    return L
def main():
    n1 = read(int)
    v1 = llegir_dades(n1)
    n2 = read(int)
    v2 = llegir_dades(n2)
    print(n1+n2)
    print(" ",end="")
    print(*fusio(v1,v2))
main() 
from yogi import read
def fusio(v1: list[float], v2: list[float]) -> list[float]:
    i1 = 0
    i2 = 0
    llista_definitiva=[]
    while i1 < len(v1) and i2 < len(v2):
        if v1[i1] < v2[i2]:
            llista_definitiva.append(v1[i1])
            i1 += 1
        else:
            llista_definitiva.append(v2[i2])
            i2 += 1
    llista_definitiva.extend(v1[i1:])
    llista_definitiva.extend(v2[i2:])
    return llista_definitiva
def llegir_dades(n:int)->list[int]:
    """Llegeix tots els nombres i els afegeix a la llista"""
    L = []
    for i in range(n):
        x = read(float)
        L.append(x)
    return L

from typing import List

def merge(v1: list[float], v2: list[float]) -> list[float]:
    """Dona un vector ordenat a partir de dos"""

    L: List[float] = []

    mida1 = len(v1)
    mida2 = len(v2)

    i, j = 0, 0

    while i < mida1 and j < mida2:
        if v1[i] <= v2[j]:
            L.append(v1[i])
            i += 1
        else:
            L.append(v2[j])
            j += 1
    
    if i == mida1:
        for t in range(j,mida2):
            L.append(v2[t])
    else:
        for t in range(j,mida2):        
            L.append(v1[t])
    
    return L

if __name__ == "__main__":
    p = [2,4,6,8,10,13.0]
    s = [9,10,32.0]
    print(merge(p,s))
from typing import List
from yogi import read

def merge(v1: list[float], v2: list[float]) -> list[float]:
    """Dona un vector ordenat a partir de dos"""

    L: List[float] = []

    mida1 = len(v1)
    mida2 = len(v2)

    i, j = 0, 0

    while i < mida1 and j < mida2:
        if v1[i] <= v2[j]:
            L.append(v1[i])
            i += 1
        else:
            L.append(v2[j])
            j += 1
    
    if i == mida1:
        for t in range(j,mida2):
            L.append(v2[t])
    else:
        for t in range(j,mida2):        
            L.append(v1[t])
    
    return L

if __name__ == "__main__":
    p: List[float] = []
    s: List[float] = []
    x = read(int)
    for i in range(x):
        p.append(read(float))
    y = read(int)
    for i in range(y):
        s.append(read(float))
    print(x+y)
    print(*merge(p,s))
    print()
def fusio(v1, v2):
	fusionada = []
	for i in range(max(len(v1),len(v2))):
		try:
			fusionada.append(v1[i])
		except:
			pass
		try:
			fusionada.append(v2[i])
		except:
			pass
	return fusionada
			

def fusio(v1, v2):
	fusionada = []
	i1 = 0
	i2 = 0
	try:
		while i1 < max(len(v1),len(v2)) and i2 < max(len(v1),len(v2)):
			if v1[i1] < v2[i2]:
				fusionada.append(v1[i1])
				i1 += 1
			else:
				fusionada.append(v2[i2])
				i2 += 1
	except:
		if i1 == len(v1):
			while i2 < len(v2):
				fusionada.append(v2[i2])
				i2 += 1
		if i2 == len(v2):
			while i1 < len(v1):
				fusionada.append(v1[i1])
				i1 += 1
	return fusionada
			

def fusio(v1, v2):
	fusionada = []
	i1 = 0
	i2 = 0
	while i1 < len(v1) and i2 < len(v2):
		if v1[i1] < v2[i2]:
			fusionada.append(v1[i1])
			i1 += 1
		else:
			fusionada.append(v2[i2])
			i2 += 1
	if i1 == len(v1):
		while i2 != len(v2):
			fusionada.append(v2[i2])
			i2 += 1
	if i2 == len(v2):
		while i1 != len(v1):
			fusionada.append(v1[i1])
			i1 += 1
	return fusionada
		

def fusio(v1: list[float], v2: list[float]) -> list[float]:
    
    L: list[float] = []
    i, j = 0, 0

    while i < len(v1) and j < len(v2):
        if v1[i] <= v2[j]:
            L.append(v1[i])
            i += 1
        else:
            L.append(v2[j])
            j += 1
    L.extend(v1[i:])
    L.extend(v2[j:])

    return L



def fusio(v1: list[float], v2: list[float]) -> list[float]:
    v1.extend(v2)
    v1.sort()
    return v1


def fusio(v1:list[float], v2:list[float]) -> list[float]:
    fusio:list[float] = v1 + v2
    n = len(fusio)
    i = n
    while i != 0:
        p = 0
        for j in range(1, i):
            if fusio[j] > fusio[p]:
                p = j
        fusio[i - 1], fusio[p] = fusio[p], fusio[i - 1]
        i -= 1
    return fusio

from yogi import tokens
def fusio(v1: list, v2: list) -> list:
    v = []
    j = 0
    i = 0
    while i < len(v1) and j < len (v2):
        if v1[i] <= v2[j]:
            v.append (v1[i])
            i += 1
        else:
            assert v2[j] < v1 [i]
            v.append(v2[j])
            j += 1
    v.extend(v2[j::])
    v.extend (v1[i::])
    return v


def fusio(v1:list[float], v2:list[float]) -> list[float]:
    fusio:list[float] = []
    i, j = 0, 0
    while i < len(v1) and j < len(v2):
        if v1[i] <= v2[j]:
            fusio.append(v1[i])
            i += 1
        else:
            fusio.append(v2[j])
            j += 1
    fusio.extend(v1[i:])
    fusio.extend(v2[j:])
    return fusio


def fusio(l1: list[float], l2: list[float]) -> list[float]:
    '''
    Donades dues llistes ordenades, retorna la seva fusio ordenada.
    '''
    n1 = len(l1)
    n2 = len(l2)
    r: list[float] = []
    i, j = 0, 0
    while i < n1 and j < n2:
        if l1[i] <= l2[j]:
            r.append(l1[i])
            i += 1
        else:
            r.append(l2[j])
            j += 1
    r.extend(l1[i:])
    r.extend(l2[j:])
    return r
                